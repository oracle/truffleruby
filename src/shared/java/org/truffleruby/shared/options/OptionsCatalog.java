/*
 * Copyright (c) 2016, 2024 Oracle and/or its affiliates. All rights reserved. This
 * code is released under a tri EPL/GPL/LGPL license. You can use it,
 * redistribute it and/or modify it under the terms of the:
 *
 * Eclipse Public License version 2.0, or
 * GNU General Public License version 2, or
 * GNU Lesser General Public License version 2.1.
 */
package org.truffleruby.shared.options;

// GENERATED BY tool/generate-options.rb
// This file is automatically generated by options.yml with 'jt build options'

import org.graalvm.options.OptionCategory;
import org.graalvm.options.OptionDescriptor;
import org.graalvm.options.OptionKey;
import org.graalvm.options.OptionStability;

// @formatter:off
public final class OptionsCatalog {

    public static final OptionKey<String[]> LOAD_PATHS_KEY = new OptionKey<>(StringArrayOptionType.EMPTY_STRING_ARRAY, StringArrayOptionType.INSTANCE);
    public static final OptionKey<String[]> REQUIRED_LIBRARIES_KEY = new OptionKey<>(StringArrayOptionType.EMPTY_STRING_ARRAY, StringArrayOptionType.INSTANCE);
    public static final OptionKey<String> WORKING_DIRECTORY_KEY = new OptionKey<>(".");
    public static final OptionKey<Boolean> DEBUG_KEY = new OptionKey<>(false);
    public static final OptionKey<Verbosity> VERBOSITY_KEY = new OptionKey<>(Verbosity.FALSE);
    public static final OptionKey<String> SOURCE_ENCODING_KEY = new OptionKey<>("UTF-8");
    public static final OptionKey<String> INTERNAL_ENCODING_KEY = new OptionKey<>("");
    public static final OptionKey<String> EXTERNAL_ENCODING_KEY = new OptionKey<>("");
    public static final OptionKey<Integer> BACKTRACE_LIMIT_KEY = new OptionKey<>(-1);
    public static final OptionKey<String> LAUNCHER_KEY = new OptionKey<>("");
    public static final OptionKey<String> CORE_LOAD_PATH_KEY = new OptionKey<>("resource:/truffleruby");
    public static final OptionKey<Boolean> FROZEN_STRING_LITERALS_KEY = new OptionKey<>(false);
    public static final OptionKey<Boolean> RUBYGEMS_KEY = new OptionKey<>(true);
    public static final OptionKey<Boolean> DID_YOU_MEAN_KEY = new OptionKey<>(true);
    public static final OptionKey<Boolean> DEFAULT_LAZY_KEY = new OptionKey<>(true);
    public static final OptionKey<Boolean> LAZY_CALLTARGETS_KEY = new OptionKey<>(DEFAULT_LAZY_KEY.getDefaultValue());
    public static final OptionKey<Boolean> LAZY_RUBYGEMS_KEY = new OptionKey<>(DEFAULT_LAZY_KEY.getDefaultValue());
    public static final OptionKey<Boolean> EMBEDDED_KEY = new OptionKey<>(true);
    public static final OptionKey<Boolean> NATIVE_PLATFORM_KEY = new OptionKey<>(true);
    public static final OptionKey<Boolean> NATIVE_INTERRUPT_KEY = new OptionKey<>(NATIVE_PLATFORM_KEY.getDefaultValue());
    public static final OptionKey<Boolean> HANDLE_INTERRUPT_KEY = new OptionKey<>(!EMBEDDED_KEY.getDefaultValue());
    public static final OptionKey<Boolean> SINGLE_THREADED_KEY = new OptionKey<>(EMBEDDED_KEY.getDefaultValue());
    public static final OptionKey<Boolean> POLYGLOT_STDIO_KEY = new OptionKey<>(EMBEDDED_KEY.getDefaultValue() || !NATIVE_PLATFORM_KEY.getDefaultValue());
    public static final OptionKey<Boolean> HOST_INTEROP_KEY = new OptionKey<>(true);
    public static final OptionKey<Boolean> TRACE_CALLS_KEY = new OptionKey<>(true);
    public static final OptionKey<Boolean> COVERAGE_GLOBAL_KEY = new OptionKey<>(false);
    public static final OptionKey<Boolean> CORE_AS_INTERNAL_KEY = new OptionKey<>(false);
    public static final OptionKey<Boolean> STDLIB_AS_INTERNAL_KEY = new OptionKey<>(false);
    public static final OptionKey<Boolean> LAZY_TRANSLATION_USER_KEY = new OptionKey<>(LAZY_CALLTARGETS_KEY.getDefaultValue());
    public static final OptionKey<Boolean> PATCHING_KEY = new OptionKey<>(true);
    public static final OptionKey<Boolean> HASHING_DETERMINISTIC_KEY = new OptionKey<>(false);
    public static final OptionKey<Boolean> VIRTUAL_THREAD_FIBERS_KEY = new OptionKey<>(false);
    public static final OptionKey<Boolean> LOG_SUBPROCESS_KEY = new OptionKey<>(false);
    public static final OptionKey<Boolean> WARN_LOCALE_KEY = new OptionKey<>(true);
    public static final OptionKey<Boolean> EXCEPTIONS_STORE_JAVA_KEY = new OptionKey<>(false);
    public static final OptionKey<Boolean> EXCEPTIONS_PRINT_JAVA_KEY = new OptionKey<>(false);
    public static final OptionKey<Boolean> EXCEPTIONS_PRINT_UNCAUGHT_JAVA_KEY = new OptionKey<>(false);
    public static final OptionKey<Boolean> EXCEPTIONS_PRINT_RUBY_FOR_JAVA_KEY = new OptionKey<>(false);
    public static final OptionKey<Boolean> EXCEPTIONS_WARN_STACKOVERFLOW_KEY = new OptionKey<>(true);
    public static final OptionKey<Boolean> EXCEPTIONS_WARN_OUT_OF_MEMORY_KEY = new OptionKey<>(true);
    public static final OptionKey<Boolean> BACKTRACES_INTERLEAVE_JAVA_KEY = new OptionKey<>(false);
    public static final OptionKey<Boolean> BACKTRACES_OMIT_UNUSED_KEY = new OptionKey<>(true);
    public static final OptionKey<Boolean> BIG_HASH_STRATEGY_IS_BUCKETS_KEY = new OptionKey<>(true);
    public static final OptionKey<Boolean> BACKTRACE_ON_INTERRUPT_KEY = new OptionKey<>(false);
    public static final OptionKey<Boolean> BACKTRACE_ON_SIGALRM_KEY = new OptionKey<>(!EMBEDDED_KEY.getDefaultValue());
    public static final OptionKey<Boolean> BACKTRACE_ON_RAISE_KEY = new OptionKey<>(false);
    public static final OptionKey<Boolean> BACKTRACE_ON_RESCUE_KEY = new OptionKey<>(false);
    public static final OptionKey<Boolean> BACKTRACE_ON_NEW_THREAD_KEY = new OptionKey<>(false);
    public static final OptionKey<Boolean> BACKTRACE_ON_NEW_FIBER_KEY = new OptionKey<>(false);
    public static final OptionKey<Boolean> CEXTS_KEY = new OptionKey<>(true);
    public static final OptionKey<Boolean> CEXT_LOCK_KEY = new OptionKey<>(true);
    public static final OptionKey<Boolean> CEXTS_PANAMA_KEY = new OptionKey<>(false);
    public static final OptionKey<Boolean> OPTIONS_LOG_KEY = new OptionKey<>(false);
    public static final OptionKey<Boolean> LOG_LOAD_KEY = new OptionKey<>(false);
    public static final OptionKey<Boolean> LOG_AUTOLOAD_KEY = new OptionKey<>(false);
    public static final OptionKey<Boolean> LOG_FEATURE_LOCATION_KEY = new OptionKey<>(false);
    public static final OptionKey<Profile> METRICS_PROFILE_REQUIRE_KEY = new OptionKey<>(Profile.NONE);
    public static final OptionKey<Boolean> CEXTS_LOG_LOAD_KEY = new OptionKey<>(false);
    public static final OptionKey<Boolean> CEXTS_LOG_WARNINGS_KEY = new OptionKey<>(false);
    public static final OptionKey<Boolean> WARN_DEPRECATED_KEY = new OptionKey<>(false);
    public static final OptionKey<Boolean> WARN_EXPERIMENTAL_KEY = new OptionKey<>(true);
    public static final OptionKey<Boolean> WARN_PERFORMANCE_KEY = new OptionKey<>(false);
    public static final OptionKey<Boolean> USE_TRUFFLE_REGEX_KEY = new OptionKey<>(true);
    public static final OptionKey<Boolean> WARN_TRUFFLE_REGEX_COMPILE_FALLBACK_KEY = new OptionKey<>(false);
    public static final OptionKey<Boolean> WARN_TRUFFLE_REGEX_MATCH_FALLBACK_KEY = new OptionKey<>(false);
    public static final OptionKey<Boolean> TRUFFLE_REGEX_IGNORE_ATOMIC_GROUPS_KEY = new OptionKey<>(false);
    public static final OptionKey<String[]> REUSE_PRECOMPILED_GEMS_KEY = new OptionKey<>(StringArrayOptionType.EMPTY_STRING_ARRAY, StringArrayOptionType.INSTANCE);
    public static final OptionKey<Boolean> ARGV_GLOBALS_KEY = new OptionKey<>(false);
    public static final OptionKey<Boolean> CHOMP_LOOP_KEY = new OptionKey<>(false);
    public static final OptionKey<Boolean> GETS_LOOP_KEY = new OptionKey<>(false);
    public static final OptionKey<Boolean> PRINT_LOOP_KEY = new OptionKey<>(false);
    public static final OptionKey<Boolean> SPLIT_LOOP_KEY = new OptionKey<>(false);
    public static final OptionKey<Boolean> IGNORE_LINES_BEFORE_RUBY_SHEBANG_KEY = new OptionKey<>(false);
    public static final OptionKey<Boolean> SYNTAX_CHECK_KEY = new OptionKey<>(false);
    public static final OptionKey<String[]> ARGV_GLOBAL_VALUES_KEY = new OptionKey<>(StringArrayOptionType.EMPTY_STRING_ARRAY, StringArrayOptionType.INSTANCE);
    public static final OptionKey<String[]> ARGV_GLOBAL_FLAGS_KEY = new OptionKey<>(StringArrayOptionType.EMPTY_STRING_ARRAY, StringArrayOptionType.INSTANCE);
    public static final OptionKey<Boolean> BUILDING_CORE_CEXTS_KEY = new OptionKey<>(false);
    public static final OptionKey<Boolean> LAZY_TRANSLATION_LOG_KEY = new OptionKey<>(false);
    public static final OptionKey<Boolean> LOG_DYNAMIC_CONSTANT_LOOKUP_KEY = new OptionKey<>(false);
    public static final OptionKey<Boolean> LOG_PENDING_INTERRUPTS_KEY = new OptionKey<>(false);
    public static final OptionKey<Boolean> PRINT_INTERNED_TSTRING_STATS_KEY = new OptionKey<>(false);
    public static final OptionKey<Boolean> CEXTS_TO_NATIVE_STATS_KEY = new OptionKey<>(false);
    public static final OptionKey<Boolean> CEXTS_TO_NATIVE_COUNT_KEY = new OptionKey<>(CEXTS_TO_NATIVE_STATS_KEY.getDefaultValue());
    public static final OptionKey<Boolean> BACKTRACE_ON_TO_NATIVE_KEY = new OptionKey<>(false);
    public static final OptionKey<Boolean> CEXTS_KEEP_HANDLES_ALIVE_KEY = new OptionKey<>(false);
    public static final OptionKey<Boolean> CEXTS_SULONG_KEY = new OptionKey<>(false);
    public static final OptionKey<Boolean> LAZY_BUILTINS_KEY = new OptionKey<>(LAZY_CALLTARGETS_KEY.getDefaultValue());
    public static final OptionKey<Boolean> LAZY_TRANSLATION_CORE_KEY = new OptionKey<>(LAZY_CALLTARGETS_KEY.getDefaultValue());
    public static final OptionKey<Boolean> CHAOS_DATA_KEY = new OptionKey<>(false);
    public static final OptionKey<Boolean> INSTRUMENT_ALL_NODES_KEY = new OptionKey<>(false);
    public static final OptionKey<Boolean> BASICOPS_INLINE_KEY = new OptionKey<>(true);
    public static final OptionKey<Boolean> BASICOPS_LOG_REWRITE_KEY = new OptionKey<>(false);
    public static final OptionKey<Boolean> PROFILE_ARGUMENTS_KEY = new OptionKey<>(true);
    public static final OptionKey<Integer> DEFAULT_CACHE_KEY = new OptionKey<>(8);
    public static final OptionKey<Integer> METHOD_LOOKUP_CACHE_KEY = new OptionKey<>(DEFAULT_CACHE_KEY.getDefaultValue());
    public static final OptionKey<Integer> DISPATCH_CACHE_KEY = new OptionKey<>(DEFAULT_CACHE_KEY.getDefaultValue());
    public static final OptionKey<Integer> YIELD_CACHE_KEY = new OptionKey<>(DEFAULT_CACHE_KEY.getDefaultValue());
    public static final OptionKey<Integer> IS_A_CACHE_KEY = new OptionKey<>(DEFAULT_CACHE_KEY.getDefaultValue());
    public static final OptionKey<Integer> BIND_CACHE_KEY = new OptionKey<>(DEFAULT_CACHE_KEY.getDefaultValue());
    public static final OptionKey<Integer> CONSTANT_CACHE_KEY = new OptionKey<>(DEFAULT_CACHE_KEY.getDefaultValue());
    public static final OptionKey<Integer> INSTANCE_VARIABLE_CACHE_KEY = new OptionKey<>(DEFAULT_CACHE_KEY.getDefaultValue());
    public static final OptionKey<Integer> BINDING_LOCAL_VARIABLE_CACHE_KEY = new OptionKey<>(DEFAULT_CACHE_KEY.getDefaultValue());
    public static final OptionKey<Integer> SYMBOL_TO_PROC_CACHE_KEY = new OptionKey<>(DEFAULT_CACHE_KEY.getDefaultValue());
    public static final OptionKey<Integer> PACK_CACHE_KEY = new OptionKey<>(DEFAULT_CACHE_KEY.getDefaultValue());
    public static final OptionKey<Integer> UNPACK_CACHE_KEY = new OptionKey<>(DEFAULT_CACHE_KEY.getDefaultValue());
    public static final OptionKey<Integer> EVAL_CACHE_KEY = new OptionKey<>(DEFAULT_CACHE_KEY.getDefaultValue());
    public static final OptionKey<Integer> ENCODING_COMPATIBLE_QUERY_CACHE_KEY = new OptionKey<>(DEFAULT_CACHE_KEY.getDefaultValue());
    public static final OptionKey<Integer> ENCODING_LOADED_CLASSES_CACHE_KEY = new OptionKey<>(DEFAULT_CACHE_KEY.getDefaultValue());
    public static final OptionKey<Integer> INTEROP_CONVERT_CACHE_KEY = new OptionKey<>(DEFAULT_CACHE_KEY.getDefaultValue());
    public static final OptionKey<Integer> TIME_FORMAT_CACHE_KEY = new OptionKey<>(DEFAULT_CACHE_KEY.getDefaultValue());
    public static final OptionKey<Integer> POW_CACHE_KEY = new OptionKey<>(DEFAULT_CACHE_KEY.getDefaultValue());
    public static final OptionKey<Integer> IDENTITY_CACHE_KEY = new OptionKey<>(1);
    public static final OptionKey<Integer> CONTEXT_SPECIFIC_IDENTITY_CACHE_KEY = new OptionKey<>(IDENTITY_CACHE_KEY.getDefaultValue());
    public static final OptionKey<Integer> CLASS_CACHE_KEY = new OptionKey<>(3);
    public static final OptionKey<Integer> ARRAY_DUP_CACHE_KEY = new OptionKey<>(3);
    public static final OptionKey<Integer> ARRAY_STRATEGY_CACHE_KEY = new OptionKey<>(4);
    public static final OptionKey<Integer> ARRAY_UNINITIALIZED_SIZE_KEY = new OptionKey<>(16);
    public static final OptionKey<Integer> ARRAY_SMALL_KEY = new OptionKey<>(3);
    public static final OptionKey<Integer> PACK_UNROLL_LIMIT_KEY = new OptionKey<>(4);
    public static final OptionKey<Integer> PACK_RECOVER_LOOP_MIN_KEY = new OptionKey<>(32);
    public static final OptionKey<Integer> CEXTS_MARKING_CACHE_KEY = new OptionKey<>(100);
    public static final OptionKey<Integer> GLOBAL_VARIABLE_MAX_INVALIDATIONS_KEY = new OptionKey<>(1);
    public static final OptionKey<Boolean> CLONE_DEFAULT_KEY = new OptionKey<>(true);
    public static final OptionKey<Boolean> INLINE_DEFAULT_KEY = new OptionKey<>(true);
    public static final OptionKey<Boolean> CORE_ALWAYS_CLONE_KEY = new OptionKey<>(false);
    public static final OptionKey<Boolean> ALWAYS_CLONE_ALL_KEY = new OptionKey<>(false);
    public static final OptionKey<Boolean> ALWAYS_SPLIT_HONOR_KEY = new OptionKey<>(CLONE_DEFAULT_KEY.getDefaultValue());
    public static final OptionKey<Boolean> NEVER_SPLIT_HONOR_KEY = new OptionKey<>(true);
    public static final OptionKey<Boolean> YIELD_ALWAYS_INLINE_KEY = new OptionKey<>(INLINE_DEFAULT_KEY.getDefaultValue());
    public static final OptionKey<Boolean> METHODMISSING_ALWAYS_CLONE_KEY = new OptionKey<>(CLONE_DEFAULT_KEY.getDefaultValue());
    public static final OptionKey<Boolean> METHODMISSING_ALWAYS_INLINE_KEY = new OptionKey<>(INLINE_DEFAULT_KEY.getDefaultValue());
    public static final OptionKey<Boolean> CHECK_CLONE_UNINITIALIZED_CORRECTNESS_KEY = new OptionKey<>(false);
    public static final OptionKey<Boolean> REGEXP_INSTRUMENT_CREATION_KEY = new OptionKey<>(false);
    public static final OptionKey<Boolean> REGEXP_INSTRUMENT_MATCH_KEY = new OptionKey<>(false);
    public static final OptionKey<Boolean> REGEXP_INSTRUMENT_MATCH_DETAILED_KEY = new OptionKey<>(false);
    public static final OptionKey<OutputFormat> REGEXP_INSTRUMENT_OUTPUT_FORMAT_KEY = new OptionKey<>(OutputFormat.TEXT);
    public static final OptionKey<Boolean> METRICS_TIME_PARSING_FILE_KEY = new OptionKey<>(false);
    public static final OptionKey<Boolean> METRICS_TIME_REQUIRE_KEY = new OptionKey<>(false);
    public static final OptionKey<Boolean> SHARED_OBJECTS_ENABLED_KEY = new OptionKey<>(true);
    public static final OptionKey<Boolean> SHARED_OBJECTS_DEBUG_KEY = new OptionKey<>(false);
    public static final OptionKey<Boolean> SHARED_OBJECTS_FORCE_KEY = new OptionKey<>(false);
    public static final OptionKey<Boolean> TESTING_RUBYGEMS_KEY = new OptionKey<>(false);
    public static final OptionKey<Boolean> RUN_TWICE_KEY = new OptionKey<>(false);
    public static final OptionKey<Boolean> EXPERIMENTAL_ENGINE_CACHING_KEY = new OptionKey<>(RUN_TWICE_KEY.getDefaultValue());
    public static final OptionKey<Boolean> COMPARE_REGEX_ENGINES_KEY = new OptionKey<>(false);

    public static final OptionDescriptor LOAD_PATHS = OptionDescriptor
            .newBuilder(LOAD_PATHS_KEY, "ruby.load-paths")
            .help("Load paths (configured by the -I Ruby option)")
            .category(OptionCategory.USER)
            .stability(OptionStability.STABLE)
            .usageSyntax("<path>,<path>,...")
            .build();

    public static final OptionDescriptor REQUIRED_LIBRARIES = OptionDescriptor
            .newBuilder(REQUIRED_LIBRARIES_KEY, "ruby.required-libraries")
            .help("Required libraries (configured by the -r Ruby option)")
            .category(OptionCategory.USER)
            .stability(OptionStability.STABLE)
            .usageSyntax("<path>,<path>,...")
            .build();

    public static final OptionDescriptor WORKING_DIRECTORY = OptionDescriptor
            .newBuilder(WORKING_DIRECTORY_KEY, "ruby.working-directory")
            .help("Interpreter will switch to this directory (configured by the -C Ruby option)")
            .category(OptionCategory.USER)
            .stability(OptionStability.STABLE)
            .usageSyntax(".")
            .build();

    public static final OptionDescriptor DEBUG = OptionDescriptor
            .newBuilder(DEBUG_KEY, "ruby.debug")
            .help("Sets $DEBUG to this value (configured by the -d Ruby option)")
            .category(OptionCategory.USER)
            .stability(OptionStability.STABLE)
            .usageSyntax("")
            .build();

    public static final OptionDescriptor VERBOSITY = OptionDescriptor
            .newBuilder(VERBOSITY_KEY, "ruby.verbose")
            .help("Sets $VERBOSE to this value (configured by the -v, -w, -W Ruby options)")
            .category(OptionCategory.USER)
            .stability(OptionStability.STABLE)
            .usageSyntax("")
            .build();

    public static final OptionDescriptor SOURCE_ENCODING = OptionDescriptor
            .newBuilder(SOURCE_ENCODING_KEY, "ruby.source-encoding")
            .help("Source encoding (configured by the -K Ruby option)")
            .category(OptionCategory.USER)
            .stability(OptionStability.STABLE)
            .usageSyntax("UTF-8")
            .build();

    public static final OptionDescriptor INTERNAL_ENCODING = OptionDescriptor
            .newBuilder(INTERNAL_ENCODING_KEY, "ruby.internal-encoding")
            .help("Internal encoding (configured by the -E, -U Ruby options)")
            .category(OptionCategory.USER)
            .stability(OptionStability.STABLE)
            .usageSyntax("<nil>")
            .build();

    public static final OptionDescriptor EXTERNAL_ENCODING = OptionDescriptor
            .newBuilder(EXTERNAL_ENCODING_KEY, "ruby.external-encoding")
            .help("External encoding (configured by the -E Ruby option)")
            .category(OptionCategory.USER)
            .stability(OptionStability.STABLE)
            .usageSyntax("<locale>")
            .build();

    public static final OptionDescriptor BACKTRACE_LIMIT = OptionDescriptor
            .newBuilder(BACKTRACE_LIMIT_KEY, "ruby.backtrace-limit")
            .help("limit the maximum length of backtrace displayed")
            .category(OptionCategory.USER)
            .stability(OptionStability.STABLE)
            .usageSyntax("-1")
            .build();

    public static final OptionDescriptor LAUNCHER = OptionDescriptor
            .newBuilder(LAUNCHER_KEY, "ruby.launcher")
            .help("The location of the TruffleRuby launcher program")
            .category(OptionCategory.EXPERT)
            .stability(OptionStability.EXPERIMENTAL)
            .usageSyntax("<set by launcher>")
            .build();

    public static final OptionDescriptor CORE_LOAD_PATH = OptionDescriptor
            .newBuilder(CORE_LOAD_PATH_KEY, "ruby.core-load-path")
            .help("Location to load the Truffle core library from")
            .category(OptionCategory.EXPERT)
            .stability(OptionStability.EXPERIMENTAL)
            .usageSyntax("<path, default is from cache>")
            .build();

    public static final OptionDescriptor FROZEN_STRING_LITERALS = OptionDescriptor
            .newBuilder(FROZEN_STRING_LITERALS_KEY, "ruby.frozen-string-literals")
            .help("Use frozen string literals")
            .category(OptionCategory.EXPERT)
            .stability(OptionStability.EXPERIMENTAL)
            .usageSyntax("")
            .build();

    public static final OptionDescriptor RUBYGEMS = OptionDescriptor
            .newBuilder(RUBYGEMS_KEY, "ruby.rubygems")
            .help("Use RubyGems")
            .category(OptionCategory.EXPERT)
            .stability(OptionStability.EXPERIMENTAL)
            .usageSyntax("")
            .build();

    public static final OptionDescriptor DID_YOU_MEAN = OptionDescriptor
            .newBuilder(DID_YOU_MEAN_KEY, "ruby.did-you-mean")
            .help("Use did_you_mean")
            .category(OptionCategory.EXPERT)
            .stability(OptionStability.EXPERIMENTAL)
            .usageSyntax("")
            .build();

    public static final OptionDescriptor DEFAULT_LAZY = OptionDescriptor
            .newBuilder(DEFAULT_LAZY_KEY, "ruby.lazy-default")
            .help("Enable default lazy options")
            .category(OptionCategory.EXPERT)
            .stability(OptionStability.EXPERIMENTAL)
            .usageSyntax("")
            .build();

    public static final OptionDescriptor LAZY_CALLTARGETS = OptionDescriptor
            .newBuilder(LAZY_CALLTARGETS_KEY, "ruby.lazy-calltargets")
            .help("Create CallTargets lazily when possible")
            .category(OptionCategory.EXPERT)
            .stability(OptionStability.EXPERIMENTAL)
            .usageSyntax("")
            .build();

    public static final OptionDescriptor LAZY_RUBYGEMS = OptionDescriptor
            .newBuilder(LAZY_RUBYGEMS_KEY, "ruby.lazy-rubygems")
            .help("Load RubyGems lazily on first failing require")
            .category(OptionCategory.EXPERT)
            .stability(OptionStability.EXPERIMENTAL)
            .usageSyntax("")
            .build();

    public static final OptionDescriptor EMBEDDED = OptionDescriptor
            .newBuilder(EMBEDDED_KEY, "ruby.embedded")
            .help("Set default options for an embedded use of TruffleRuby, rather than top-level use")
            .category(OptionCategory.EXPERT)
            .stability(OptionStability.EXPERIMENTAL)
            .usageSyntax("")
            .build();

    public static final OptionDescriptor NATIVE_PLATFORM = OptionDescriptor
            .newBuilder(NATIVE_PLATFORM_KEY, "ruby.platform-native")
            .help("Enables native calls via Truffle NFI for internal functionality")
            .category(OptionCategory.EXPERT)
            .stability(OptionStability.EXPERIMENTAL)
            .usageSyntax("")
            .build();

    public static final OptionDescriptor NATIVE_INTERRUPT = OptionDescriptor
            .newBuilder(NATIVE_INTERRUPT_KEY, "ruby.platform-native-interrupt")
            .help("Use the SIGVTALRM signal to interrupt native blocking calls")
            .category(OptionCategory.EXPERT)
            .stability(OptionStability.EXPERIMENTAL)
            .usageSyntax("")
            .build();

    public static final OptionDescriptor HANDLE_INTERRUPT = OptionDescriptor
            .newBuilder(HANDLE_INTERRUPT_KEY, "ruby.platform-handle-interrupt")
            .help("Handle the interrupt signal and raise an Interrupt exception")
            .category(OptionCategory.EXPERT)
            .stability(OptionStability.EXPERIMENTAL)
            .usageSyntax("")
            .build();

    public static final OptionDescriptor SINGLE_THREADED = OptionDescriptor
            .newBuilder(SINGLE_THREADED_KEY, "ruby.single-threaded")
            .help("Use only a single thread to be compatible with languages not supporting multithreading")
            .category(OptionCategory.EXPERT)
            .stability(OptionStability.EXPERIMENTAL)
            .usageSyntax("")
            .build();

    public static final OptionDescriptor POLYGLOT_STDIO = OptionDescriptor
            .newBuilder(POLYGLOT_STDIO_KEY, "ruby.polyglot-stdio")
            .help("Use standard IO streams from the Graal-SDK polyglot API configuration")
            .category(OptionCategory.EXPERT)
            .stability(OptionStability.EXPERIMENTAL)
            .usageSyntax("")
            .build();

    public static final OptionDescriptor HOST_INTEROP = OptionDescriptor
            .newBuilder(HOST_INTEROP_KEY, "ruby.interop-host")
            .help("Allow interoperability with the host language (Java)")
            .category(OptionCategory.EXPERT)
            .stability(OptionStability.EXPERIMENTAL)
            .usageSyntax("")
            .build();

    public static final OptionDescriptor TRACE_CALLS = OptionDescriptor
            .newBuilder(TRACE_CALLS_KEY, "ruby.trace-calls")
            .help("Support tracing (set_trace_func, TracePoint) of method calls")
            .category(OptionCategory.EXPERT)
            .stability(OptionStability.EXPERIMENTAL)
            .usageSyntax("")
            .build();

    public static final OptionDescriptor COVERAGE_GLOBAL = OptionDescriptor
            .newBuilder(COVERAGE_GLOBAL_KEY, "ruby.coverage-global")
            .help("Run coverage for all code and print results on exit")
            .category(OptionCategory.EXPERT)
            .stability(OptionStability.EXPERIMENTAL)
            .usageSyntax("")
            .build();

    public static final OptionDescriptor CORE_AS_INTERNAL = OptionDescriptor
            .newBuilder(CORE_AS_INTERNAL_KEY, "ruby.core-as-internal")
            .help("Mark core library sources as internal")
            .category(OptionCategory.EXPERT)
            .stability(OptionStability.EXPERIMENTAL)
            .usageSyntax("")
            .build();

    public static final OptionDescriptor STDLIB_AS_INTERNAL = OptionDescriptor
            .newBuilder(STDLIB_AS_INTERNAL_KEY, "ruby.stdlib-as-internal")
            .help("Mark stdlib sources as internal")
            .category(OptionCategory.EXPERT)
            .stability(OptionStability.EXPERIMENTAL)
            .usageSyntax("")
            .build();

    public static final OptionDescriptor LAZY_TRANSLATION_USER = OptionDescriptor
            .newBuilder(LAZY_TRANSLATION_USER_KEY, "ruby.lazy-translation-user")
            .help("Lazily translation of stdlib, gem and user source files")
            .category(OptionCategory.EXPERT)
            .stability(OptionStability.EXPERIMENTAL)
            .usageSyntax("")
            .build();

    public static final OptionDescriptor PATCHING = OptionDescriptor
            .newBuilder(PATCHING_KEY, "ruby.patching")
            .help("Use patching")
            .category(OptionCategory.EXPERT)
            .stability(OptionStability.EXPERIMENTAL)
            .usageSyntax("")
            .build();

    public static final OptionDescriptor HASHING_DETERMINISTIC = OptionDescriptor
            .newBuilder(HASHING_DETERMINISTIC_KEY, "ruby.hashing-deterministic")
            .help("Produce deterministic hash values")
            .category(OptionCategory.EXPERT)
            .stability(OptionStability.EXPERIMENTAL)
            .usageSyntax("")
            .build();

    public static final OptionDescriptor VIRTUAL_THREAD_FIBERS = OptionDescriptor
            .newBuilder(VIRTUAL_THREAD_FIBERS_KEY, "ruby.virtual-thread-fibers")
            .help("Use VirtualThread for Fibers")
            .category(OptionCategory.EXPERT)
            .stability(OptionStability.EXPERIMENTAL)
            .usageSyntax("")
            .build();

    public static final OptionDescriptor LOG_SUBPROCESS = OptionDescriptor
            .newBuilder(LOG_SUBPROCESS_KEY, "ruby.log-subprocess")
            .help("Log whenever a subprocess is created")
            .category(OptionCategory.EXPERT)
            .stability(OptionStability.EXPERIMENTAL)
            .usageSyntax("")
            .build();

    public static final OptionDescriptor WARN_LOCALE = OptionDescriptor
            .newBuilder(WARN_LOCALE_KEY, "ruby.warn-locale")
            .help("Warn when the system locale is not set properly")
            .category(OptionCategory.EXPERT)
            .stability(OptionStability.EXPERIMENTAL)
            .usageSyntax("")
            .build();

    public static final OptionDescriptor EXCEPTIONS_STORE_JAVA = OptionDescriptor
            .newBuilder(EXCEPTIONS_STORE_JAVA_KEY, "ruby.exceptions-store-java")
            .help("Store the Java exception with the Ruby backtrace")
            .category(OptionCategory.EXPERT)
            .stability(OptionStability.EXPERIMENTAL)
            .usageSyntax("")
            .build();

    public static final OptionDescriptor EXCEPTIONS_PRINT_JAVA = OptionDescriptor
            .newBuilder(EXCEPTIONS_PRINT_JAVA_KEY, "ruby.exceptions-print-java")
            .help("Print Java exceptions at the point of translating them to Ruby exceptions")
            .category(OptionCategory.EXPERT)
            .stability(OptionStability.EXPERIMENTAL)
            .usageSyntax("")
            .build();

    public static final OptionDescriptor EXCEPTIONS_PRINT_UNCAUGHT_JAVA = OptionDescriptor
            .newBuilder(EXCEPTIONS_PRINT_UNCAUGHT_JAVA_KEY, "ruby.exceptions-print-uncaught-java")
            .help("Print uncaught Java exceptions at the point of translating them to Ruby exceptions")
            .category(OptionCategory.EXPERT)
            .stability(OptionStability.EXPERIMENTAL)
            .usageSyntax("")
            .build();

    public static final OptionDescriptor EXCEPTIONS_PRINT_RUBY_FOR_JAVA = OptionDescriptor
            .newBuilder(EXCEPTIONS_PRINT_RUBY_FOR_JAVA_KEY, "ruby.exceptions-print-ruby-for-java")
            .help("When printing a Java backtrace, also print the Ruby backtrace at that point")
            .category(OptionCategory.EXPERT)
            .stability(OptionStability.EXPERIMENTAL)
            .usageSyntax("")
            .build();

    public static final OptionDescriptor EXCEPTIONS_WARN_STACKOVERFLOW = OptionDescriptor
            .newBuilder(EXCEPTIONS_WARN_STACKOVERFLOW_KEY, "ruby.exceptions-warn-stackoverflow")
            .help("Warn when a stack overflow error is thrown")
            .category(OptionCategory.EXPERT)
            .stability(OptionStability.EXPERIMENTAL)
            .usageSyntax("")
            .build();

    public static final OptionDescriptor EXCEPTIONS_WARN_OUT_OF_MEMORY = OptionDescriptor
            .newBuilder(EXCEPTIONS_WARN_OUT_OF_MEMORY_KEY, "ruby.exceptions-warn-out-of-memory")
            .help("Warn when an out-of-memory error is thrown")
            .category(OptionCategory.EXPERT)
            .stability(OptionStability.EXPERIMENTAL)
            .usageSyntax("")
            .build();

    public static final OptionDescriptor BACKTRACES_INTERLEAVE_JAVA = OptionDescriptor
            .newBuilder(BACKTRACES_INTERLEAVE_JAVA_KEY, "ruby.backtraces-interleave-java")
            .help("Interleave Java stacktraces into the Ruby backtrace")
            .category(OptionCategory.EXPERT)
            .stability(OptionStability.EXPERIMENTAL)
            .usageSyntax("")
            .build();

    public static final OptionDescriptor BACKTRACES_OMIT_UNUSED = OptionDescriptor
            .newBuilder(BACKTRACES_OMIT_UNUSED_KEY, "ruby.backtraces-omit-unused")
            .help("Omit backtraces that should be unused as they have pure rescue expressions")
            .category(OptionCategory.EXPERT)
            .stability(OptionStability.EXPERIMENTAL)
            .usageSyntax("")
            .build();

    public static final OptionDescriptor BIG_HASH_STRATEGY_IS_BUCKETS = OptionDescriptor
            .newBuilder(BIG_HASH_STRATEGY_IS_BUCKETS_KEY, "ruby.buckets-big-hash")
            .help("Whether to use chaining-style buckets hash store for hash tables exceeding the small hash limit")
            .category(OptionCategory.EXPERT)
            .stability(OptionStability.EXPERIMENTAL)
            .usageSyntax("")
            .build();

    public static final OptionDescriptor BACKTRACE_ON_INTERRUPT = OptionDescriptor
            .newBuilder(BACKTRACE_ON_INTERRUPT_KEY, "ruby.backtraces-on-interrupt")
            .help("Show the backtraces of all Threads on Ctrl+C")
            .category(OptionCategory.EXPERT)
            .stability(OptionStability.EXPERIMENTAL)
            .usageSyntax("")
            .build();

    public static final OptionDescriptor BACKTRACE_ON_SIGALRM = OptionDescriptor
            .newBuilder(BACKTRACE_ON_SIGALRM_KEY, "ruby.backtraces-sigalrm")
            .help("Show the backtraces of all Threads on SIGALRM")
            .category(OptionCategory.EXPERT)
            .stability(OptionStability.EXPERIMENTAL)
            .usageSyntax("")
            .build();

    public static final OptionDescriptor BACKTRACE_ON_RAISE = OptionDescriptor
            .newBuilder(BACKTRACE_ON_RAISE_KEY, "ruby.backtraces-raise")
            .help("Show the backtraces of exceptions at the point of them being raised")
            .category(OptionCategory.EXPERT)
            .stability(OptionStability.EXPERIMENTAL)
            .usageSyntax("")
            .build();

    public static final OptionDescriptor BACKTRACE_ON_RESCUE = OptionDescriptor
            .newBuilder(BACKTRACE_ON_RESCUE_KEY, "ruby.backtraces-rescue")
            .help("Show the backtraces of exceptions at the point of them being rescued")
            .category(OptionCategory.EXPERT)
            .stability(OptionStability.EXPERIMENTAL)
            .usageSyntax("")
            .build();

    public static final OptionDescriptor BACKTRACE_ON_NEW_THREAD = OptionDescriptor
            .newBuilder(BACKTRACE_ON_NEW_THREAD_KEY, "ruby.backtraces-new-thread")
            .help("Show a backtrace when new threads are created")
            .category(OptionCategory.EXPERT)
            .stability(OptionStability.EXPERIMENTAL)
            .usageSyntax("")
            .build();

    public static final OptionDescriptor BACKTRACE_ON_NEW_FIBER = OptionDescriptor
            .newBuilder(BACKTRACE_ON_NEW_FIBER_KEY, "ruby.backtraces-new-fiber")
            .help("Show a backtrace when new fibers are created")
            .category(OptionCategory.EXPERT)
            .stability(OptionStability.EXPERIMENTAL)
            .usageSyntax("")
            .build();

    public static final OptionDescriptor CEXTS = OptionDescriptor
            .newBuilder(CEXTS_KEY, "ruby.cexts")
            .help("Enable use of C extensions")
            .category(OptionCategory.EXPERT)
            .stability(OptionStability.EXPERIMENTAL)
            .usageSyntax("")
            .build();

    public static final OptionDescriptor CEXT_LOCK = OptionDescriptor
            .newBuilder(CEXT_LOCK_KEY, "ruby.cexts-lock")
            .help("Use a Global Lock when running C extensions")
            .category(OptionCategory.EXPERT)
            .stability(OptionStability.EXPERIMENTAL)
            .usageSyntax("")
            .build();

    public static final OptionDescriptor CEXTS_PANAMA = OptionDescriptor
            .newBuilder(CEXTS_PANAMA_KEY, "ruby.cexts-panama")
            .help("Use Panama for native to Ruby calls in C extensions. Only available in --jvm mode on JDK 22+.")
            .category(OptionCategory.EXPERT)
            .stability(OptionStability.EXPERIMENTAL)
            .usageSyntax("")
            .build();

    public static final OptionDescriptor OPTIONS_LOG = OptionDescriptor
            .newBuilder(OPTIONS_LOG_KEY, "ruby.options-log")
            .help("Log the final value of all options")
            .category(OptionCategory.EXPERT)
            .stability(OptionStability.EXPERIMENTAL)
            .usageSyntax("")
            .build();

    public static final OptionDescriptor LOG_LOAD = OptionDescriptor
            .newBuilder(LOG_LOAD_KEY, "ruby.log-load")
            .help("Log loading files")
            .category(OptionCategory.EXPERT)
            .stability(OptionStability.EXPERIMENTAL)
            .usageSyntax("")
            .build();

    public static final OptionDescriptor LOG_AUTOLOAD = OptionDescriptor
            .newBuilder(LOG_AUTOLOAD_KEY, "ruby.log-autoload")
            .help("Log autoloading")
            .category(OptionCategory.EXPERT)
            .stability(OptionStability.EXPERIMENTAL)
            .usageSyntax("")
            .build();

    public static final OptionDescriptor LOG_FEATURE_LOCATION = OptionDescriptor
            .newBuilder(LOG_FEATURE_LOCATION_KEY, "ruby.log-feature-location")
            .help("Log the process of finding features")
            .category(OptionCategory.EXPERT)
            .stability(OptionStability.EXPERIMENTAL)
            .usageSyntax("")
            .build();

    public static final OptionDescriptor METRICS_PROFILE_REQUIRE = OptionDescriptor
            .newBuilder(METRICS_PROFILE_REQUIRE_KEY, "ruby.metrics-profile-require")
            .help("Measure time for searching, parsing, translating and loading files.")
            .category(OptionCategory.EXPERT)
            .stability(OptionStability.EXPERIMENTAL)
            .usageSyntax("")
            .build();

    public static final OptionDescriptor CEXTS_LOG_LOAD = OptionDescriptor
            .newBuilder(CEXTS_LOG_LOAD_KEY, "ruby.cexts-log-load")
            .help("Log loading of cexts")
            .category(OptionCategory.EXPERT)
            .stability(OptionStability.EXPERIMENTAL)
            .usageSyntax("")
            .build();

    public static final OptionDescriptor CEXTS_LOG_WARNINGS = OptionDescriptor
            .newBuilder(CEXTS_LOG_WARNINGS_KEY, "ruby.cexts-log-warnings")
            .help("Log cexts warnings")
            .category(OptionCategory.EXPERT)
            .stability(OptionStability.EXPERIMENTAL)
            .usageSyntax("")
            .build();

    public static final OptionDescriptor WARN_DEPRECATED = OptionDescriptor
            .newBuilder(WARN_DEPRECATED_KEY, "ruby.warn-deprecated")
            .help("Sets the deprecated Warning category (configured by the -W Ruby option)")
            .category(OptionCategory.EXPERT)
            .stability(OptionStability.EXPERIMENTAL)
            .usageSyntax("")
            .build();

    public static final OptionDescriptor WARN_EXPERIMENTAL = OptionDescriptor
            .newBuilder(WARN_EXPERIMENTAL_KEY, "ruby.warn-experimental")
            .help("Sets the experimental Warning category (configured by the -W Ruby option)")
            .category(OptionCategory.EXPERT)
            .stability(OptionStability.EXPERIMENTAL)
            .usageSyntax("")
            .build();

    public static final OptionDescriptor WARN_PERFORMANCE = OptionDescriptor
            .newBuilder(WARN_PERFORMANCE_KEY, "ruby.warn-performance")
            .help("Sets the performance Warning category (configured by the -W Ruby option)")
            .category(OptionCategory.EXPERT)
            .stability(OptionStability.EXPERIMENTAL)
            .usageSyntax("")
            .build();

    public static final OptionDescriptor USE_TRUFFLE_REGEX = OptionDescriptor
            .newBuilder(USE_TRUFFLE_REGEX_KEY, "ruby.use-truffle-regex")
            .help("Use the Truffle regular expression engine when possible and fallback to Joni otherwise")
            .category(OptionCategory.EXPERT)
            .stability(OptionStability.EXPERIMENTAL)
            .usageSyntax("")
            .build();

    public static final OptionDescriptor WARN_TRUFFLE_REGEX_COMPILE_FALLBACK = OptionDescriptor
            .newBuilder(WARN_TRUFFLE_REGEX_COMPILE_FALLBACK_KEY, "ruby.warn-truffle-regex-compile-fallback")
            .help("Warn when a Ruby Regexp could not be compiled to a Truffle Regex and Joni is used instead")
            .category(OptionCategory.EXPERT)
            .stability(OptionStability.EXPERIMENTAL)
            .usageSyntax("")
            .build();

    public static final OptionDescriptor WARN_TRUFFLE_REGEX_MATCH_FALLBACK = OptionDescriptor
            .newBuilder(WARN_TRUFFLE_REGEX_MATCH_FALLBACK_KEY, "ruby.warn-truffle-regex-match-fallback")
            .help("Warn every time Truffle Regex cannot be used for a Regexp match (and instead Joni is used)")
            .category(OptionCategory.EXPERT)
            .stability(OptionStability.EXPERIMENTAL)
            .usageSyntax("")
            .build();

    public static final OptionDescriptor TRUFFLE_REGEX_IGNORE_ATOMIC_GROUPS = OptionDescriptor
            .newBuilder(TRUFFLE_REGEX_IGNORE_ATOMIC_GROUPS_KEY, "ruby.truffle-regex-ignore-atomic-groups")
            .help("Treat atomic groups (?>...) as ordinary groups (?:...) with Truffle Regex.")
            .category(OptionCategory.EXPERT)
            .stability(OptionStability.EXPERIMENTAL)
            .usageSyntax("")
            .build();

    public static final OptionDescriptor REUSE_PRECOMPILED_GEMS = OptionDescriptor
            .newBuilder(REUSE_PRECOMPILED_GEMS_KEY, "ruby.reuse-precompiled-gems")
            .help("A list of gems we want to install precompiled (using the local platform) on TruffleRuby. Can only be used for gem extensions which do not depend on the Ruby C API.")
            .category(OptionCategory.EXPERT)
            .stability(OptionStability.EXPERIMENTAL)
            .usageSyntax("<gem>,<gem>,...")
            .build();

    public static final OptionDescriptor ARGV_GLOBALS = OptionDescriptor
            .newBuilder(ARGV_GLOBALS_KEY, "ruby.argv-globals")
            .help("Parse options in script argv into global variables (configured by the -s Ruby option)")
            .category(OptionCategory.INTERNAL)
            .stability(OptionStability.EXPERIMENTAL)
            .usageSyntax("")
            .build();

    public static final OptionDescriptor CHOMP_LOOP = OptionDescriptor
            .newBuilder(CHOMP_LOOP_KEY, "ruby.chomp-loop")
            .help("enable line ending processing (configured by the -l Ruby option)")
            .category(OptionCategory.INTERNAL)
            .stability(OptionStability.EXPERIMENTAL)
            .usageSyntax("")
            .build();

    public static final OptionDescriptor GETS_LOOP = OptionDescriptor
            .newBuilder(GETS_LOOP_KEY, "ruby.gets-loop")
            .help("assume while gets(); ... end loop around your script (configured by the -n Ruby option)")
            .category(OptionCategory.INTERNAL)
            .stability(OptionStability.EXPERIMENTAL)
            .usageSyntax("")
            .build();

    public static final OptionDescriptor PRINT_LOOP = OptionDescriptor
            .newBuilder(PRINT_LOOP_KEY, "ruby.print-loop")
            .help("assume loop like -n but print line also like sed (configured by the -p Ruby option)")
            .category(OptionCategory.INTERNAL)
            .stability(OptionStability.EXPERIMENTAL)
            .usageSyntax("")
            .build();

    public static final OptionDescriptor SPLIT_LOOP = OptionDescriptor
            .newBuilder(SPLIT_LOOP_KEY, "ruby.split-loop")
            .help("autosplit mode with -n or -p (splits $_ into $F) (configured by the -a Ruby option)")
            .category(OptionCategory.INTERNAL)
            .stability(OptionStability.EXPERIMENTAL)
            .usageSyntax("")
            .build();

    public static final OptionDescriptor IGNORE_LINES_BEFORE_RUBY_SHEBANG = OptionDescriptor
            .newBuilder(IGNORE_LINES_BEFORE_RUBY_SHEBANG_KEY, "ruby.ignore-lines-before-ruby-shebang")
            .help("strip off text before #!ruby line (configured by the -x Ruby option)")
            .category(OptionCategory.INTERNAL)
            .stability(OptionStability.EXPERIMENTAL)
            .usageSyntax("")
            .build();

    public static final OptionDescriptor SYNTAX_CHECK = OptionDescriptor
            .newBuilder(SYNTAX_CHECK_KEY, "ruby.syntax-check")
            .help("Do not execute just check syntax (configured by the -c Ruby option)")
            .category(OptionCategory.INTERNAL)
            .stability(OptionStability.EXPERIMENTAL)
            .usageSyntax("")
            .build();

    public static final OptionDescriptor ARGV_GLOBAL_VALUES = OptionDescriptor
            .newBuilder(ARGV_GLOBAL_VALUES_KEY, "ruby.argv-global-values")
            .help("Parsed options from script argv with a value")
            .category(OptionCategory.INTERNAL)
            .stability(OptionStability.EXPERIMENTAL)
            .usageSyntax("<key>,<value>,...")
            .build();

    public static final OptionDescriptor ARGV_GLOBAL_FLAGS = OptionDescriptor
            .newBuilder(ARGV_GLOBAL_FLAGS_KEY, "ruby.argv-global-flags")
            .help("Parsed options from script argv acting as flags (no value)")
            .category(OptionCategory.INTERNAL)
            .stability(OptionStability.EXPERIMENTAL)
            .usageSyntax("<flag>,<flag>,...")
            .build();

    public static final OptionDescriptor BUILDING_CORE_CEXTS = OptionDescriptor
            .newBuilder(BUILDING_CORE_CEXTS_KEY, "ruby.building-core-cexts")
            .help("Used while building TruffleRuby to build default & bundled gems C extensions")
            .category(OptionCategory.INTERNAL)
            .stability(OptionStability.EXPERIMENTAL)
            .usageSyntax("")
            .build();

    public static final OptionDescriptor LAZY_TRANSLATION_LOG = OptionDescriptor
            .newBuilder(LAZY_TRANSLATION_LOG_KEY, "ruby.lazy-translation-log")
            .help("Log lazy translations from the parser AST to the Truffle AST")
            .category(OptionCategory.INTERNAL)
            .stability(OptionStability.EXPERIMENTAL)
            .usageSyntax("")
            .build();

    public static final OptionDescriptor LOG_DYNAMIC_CONSTANT_LOOKUP = OptionDescriptor
            .newBuilder(LOG_DYNAMIC_CONSTANT_LOOKUP_KEY, "ruby.constant-dynamic-lookup-log")
            .help("Log source code positions where dynamic constant lookup is performed")
            .category(OptionCategory.INTERNAL)
            .stability(OptionStability.EXPERIMENTAL)
            .usageSyntax("")
            .build();

    public static final OptionDescriptor LOG_PENDING_INTERRUPTS = OptionDescriptor
            .newBuilder(LOG_PENDING_INTERRUPTS_KEY, "ruby.log-pending-interrupts")
            .help("Log when executing pending interrupts")
            .category(OptionCategory.INTERNAL)
            .stability(OptionStability.EXPERIMENTAL)
            .usageSyntax("")
            .build();

    public static final OptionDescriptor PRINT_INTERNED_TSTRING_STATS = OptionDescriptor
            .newBuilder(PRINT_INTERNED_TSTRING_STATS_KEY, "ruby.print-interned-tstring-stats")
            .help("Print interned tstring stats at application exit")
            .category(OptionCategory.INTERNAL)
            .stability(OptionStability.EXPERIMENTAL)
            .usageSyntax("")
            .build();

    public static final OptionDescriptor CEXTS_TO_NATIVE_STATS = OptionDescriptor
            .newBuilder(CEXTS_TO_NATIVE_STATS_KEY, "ruby.cexts-to-native-stats")
            .help("Track the number of conversions of VALUEs to native and print the stats at application exit")
            .category(OptionCategory.INTERNAL)
            .stability(OptionStability.EXPERIMENTAL)
            .usageSyntax("")
            .build();

    public static final OptionDescriptor CEXTS_TO_NATIVE_COUNT = OptionDescriptor
            .newBuilder(CEXTS_TO_NATIVE_COUNT_KEY, "ruby.cexts-to-native-count")
            .help("Track the number of conversions of VALUEs to native")
            .category(OptionCategory.INTERNAL)
            .stability(OptionStability.EXPERIMENTAL)
            .usageSyntax("")
            .build();

    public static final OptionDescriptor BACKTRACE_ON_TO_NATIVE = OptionDescriptor
            .newBuilder(BACKTRACE_ON_TO_NATIVE_KEY, "ruby.backtraces-to-native")
            .help("Show a backtrace when a ValueWrapper handle is created for a Ruby object")
            .category(OptionCategory.INTERNAL)
            .stability(OptionStability.EXPERIMENTAL)
            .usageSyntax("")
            .build();

    public static final OptionDescriptor CEXTS_KEEP_HANDLES_ALIVE = OptionDescriptor
            .newBuilder(CEXTS_KEEP_HANDLES_ALIVE_KEY, "ruby.keep-handles-alive")
            .help("Keep handles for value wrappers alive forever")
            .category(OptionCategory.INTERNAL)
            .stability(OptionStability.EXPERIMENTAL)
            .usageSyntax("")
            .build();

    public static final OptionDescriptor CEXTS_SULONG = OptionDescriptor
            .newBuilder(CEXTS_SULONG_KEY, "ruby.cexts-sulong")
            .help("Run C extensions on Sulong instead of natively, requires rebuilding TruffleRuby from source with this option")
            .category(OptionCategory.INTERNAL)
            .stability(OptionStability.EXPERIMENTAL)
            .usageSyntax("")
            .build();

    public static final OptionDescriptor LAZY_BUILTINS = OptionDescriptor
            .newBuilder(LAZY_BUILTINS_KEY, "ruby.lazy-builtins")
            .help("Load builtin classes (core methods & primitives) lazily on first use")
            .category(OptionCategory.INTERNAL)
            .stability(OptionStability.EXPERIMENTAL)
            .usageSyntax("")
            .build();

    public static final OptionDescriptor LAZY_TRANSLATION_CORE = OptionDescriptor
            .newBuilder(LAZY_TRANSLATION_CORE_KEY, "ruby.lazy-translation-core")
            .help("Lazily translation of core source files")
            .category(OptionCategory.INTERNAL)
            .stability(OptionStability.EXPERIMENTAL)
            .usageSyntax("")
            .build();

    public static final OptionDescriptor CHAOS_DATA = OptionDescriptor
            .newBuilder(CHAOS_DATA_KEY, "ruby.chaos-data")
            .help("Randomize data representations to stress specialization code paths")
            .category(OptionCategory.INTERNAL)
            .stability(OptionStability.EXPERIMENTAL)
            .usageSyntax("")
            .build();

    public static final OptionDescriptor INSTRUMENT_ALL_NODES = OptionDescriptor
            .newBuilder(INSTRUMENT_ALL_NODES_KEY, "ruby.instrument-all-nodes")
            .help("Instrument all isInstrumentable() nodes, regardless of tags, to ensure instrumentation wrappers can be inserted")
            .category(OptionCategory.INTERNAL)
            .stability(OptionStability.EXPERIMENTAL)
            .usageSyntax("")
            .build();

    public static final OptionDescriptor BASICOPS_INLINE = OptionDescriptor
            .newBuilder(BASICOPS_INLINE_KEY, "ruby.basic-ops-inline")
            .help("Inline basic operations (like Fixnum operators) in the AST without a call")
            .category(OptionCategory.INTERNAL)
            .stability(OptionStability.EXPERIMENTAL)
            .usageSyntax("")
            .build();

    public static final OptionDescriptor BASICOPS_LOG_REWRITE = OptionDescriptor
            .newBuilder(BASICOPS_LOG_REWRITE_KEY, "ruby.basic-ops-log-rewrite")
            .help("Log the receiver and arguments when basic operations like Fixnum operators cannot be handled inline")
            .category(OptionCategory.INTERNAL)
            .stability(OptionStability.EXPERIMENTAL)
            .usageSyntax("")
            .build();

    public static final OptionDescriptor PROFILE_ARGUMENTS = OptionDescriptor
            .newBuilder(PROFILE_ARGUMENTS_KEY, "ruby.profile-arguments")
            .help("Profile the value and class of the receiver and arguments")
            .category(OptionCategory.INTERNAL)
            .stability(OptionStability.EXPERIMENTAL)
            .usageSyntax("")
            .build();

    public static final OptionDescriptor DEFAULT_CACHE = OptionDescriptor
            .newBuilder(DEFAULT_CACHE_KEY, "ruby.default-cache")
            .help("Default size for caches")
            .category(OptionCategory.INTERNAL)
            .stability(OptionStability.EXPERIMENTAL)
            .usageSyntax("8")
            .build();

    public static final OptionDescriptor METHOD_LOOKUP_CACHE = OptionDescriptor
            .newBuilder(METHOD_LOOKUP_CACHE_KEY, "ruby.method-lookup-cache")
            .help("Method lookup cache size")
            .category(OptionCategory.INTERNAL)
            .stability(OptionStability.EXPERIMENTAL)
            .usageSyntax("8")
            .build();

    public static final OptionDescriptor DISPATCH_CACHE = OptionDescriptor
            .newBuilder(DISPATCH_CACHE_KEY, "ruby.dispatch-cache")
            .help("Dispatch (various forms of method call) cache size")
            .category(OptionCategory.INTERNAL)
            .stability(OptionStability.EXPERIMENTAL)
            .usageSyntax("8")
            .build();

    public static final OptionDescriptor YIELD_CACHE = OptionDescriptor
            .newBuilder(YIELD_CACHE_KEY, "ruby.yield-cache")
            .help("Yield cache size")
            .category(OptionCategory.INTERNAL)
            .stability(OptionStability.EXPERIMENTAL)
            .usageSyntax("8")
            .build();

    public static final OptionDescriptor IS_A_CACHE = OptionDescriptor
            .newBuilder(IS_A_CACHE_KEY, "ruby.is-a-cache")
            .help("Kernel#is_a? and #kind_of? cache size")
            .category(OptionCategory.INTERNAL)
            .stability(OptionStability.EXPERIMENTAL)
            .usageSyntax("8")
            .build();

    public static final OptionDescriptor BIND_CACHE = OptionDescriptor
            .newBuilder(BIND_CACHE_KEY, "ruby.bind-cache")
            .help("Cache size of test for being able to bind a method to a module")
            .category(OptionCategory.INTERNAL)
            .stability(OptionStability.EXPERIMENTAL)
            .usageSyntax("8")
            .build();

    public static final OptionDescriptor CONSTANT_CACHE = OptionDescriptor
            .newBuilder(CONSTANT_CACHE_KEY, "ruby.constant-cache")
            .help("Constant cache size")
            .category(OptionCategory.INTERNAL)
            .stability(OptionStability.EXPERIMENTAL)
            .usageSyntax("8")
            .build();

    public static final OptionDescriptor INSTANCE_VARIABLE_CACHE = OptionDescriptor
            .newBuilder(INSTANCE_VARIABLE_CACHE_KEY, "ruby.instance-variable-cache")
            .help("Instance variable cache size")
            .category(OptionCategory.INTERNAL)
            .stability(OptionStability.EXPERIMENTAL)
            .usageSyntax("8")
            .build();

    public static final OptionDescriptor BINDING_LOCAL_VARIABLE_CACHE = OptionDescriptor
            .newBuilder(BINDING_LOCAL_VARIABLE_CACHE_KEY, "ruby.binding-local-variable-cache")
            .help("Binding#local_variable_get/set cache size")
            .category(OptionCategory.INTERNAL)
            .stability(OptionStability.EXPERIMENTAL)
            .usageSyntax("8")
            .build();

    public static final OptionDescriptor SYMBOL_TO_PROC_CACHE = OptionDescriptor
            .newBuilder(SYMBOL_TO_PROC_CACHE_KEY, "ruby.symbol-to-proc-cache")
            .help("Symbol#to_proc cache size")
            .category(OptionCategory.INTERNAL)
            .stability(OptionStability.EXPERIMENTAL)
            .usageSyntax("8")
            .build();

    public static final OptionDescriptor PACK_CACHE = OptionDescriptor
            .newBuilder(PACK_CACHE_KEY, "ruby.pack-cache")
            .help("Array#pack cache size")
            .category(OptionCategory.INTERNAL)
            .stability(OptionStability.EXPERIMENTAL)
            .usageSyntax("8")
            .build();

    public static final OptionDescriptor UNPACK_CACHE = OptionDescriptor
            .newBuilder(UNPACK_CACHE_KEY, "ruby.unpack-cache")
            .help("String#unpack cache size")
            .category(OptionCategory.INTERNAL)
            .stability(OptionStability.EXPERIMENTAL)
            .usageSyntax("8")
            .build();

    public static final OptionDescriptor EVAL_CACHE = OptionDescriptor
            .newBuilder(EVAL_CACHE_KEY, "ruby.eval-cache")
            .help("eval cache size")
            .category(OptionCategory.INTERNAL)
            .stability(OptionStability.EXPERIMENTAL)
            .usageSyntax("8")
            .build();

    public static final OptionDescriptor ENCODING_COMPATIBLE_QUERY_CACHE = OptionDescriptor
            .newBuilder(ENCODING_COMPATIBLE_QUERY_CACHE_KEY, "ruby.encoding-compatible-query-cache")
            .help("Encoding.compatible? cache size")
            .category(OptionCategory.INTERNAL)
            .stability(OptionStability.EXPERIMENTAL)
            .usageSyntax("8")
            .build();

    public static final OptionDescriptor ENCODING_LOADED_CLASSES_CACHE = OptionDescriptor
            .newBuilder(ENCODING_LOADED_CLASSES_CACHE_KEY, "ruby.encoding-loaded-classes-cache")
            .help("Cache size of encoding operations based on anticipated number of total active encodings")
            .category(OptionCategory.INTERNAL)
            .stability(OptionStability.EXPERIMENTAL)
            .usageSyntax("8")
            .build();

    public static final OptionDescriptor INTEROP_CONVERT_CACHE = OptionDescriptor
            .newBuilder(INTEROP_CONVERT_CACHE_KEY, "ruby.interop-convert-cache")
            .help("Cache size for converting values for interop")
            .category(OptionCategory.INTERNAL)
            .stability(OptionStability.EXPERIMENTAL)
            .usageSyntax("8")
            .build();

    public static final OptionDescriptor TIME_FORMAT_CACHE = OptionDescriptor
            .newBuilder(TIME_FORMAT_CACHE_KEY, "ruby.time-format-cache")
            .help("Cache size for parsed time format specifiers")
            .category(OptionCategory.INTERNAL)
            .stability(OptionStability.EXPERIMENTAL)
            .usageSyntax("8")
            .build();

    public static final OptionDescriptor POW_CACHE = OptionDescriptor
            .newBuilder(POW_CACHE_KEY, "ruby.integer-pow-cache")
            .help("Cache size for Integer#** with a constant exponent")
            .category(OptionCategory.INTERNAL)
            .stability(OptionStability.EXPERIMENTAL)
            .usageSyntax("8")
            .build();

    public static final OptionDescriptor IDENTITY_CACHE = OptionDescriptor
            .newBuilder(IDENTITY_CACHE_KEY, "ruby.identity-cache")
            .help("Cache size for inline caches comparing by identity for context-independent objects")
            .category(OptionCategory.INTERNAL)
            .stability(OptionStability.EXPERIMENTAL)
            .usageSyntax("1")
            .build();

    public static final OptionDescriptor CONTEXT_SPECIFIC_IDENTITY_CACHE = OptionDescriptor
            .newBuilder(CONTEXT_SPECIFIC_IDENTITY_CACHE_KEY, "ruby.context-identity-cache")
            .help("Cache size for inline caches comparing by identity for context-specific objects")
            .category(OptionCategory.INTERNAL)
            .stability(OptionStability.EXPERIMENTAL)
            .usageSyntax("1")
            .build();

    public static final OptionDescriptor CLASS_CACHE = OptionDescriptor
            .newBuilder(CLASS_CACHE_KEY, "ruby.class-cache")
            .help(".class and .metaclass cache size")
            .category(OptionCategory.INTERNAL)
            .stability(OptionStability.EXPERIMENTAL)
            .usageSyntax("3")
            .build();

    public static final OptionDescriptor ARRAY_DUP_CACHE = OptionDescriptor
            .newBuilder(ARRAY_DUP_CACHE_KEY, "ruby.array-dup-cache")
            .help("Cache size for copying small arrays")
            .category(OptionCategory.INTERNAL)
            .stability(OptionStability.EXPERIMENTAL)
            .usageSyntax("3")
            .build();

    public static final OptionDescriptor ARRAY_STRATEGY_CACHE = OptionDescriptor
            .newBuilder(ARRAY_STRATEGY_CACHE_KEY, "ruby.array-strategy-cache")
            .help("Cache size for array strategies")
            .category(OptionCategory.INTERNAL)
            .stability(OptionStability.EXPERIMENTAL)
            .usageSyntax("4")
            .build();

    public static final OptionDescriptor ARRAY_UNINITIALIZED_SIZE = OptionDescriptor
            .newBuilder(ARRAY_UNINITIALIZED_SIZE_KEY, "ruby.array-uninitialized-size")
            .help("How large an Array to allocate when we have no other information to go on")
            .category(OptionCategory.INTERNAL)
            .stability(OptionStability.EXPERIMENTAL)
            .usageSyntax("16")
            .build();

    public static final OptionDescriptor ARRAY_SMALL = OptionDescriptor
            .newBuilder(ARRAY_SMALL_KEY, "ruby.array-small")
            .help("Maximum size of an Array to consider small for optimisations")
            .category(OptionCategory.INTERNAL)
            .stability(OptionStability.EXPERIMENTAL)
            .usageSyntax("3")
            .build();

    public static final OptionDescriptor PACK_UNROLL_LIMIT = OptionDescriptor
            .newBuilder(PACK_UNROLL_LIMIT_KEY, "ruby.pack-unroll")
            .help("If a pack or unpack expression has a loop less than this many iterations, unroll it")
            .category(OptionCategory.INTERNAL)
            .stability(OptionStability.EXPERIMENTAL)
            .usageSyntax("4")
            .build();

    public static final OptionDescriptor PACK_RECOVER_LOOP_MIN = OptionDescriptor
            .newBuilder(PACK_RECOVER_LOOP_MIN_KEY, "ruby.pack-recover")
            .help("If a pack or unpack expression is longer than this, attempt to recover loops")
            .category(OptionCategory.INTERNAL)
            .stability(OptionStability.EXPERIMENTAL)
            .usageSyntax("32")
            .build();

    public static final OptionDescriptor CEXTS_MARKING_CACHE = OptionDescriptor
            .newBuilder(CEXTS_MARKING_CACHE_KEY, "ruby.cexts-marking-cache")
            .help("Number of objects converted to native handles before the marking service is run")
            .category(OptionCategory.INTERNAL)
            .stability(OptionStability.EXPERIMENTAL)
            .usageSyntax("100")
            .build();

    public static final OptionDescriptor GLOBAL_VARIABLE_MAX_INVALIDATIONS = OptionDescriptor
            .newBuilder(GLOBAL_VARIABLE_MAX_INVALIDATIONS_KEY, "ruby.global-variable-max-invalidations")
            .help("Maximum number of times a global variable can be changed to be considered constant")
            .category(OptionCategory.INTERNAL)
            .stability(OptionStability.EXPERIMENTAL)
            .usageSyntax("1")
            .build();

    public static final OptionDescriptor CLONE_DEFAULT = OptionDescriptor
            .newBuilder(CLONE_DEFAULT_KEY, "ruby.clone-default")
            .help("Default option for cloning")
            .category(OptionCategory.INTERNAL)
            .stability(OptionStability.EXPERIMENTAL)
            .usageSyntax("")
            .build();

    public static final OptionDescriptor INLINE_DEFAULT = OptionDescriptor
            .newBuilder(INLINE_DEFAULT_KEY, "ruby.inline-default")
            .help("Default option for inlining")
            .category(OptionCategory.INTERNAL)
            .stability(OptionStability.EXPERIMENTAL)
            .usageSyntax("")
            .build();

    public static final OptionDescriptor CORE_ALWAYS_CLONE = OptionDescriptor
            .newBuilder(CORE_ALWAYS_CLONE_KEY, "ruby.core-always-clone")
            .help("Always clone built-in core methods")
            .category(OptionCategory.INTERNAL)
            .stability(OptionStability.EXPERIMENTAL)
            .usageSyntax("")
            .build();

    public static final OptionDescriptor ALWAYS_CLONE_ALL = OptionDescriptor
            .newBuilder(ALWAYS_CLONE_ALL_KEY, "ruby.always-clone-all")
            .help("Always clone all call targets (very slow, only for debugging)")
            .category(OptionCategory.INTERNAL)
            .stability(OptionStability.EXPERIMENTAL)
            .usageSyntax("")
            .build();

    public static final OptionDescriptor ALWAYS_SPLIT_HONOR = OptionDescriptor
            .newBuilder(ALWAYS_SPLIT_HONOR_KEY, "ruby.always-split-honor")
            .help("Honor Truffle::Graal.always_split annotations")
            .category(OptionCategory.INTERNAL)
            .stability(OptionStability.EXPERIMENTAL)
            .usageSyntax("")
            .build();

    public static final OptionDescriptor NEVER_SPLIT_HONOR = OptionDescriptor
            .newBuilder(NEVER_SPLIT_HONOR_KEY, "ruby.never-split-honor")
            .help("Honor Truffle::Graal.never_split annotations")
            .category(OptionCategory.INTERNAL)
            .stability(OptionStability.EXPERIMENTAL)
            .usageSyntax("")
            .build();

    public static final OptionDescriptor YIELD_ALWAYS_INLINE = OptionDescriptor
            .newBuilder(YIELD_ALWAYS_INLINE_KEY, "ruby.yield-always-inline")
            .help("Always inline yields")
            .category(OptionCategory.INTERNAL)
            .stability(OptionStability.EXPERIMENTAL)
            .usageSyntax("")
            .build();

    public static final OptionDescriptor METHODMISSING_ALWAYS_CLONE = OptionDescriptor
            .newBuilder(METHODMISSING_ALWAYS_CLONE_KEY, "ruby.method-missing-always-clone")
            .help("Always clone #method_missing")
            .category(OptionCategory.INTERNAL)
            .stability(OptionStability.EXPERIMENTAL)
            .usageSyntax("")
            .build();

    public static final OptionDescriptor METHODMISSING_ALWAYS_INLINE = OptionDescriptor
            .newBuilder(METHODMISSING_ALWAYS_INLINE_KEY, "ruby.method-missing-always-inline")
            .help("Always inline #method_missing")
            .category(OptionCategory.INTERNAL)
            .stability(OptionStability.EXPERIMENTAL)
            .usageSyntax("")
            .build();

    public static final OptionDescriptor CHECK_CLONE_UNINITIALIZED_CORRECTNESS = OptionDescriptor
            .newBuilder(CHECK_CLONE_UNINITIALIZED_CORRECTNESS_KEY, "ruby.check-clone-uninitialized-correctness")
            .help("Check whether #cloneUninitialized correctly clones a root node AST")
            .category(OptionCategory.INTERNAL)
            .stability(OptionStability.EXPERIMENTAL)
            .usageSyntax("")
            .build();

    public static final OptionDescriptor REGEXP_INSTRUMENT_CREATION = OptionDescriptor
            .newBuilder(REGEXP_INSTRUMENT_CREATION_KEY, "ruby.regexp-instrument-creation")
            .help("Enable instrumentation to gather stats on regexp creation")
            .category(OptionCategory.INTERNAL)
            .stability(OptionStability.EXPERIMENTAL)
            .usageSyntax("")
            .build();

    public static final OptionDescriptor REGEXP_INSTRUMENT_MATCH = OptionDescriptor
            .newBuilder(REGEXP_INSTRUMENT_MATCH_KEY, "ruby.regexp-instrument-match")
            .help("Enable instrumentation to gather stats on regexp matching")
            .category(OptionCategory.INTERNAL)
            .stability(OptionStability.EXPERIMENTAL)
            .usageSyntax("")
            .build();

    public static final OptionDescriptor REGEXP_INSTRUMENT_MATCH_DETAILED = OptionDescriptor
            .newBuilder(REGEXP_INSTRUMENT_MATCH_DETAILED_KEY, "ruby.regexp-instrument-match-detailed")
            .help("Enable instrumentation to gather detailed stats on strings matched against a regexp")
            .category(OptionCategory.INTERNAL)
            .stability(OptionStability.EXPERIMENTAL)
            .usageSyntax("")
            .build();

    public static final OptionDescriptor REGEXP_INSTRUMENT_OUTPUT_FORMAT = OptionDescriptor
            .newBuilder(REGEXP_INSTRUMENT_OUTPUT_FORMAT_KEY, "ruby.regexp-instrumentation-output-format")
            .help("Output format for regexp instrumentation")
            .category(OptionCategory.INTERNAL)
            .stability(OptionStability.EXPERIMENTAL)
            .usageSyntax("")
            .build();

    public static final OptionDescriptor METRICS_TIME_PARSING_FILE = OptionDescriptor
            .newBuilder(METRICS_TIME_PARSING_FILE_KEY, "ruby.metrics-time-parsing-file")
            .help("Measure time for parsing, translating and executing files, per file")
            .category(OptionCategory.INTERNAL)
            .stability(OptionStability.EXPERIMENTAL)
            .usageSyntax("")
            .build();

    public static final OptionDescriptor METRICS_TIME_REQUIRE = OptionDescriptor
            .newBuilder(METRICS_TIME_REQUIRE_KEY, "ruby.metrics-time-require")
            .help("Measure time for #require and executing the required file")
            .category(OptionCategory.INTERNAL)
            .stability(OptionStability.EXPERIMENTAL)
            .usageSyntax("")
            .build();

    public static final OptionDescriptor SHARED_OBJECTS_ENABLED = OptionDescriptor
            .newBuilder(SHARED_OBJECTS_ENABLED_KEY, "ruby.shared-objects")
            .help("Enable thread-safe objects")
            .category(OptionCategory.INTERNAL)
            .stability(OptionStability.EXPERIMENTAL)
            .usageSyntax("")
            .build();

    public static final OptionDescriptor SHARED_OBJECTS_DEBUG = OptionDescriptor
            .newBuilder(SHARED_OBJECTS_DEBUG_KEY, "ruby.shared-objects-debug")
            .help("Print information about shared objects")
            .category(OptionCategory.INTERNAL)
            .stability(OptionStability.EXPERIMENTAL)
            .usageSyntax("")
            .build();

    public static final OptionDescriptor SHARED_OBJECTS_FORCE = OptionDescriptor
            .newBuilder(SHARED_OBJECTS_FORCE_KEY, "ruby.shared-objects-force")
            .help("Force sharing of objects roots at startup")
            .category(OptionCategory.INTERNAL)
            .stability(OptionStability.EXPERIMENTAL)
            .usageSyntax("")
            .build();

    public static final OptionDescriptor TESTING_RUBYGEMS = OptionDescriptor
            .newBuilder(TESTING_RUBYGEMS_KEY, "ruby.testing-rubygems")
            .help("Indicates rubygems is being tested")
            .category(OptionCategory.INTERNAL)
            .stability(OptionStability.EXPERIMENTAL)
            .usageSyntax("")
            .build();

    public static final OptionDescriptor RUN_TWICE = OptionDescriptor
            .newBuilder(RUN_TWICE_KEY, "ruby.run-twice")
            .help("Run a workload twice using a shared engine in the same process")
            .category(OptionCategory.INTERNAL)
            .stability(OptionStability.EXPERIMENTAL)
            .usageSyntax("")
            .build();

    public static final OptionDescriptor EXPERIMENTAL_ENGINE_CACHING = OptionDescriptor
            .newBuilder(EXPERIMENTAL_ENGINE_CACHING_KEY, "ruby.experimental-engine-caching")
            .help("Enables experimental support for engine caching for TruffleRuby")
            .category(OptionCategory.INTERNAL)
            .stability(OptionStability.EXPERIMENTAL)
            .usageSyntax("")
            .build();

    public static final OptionDescriptor COMPARE_REGEX_ENGINES = OptionDescriptor
            .newBuilder(COMPARE_REGEX_ENGINES_KEY, "ruby.compare-regex-engines")
            .help("Uses both Joni and the TRegex engine and compares their results")
            .category(OptionCategory.INTERNAL)
            .stability(OptionStability.EXPERIMENTAL)
            .usageSyntax("")
            .build();

    public static OptionDescriptor fromName(String name) {
        switch (name) {
            case "ruby.load-paths":
                return LOAD_PATHS;
            case "ruby.required-libraries":
                return REQUIRED_LIBRARIES;
            case "ruby.working-directory":
                return WORKING_DIRECTORY;
            case "ruby.debug":
                return DEBUG;
            case "ruby.verbose":
                return VERBOSITY;
            case "ruby.source-encoding":
                return SOURCE_ENCODING;
            case "ruby.internal-encoding":
                return INTERNAL_ENCODING;
            case "ruby.external-encoding":
                return EXTERNAL_ENCODING;
            case "ruby.backtrace-limit":
                return BACKTRACE_LIMIT;
            case "ruby.launcher":
                return LAUNCHER;
            case "ruby.core-load-path":
                return CORE_LOAD_PATH;
            case "ruby.frozen-string-literals":
                return FROZEN_STRING_LITERALS;
            case "ruby.rubygems":
                return RUBYGEMS;
            case "ruby.did-you-mean":
                return DID_YOU_MEAN;
            case "ruby.lazy-default":
                return DEFAULT_LAZY;
            case "ruby.lazy-calltargets":
                return LAZY_CALLTARGETS;
            case "ruby.lazy-rubygems":
                return LAZY_RUBYGEMS;
            case "ruby.embedded":
                return EMBEDDED;
            case "ruby.platform-native":
                return NATIVE_PLATFORM;
            case "ruby.platform-native-interrupt":
                return NATIVE_INTERRUPT;
            case "ruby.platform-handle-interrupt":
                return HANDLE_INTERRUPT;
            case "ruby.single-threaded":
                return SINGLE_THREADED;
            case "ruby.polyglot-stdio":
                return POLYGLOT_STDIO;
            case "ruby.interop-host":
                return HOST_INTEROP;
            case "ruby.trace-calls":
                return TRACE_CALLS;
            case "ruby.coverage-global":
                return COVERAGE_GLOBAL;
            case "ruby.core-as-internal":
                return CORE_AS_INTERNAL;
            case "ruby.stdlib-as-internal":
                return STDLIB_AS_INTERNAL;
            case "ruby.lazy-translation-user":
                return LAZY_TRANSLATION_USER;
            case "ruby.patching":
                return PATCHING;
            case "ruby.hashing-deterministic":
                return HASHING_DETERMINISTIC;
            case "ruby.virtual-thread-fibers":
                return VIRTUAL_THREAD_FIBERS;
            case "ruby.log-subprocess":
                return LOG_SUBPROCESS;
            case "ruby.warn-locale":
                return WARN_LOCALE;
            case "ruby.exceptions-store-java":
                return EXCEPTIONS_STORE_JAVA;
            case "ruby.exceptions-print-java":
                return EXCEPTIONS_PRINT_JAVA;
            case "ruby.exceptions-print-uncaught-java":
                return EXCEPTIONS_PRINT_UNCAUGHT_JAVA;
            case "ruby.exceptions-print-ruby-for-java":
                return EXCEPTIONS_PRINT_RUBY_FOR_JAVA;
            case "ruby.exceptions-warn-stackoverflow":
                return EXCEPTIONS_WARN_STACKOVERFLOW;
            case "ruby.exceptions-warn-out-of-memory":
                return EXCEPTIONS_WARN_OUT_OF_MEMORY;
            case "ruby.backtraces-interleave-java":
                return BACKTRACES_INTERLEAVE_JAVA;
            case "ruby.backtraces-omit-unused":
                return BACKTRACES_OMIT_UNUSED;
            case "ruby.buckets-big-hash":
                return BIG_HASH_STRATEGY_IS_BUCKETS;
            case "ruby.backtraces-on-interrupt":
                return BACKTRACE_ON_INTERRUPT;
            case "ruby.backtraces-sigalrm":
                return BACKTRACE_ON_SIGALRM;
            case "ruby.backtraces-raise":
                return BACKTRACE_ON_RAISE;
            case "ruby.backtraces-rescue":
                return BACKTRACE_ON_RESCUE;
            case "ruby.backtraces-new-thread":
                return BACKTRACE_ON_NEW_THREAD;
            case "ruby.backtraces-new-fiber":
                return BACKTRACE_ON_NEW_FIBER;
            case "ruby.cexts":
                return CEXTS;
            case "ruby.cexts-lock":
                return CEXT_LOCK;
            case "ruby.cexts-panama":
                return CEXTS_PANAMA;
            case "ruby.options-log":
                return OPTIONS_LOG;
            case "ruby.log-load":
                return LOG_LOAD;
            case "ruby.log-autoload":
                return LOG_AUTOLOAD;
            case "ruby.log-feature-location":
                return LOG_FEATURE_LOCATION;
            case "ruby.metrics-profile-require":
                return METRICS_PROFILE_REQUIRE;
            case "ruby.cexts-log-load":
                return CEXTS_LOG_LOAD;
            case "ruby.cexts-log-warnings":
                return CEXTS_LOG_WARNINGS;
            case "ruby.warn-deprecated":
                return WARN_DEPRECATED;
            case "ruby.warn-experimental":
                return WARN_EXPERIMENTAL;
            case "ruby.warn-performance":
                return WARN_PERFORMANCE;
            case "ruby.use-truffle-regex":
                return USE_TRUFFLE_REGEX;
            case "ruby.warn-truffle-regex-compile-fallback":
                return WARN_TRUFFLE_REGEX_COMPILE_FALLBACK;
            case "ruby.warn-truffle-regex-match-fallback":
                return WARN_TRUFFLE_REGEX_MATCH_FALLBACK;
            case "ruby.truffle-regex-ignore-atomic-groups":
                return TRUFFLE_REGEX_IGNORE_ATOMIC_GROUPS;
            case "ruby.reuse-precompiled-gems":
                return REUSE_PRECOMPILED_GEMS;
            case "ruby.argv-globals":
                return ARGV_GLOBALS;
            case "ruby.chomp-loop":
                return CHOMP_LOOP;
            case "ruby.gets-loop":
                return GETS_LOOP;
            case "ruby.print-loop":
                return PRINT_LOOP;
            case "ruby.split-loop":
                return SPLIT_LOOP;
            case "ruby.ignore-lines-before-ruby-shebang":
                return IGNORE_LINES_BEFORE_RUBY_SHEBANG;
            case "ruby.syntax-check":
                return SYNTAX_CHECK;
            case "ruby.argv-global-values":
                return ARGV_GLOBAL_VALUES;
            case "ruby.argv-global-flags":
                return ARGV_GLOBAL_FLAGS;
            case "ruby.building-core-cexts":
                return BUILDING_CORE_CEXTS;
            case "ruby.lazy-translation-log":
                return LAZY_TRANSLATION_LOG;
            case "ruby.constant-dynamic-lookup-log":
                return LOG_DYNAMIC_CONSTANT_LOOKUP;
            case "ruby.log-pending-interrupts":
                return LOG_PENDING_INTERRUPTS;
            case "ruby.print-interned-tstring-stats":
                return PRINT_INTERNED_TSTRING_STATS;
            case "ruby.cexts-to-native-stats":
                return CEXTS_TO_NATIVE_STATS;
            case "ruby.cexts-to-native-count":
                return CEXTS_TO_NATIVE_COUNT;
            case "ruby.backtraces-to-native":
                return BACKTRACE_ON_TO_NATIVE;
            case "ruby.keep-handles-alive":
                return CEXTS_KEEP_HANDLES_ALIVE;
            case "ruby.cexts-sulong":
                return CEXTS_SULONG;
            case "ruby.lazy-builtins":
                return LAZY_BUILTINS;
            case "ruby.lazy-translation-core":
                return LAZY_TRANSLATION_CORE;
            case "ruby.chaos-data":
                return CHAOS_DATA;
            case "ruby.instrument-all-nodes":
                return INSTRUMENT_ALL_NODES;
            case "ruby.basic-ops-inline":
                return BASICOPS_INLINE;
            case "ruby.basic-ops-log-rewrite":
                return BASICOPS_LOG_REWRITE;
            case "ruby.profile-arguments":
                return PROFILE_ARGUMENTS;
            case "ruby.default-cache":
                return DEFAULT_CACHE;
            case "ruby.method-lookup-cache":
                return METHOD_LOOKUP_CACHE;
            case "ruby.dispatch-cache":
                return DISPATCH_CACHE;
            case "ruby.yield-cache":
                return YIELD_CACHE;
            case "ruby.is-a-cache":
                return IS_A_CACHE;
            case "ruby.bind-cache":
                return BIND_CACHE;
            case "ruby.constant-cache":
                return CONSTANT_CACHE;
            case "ruby.instance-variable-cache":
                return INSTANCE_VARIABLE_CACHE;
            case "ruby.binding-local-variable-cache":
                return BINDING_LOCAL_VARIABLE_CACHE;
            case "ruby.symbol-to-proc-cache":
                return SYMBOL_TO_PROC_CACHE;
            case "ruby.pack-cache":
                return PACK_CACHE;
            case "ruby.unpack-cache":
                return UNPACK_CACHE;
            case "ruby.eval-cache":
                return EVAL_CACHE;
            case "ruby.encoding-compatible-query-cache":
                return ENCODING_COMPATIBLE_QUERY_CACHE;
            case "ruby.encoding-loaded-classes-cache":
                return ENCODING_LOADED_CLASSES_CACHE;
            case "ruby.interop-convert-cache":
                return INTEROP_CONVERT_CACHE;
            case "ruby.time-format-cache":
                return TIME_FORMAT_CACHE;
            case "ruby.integer-pow-cache":
                return POW_CACHE;
            case "ruby.identity-cache":
                return IDENTITY_CACHE;
            case "ruby.context-identity-cache":
                return CONTEXT_SPECIFIC_IDENTITY_CACHE;
            case "ruby.class-cache":
                return CLASS_CACHE;
            case "ruby.array-dup-cache":
                return ARRAY_DUP_CACHE;
            case "ruby.array-strategy-cache":
                return ARRAY_STRATEGY_CACHE;
            case "ruby.array-uninitialized-size":
                return ARRAY_UNINITIALIZED_SIZE;
            case "ruby.array-small":
                return ARRAY_SMALL;
            case "ruby.pack-unroll":
                return PACK_UNROLL_LIMIT;
            case "ruby.pack-recover":
                return PACK_RECOVER_LOOP_MIN;
            case "ruby.cexts-marking-cache":
                return CEXTS_MARKING_CACHE;
            case "ruby.global-variable-max-invalidations":
                return GLOBAL_VARIABLE_MAX_INVALIDATIONS;
            case "ruby.clone-default":
                return CLONE_DEFAULT;
            case "ruby.inline-default":
                return INLINE_DEFAULT;
            case "ruby.core-always-clone":
                return CORE_ALWAYS_CLONE;
            case "ruby.always-clone-all":
                return ALWAYS_CLONE_ALL;
            case "ruby.always-split-honor":
                return ALWAYS_SPLIT_HONOR;
            case "ruby.never-split-honor":
                return NEVER_SPLIT_HONOR;
            case "ruby.yield-always-inline":
                return YIELD_ALWAYS_INLINE;
            case "ruby.method-missing-always-clone":
                return METHODMISSING_ALWAYS_CLONE;
            case "ruby.method-missing-always-inline":
                return METHODMISSING_ALWAYS_INLINE;
            case "ruby.check-clone-uninitialized-correctness":
                return CHECK_CLONE_UNINITIALIZED_CORRECTNESS;
            case "ruby.regexp-instrument-creation":
                return REGEXP_INSTRUMENT_CREATION;
            case "ruby.regexp-instrument-match":
                return REGEXP_INSTRUMENT_MATCH;
            case "ruby.regexp-instrument-match-detailed":
                return REGEXP_INSTRUMENT_MATCH_DETAILED;
            case "ruby.regexp-instrumentation-output-format":
                return REGEXP_INSTRUMENT_OUTPUT_FORMAT;
            case "ruby.metrics-time-parsing-file":
                return METRICS_TIME_PARSING_FILE;
            case "ruby.metrics-time-require":
                return METRICS_TIME_REQUIRE;
            case "ruby.shared-objects":
                return SHARED_OBJECTS_ENABLED;
            case "ruby.shared-objects-debug":
                return SHARED_OBJECTS_DEBUG;
            case "ruby.shared-objects-force":
                return SHARED_OBJECTS_FORCE;
            case "ruby.testing-rubygems":
                return TESTING_RUBYGEMS;
            case "ruby.run-twice":
                return RUN_TWICE;
            case "ruby.experimental-engine-caching":
                return EXPERIMENTAL_ENGINE_CACHING;
            case "ruby.compare-regex-engines":
                return COMPARE_REGEX_ENGINES;
            default:
                return null;
        }
    }

    public static OptionDescriptor[] allDescriptors() {
        return new OptionDescriptor[] {
            LOAD_PATHS,
            REQUIRED_LIBRARIES,
            WORKING_DIRECTORY,
            DEBUG,
            VERBOSITY,
            SOURCE_ENCODING,
            INTERNAL_ENCODING,
            EXTERNAL_ENCODING,
            BACKTRACE_LIMIT,
            LAUNCHER,
            CORE_LOAD_PATH,
            FROZEN_STRING_LITERALS,
            RUBYGEMS,
            DID_YOU_MEAN,
            DEFAULT_LAZY,
            LAZY_CALLTARGETS,
            LAZY_RUBYGEMS,
            EMBEDDED,
            NATIVE_PLATFORM,
            NATIVE_INTERRUPT,
            HANDLE_INTERRUPT,
            SINGLE_THREADED,
            POLYGLOT_STDIO,
            HOST_INTEROP,
            TRACE_CALLS,
            COVERAGE_GLOBAL,
            CORE_AS_INTERNAL,
            STDLIB_AS_INTERNAL,
            LAZY_TRANSLATION_USER,
            PATCHING,
            HASHING_DETERMINISTIC,
            VIRTUAL_THREAD_FIBERS,
            LOG_SUBPROCESS,
            WARN_LOCALE,
            EXCEPTIONS_STORE_JAVA,
            EXCEPTIONS_PRINT_JAVA,
            EXCEPTIONS_PRINT_UNCAUGHT_JAVA,
            EXCEPTIONS_PRINT_RUBY_FOR_JAVA,
            EXCEPTIONS_WARN_STACKOVERFLOW,
            EXCEPTIONS_WARN_OUT_OF_MEMORY,
            BACKTRACES_INTERLEAVE_JAVA,
            BACKTRACES_OMIT_UNUSED,
            BIG_HASH_STRATEGY_IS_BUCKETS,
            BACKTRACE_ON_INTERRUPT,
            BACKTRACE_ON_SIGALRM,
            BACKTRACE_ON_RAISE,
            BACKTRACE_ON_RESCUE,
            BACKTRACE_ON_NEW_THREAD,
            BACKTRACE_ON_NEW_FIBER,
            CEXTS,
            CEXT_LOCK,
            CEXTS_PANAMA,
            OPTIONS_LOG,
            LOG_LOAD,
            LOG_AUTOLOAD,
            LOG_FEATURE_LOCATION,
            METRICS_PROFILE_REQUIRE,
            CEXTS_LOG_LOAD,
            CEXTS_LOG_WARNINGS,
            WARN_DEPRECATED,
            WARN_EXPERIMENTAL,
            WARN_PERFORMANCE,
            USE_TRUFFLE_REGEX,
            WARN_TRUFFLE_REGEX_COMPILE_FALLBACK,
            WARN_TRUFFLE_REGEX_MATCH_FALLBACK,
            TRUFFLE_REGEX_IGNORE_ATOMIC_GROUPS,
            REUSE_PRECOMPILED_GEMS,
            ARGV_GLOBALS,
            CHOMP_LOOP,
            GETS_LOOP,
            PRINT_LOOP,
            SPLIT_LOOP,
            IGNORE_LINES_BEFORE_RUBY_SHEBANG,
            SYNTAX_CHECK,
            ARGV_GLOBAL_VALUES,
            ARGV_GLOBAL_FLAGS,
            BUILDING_CORE_CEXTS,
            LAZY_TRANSLATION_LOG,
            LOG_DYNAMIC_CONSTANT_LOOKUP,
            LOG_PENDING_INTERRUPTS,
            PRINT_INTERNED_TSTRING_STATS,
            CEXTS_TO_NATIVE_STATS,
            CEXTS_TO_NATIVE_COUNT,
            BACKTRACE_ON_TO_NATIVE,
            CEXTS_KEEP_HANDLES_ALIVE,
            CEXTS_SULONG,
            LAZY_BUILTINS,
            LAZY_TRANSLATION_CORE,
            CHAOS_DATA,
            INSTRUMENT_ALL_NODES,
            BASICOPS_INLINE,
            BASICOPS_LOG_REWRITE,
            PROFILE_ARGUMENTS,
            DEFAULT_CACHE,
            METHOD_LOOKUP_CACHE,
            DISPATCH_CACHE,
            YIELD_CACHE,
            IS_A_CACHE,
            BIND_CACHE,
            CONSTANT_CACHE,
            INSTANCE_VARIABLE_CACHE,
            BINDING_LOCAL_VARIABLE_CACHE,
            SYMBOL_TO_PROC_CACHE,
            PACK_CACHE,
            UNPACK_CACHE,
            EVAL_CACHE,
            ENCODING_COMPATIBLE_QUERY_CACHE,
            ENCODING_LOADED_CLASSES_CACHE,
            INTEROP_CONVERT_CACHE,
            TIME_FORMAT_CACHE,
            POW_CACHE,
            IDENTITY_CACHE,
            CONTEXT_SPECIFIC_IDENTITY_CACHE,
            CLASS_CACHE,
            ARRAY_DUP_CACHE,
            ARRAY_STRATEGY_CACHE,
            ARRAY_UNINITIALIZED_SIZE,
            ARRAY_SMALL,
            PACK_UNROLL_LIMIT,
            PACK_RECOVER_LOOP_MIN,
            CEXTS_MARKING_CACHE,
            GLOBAL_VARIABLE_MAX_INVALIDATIONS,
            CLONE_DEFAULT,
            INLINE_DEFAULT,
            CORE_ALWAYS_CLONE,
            ALWAYS_CLONE_ALL,
            ALWAYS_SPLIT_HONOR,
            NEVER_SPLIT_HONOR,
            YIELD_ALWAYS_INLINE,
            METHODMISSING_ALWAYS_CLONE,
            METHODMISSING_ALWAYS_INLINE,
            CHECK_CLONE_UNINITIALIZED_CORRECTNESS,
            REGEXP_INSTRUMENT_CREATION,
            REGEXP_INSTRUMENT_MATCH,
            REGEXP_INSTRUMENT_MATCH_DETAILED,
            REGEXP_INSTRUMENT_OUTPUT_FORMAT,
            METRICS_TIME_PARSING_FILE,
            METRICS_TIME_REQUIRE,
            SHARED_OBJECTS_ENABLED,
            SHARED_OBJECTS_DEBUG,
            SHARED_OBJECTS_FORCE,
            TESTING_RUBYGEMS,
            RUN_TWICE,
            EXPERIMENTAL_ENGINE_CACHING,
            COMPARE_REGEX_ENGINES,
        };
    }
}
// @formatter:on
