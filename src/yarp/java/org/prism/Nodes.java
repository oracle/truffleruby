/*----------------------------------------------------------------------------*/
/* This file is generated by the templates/template.rb script and should not  */
/* be modified manually. See                                                  */
/* templates/java/org/prism/Nodes.java.erb                                    */
/* if you are looking to modify the                                           */
/* template                                                                   */
/*----------------------------------------------------------------------------*/

package org.prism;

import java.lang.Override;
import java.lang.String;
import java.lang.StringBuilder;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.Arrays;

// GENERATED BY Nodes.java.erb
// @formatter:off
public abstract class Nodes {

    public static final String[] EMPTY_STRING_ARRAY = {};

    @Target(ElementType.FIELD)
    @Retention(RetentionPolicy.SOURCE)
    public @interface Nullable {
    }

    @Target(ElementType.FIELD)
    @Retention(RetentionPolicy.SOURCE)
    public @interface UnionType {
        Class<? extends Node>[] value();
    }

    public static final class Location {

        public static final Location[] EMPTY_ARRAY = {};

        public final int startOffset;
        public final int length;

        public Location(int startOffset, int length) {
            this.startOffset = startOffset;
            this.length = length;
        }

        public int endOffset() {
            return startOffset + length;
        }
    }

    public static final class Source {
        public final byte[] bytes;
        private int startLine = 1;
        private int[] lineOffsets = null;

        Source(byte[] bytes) {
          this.bytes = bytes;
        }

        void setStartLine(int startLine) {
            this.startLine = startLine;
        }

        void setLineOffsets(int[] lineOffsets) {
            this.lineOffsets = lineOffsets;
        }

        // 1-based
        public int line(int byteOffset) {
            return startLine + findLine(byteOffset);
        }

        // 0-based
        public int findLine(int byteOffset) {
            if (byteOffset >= bytes.length) byteOffset = bytes.length - 1;
            assert byteOffset >= 0 : byteOffset;
            int index = Arrays.binarySearch(lineOffsets, byteOffset);
            int line;
            if (index < 0) {
                line = -index - 2;
            } else {
                line = index;
            }
            assert line >= 0 && line <= getLineCount() : line;
            return line;
        }

        public int getLineCount() {
            return lineOffsets.length;
        }
    }

    public static abstract class Node {

        public static final Node[] EMPTY_ARRAY = {};

        public final int startOffset;
        public final int length;
        private boolean newLineFlag = false;

        public Node(int startOffset, int length) {
            this.startOffset = startOffset;
            this.length = length;
        }

        public final int endOffset() {
            return startOffset + length;
        }

        public final boolean hasNewLineFlag() {
            return newLineFlag;
        }

        public void setNewLineFlag(Source source, boolean[] newlineMarked) {
            int line = source.findLine(this.startOffset);
            if (!newlineMarked[line]) {
                newlineMarked[line] = true;
                this.newLineFlag = true;
            }
        }

        public void setNewLineFlag(boolean newLineFlag) {
            this.newLineFlag = newLineFlag;
        }

        public abstract <T> T accept(AbstractNodeVisitor<T> visitor);

        public abstract <T> void visitChildNodes(AbstractNodeVisitor<T> visitor);

        public abstract Node[] childNodes();

        @Override
        public String toString() {
            return toString("");
        }

        protected abstract String toString(String indent);
    }

    /**
     * Flags for arguments nodes.
     */
    public static final class ArgumentsNodeFlags implements Comparable<ArgumentsNodeFlags> {

        // if arguments contain keywords
        public static final short CONTAINS_KEYWORDS = 1 << 0;

        // if arguments contain keyword splat
        public static final short CONTAINS_KEYWORD_SPLAT = 1 << 1;

        // if arguments contain splat
        public static final short CONTAINS_SPLAT = 1 << 2;

        public static boolean isContainsKeywords(short flags) {
            return (flags & CONTAINS_KEYWORDS) != 0;
        }

        public static boolean isContainsKeywordSplat(short flags) {
            return (flags & CONTAINS_KEYWORD_SPLAT) != 0;
        }

        public static boolean isContainsSplat(short flags) {
            return (flags & CONTAINS_SPLAT) != 0;
        }

        private final short flags;

        public ArgumentsNodeFlags(short flags) {
            this.flags = flags;
        }

        @Override
        public int hashCode() {
            return flags;
        }

        @Override
        public boolean equals(Object other) {
            if (!(other instanceof ArgumentsNodeFlags)) {
                return false;
            }

            return flags == ((ArgumentsNodeFlags) other).flags;
        }

        @Override
        public int compareTo(ArgumentsNodeFlags other) {
            return flags - other.flags;
        }

        public boolean isContainsKeywords() {
            return (flags & CONTAINS_KEYWORDS) != 0;
        }

        public boolean isContainsKeywordSplat() {
            return (flags & CONTAINS_KEYWORD_SPLAT) != 0;
        }

        public boolean isContainsSplat() {
            return (flags & CONTAINS_SPLAT) != 0;
        }

    }

    /**
     * Flags for array nodes.
     */
    public static final class ArrayNodeFlags implements Comparable<ArrayNodeFlags> {

        // if array contains splat nodes
        public static final short CONTAINS_SPLAT = 1 << 0;

        public static boolean isContainsSplat(short flags) {
            return (flags & CONTAINS_SPLAT) != 0;
        }

        private final short flags;

        public ArrayNodeFlags(short flags) {
            this.flags = flags;
        }

        @Override
        public int hashCode() {
            return flags;
        }

        @Override
        public boolean equals(Object other) {
            if (!(other instanceof ArrayNodeFlags)) {
                return false;
            }

            return flags == ((ArrayNodeFlags) other).flags;
        }

        @Override
        public int compareTo(ArrayNodeFlags other) {
            return flags - other.flags;
        }

        public boolean isContainsSplat() {
            return (flags & CONTAINS_SPLAT) != 0;
        }

    }

    /**
     * Flags for call nodes.
     */
    public static final class CallNodeFlags implements Comparable<CallNodeFlags> {

        // &. operator
        public static final short SAFE_NAVIGATION = 1 << 0;

        // a call that could have been a local variable
        public static final short VARIABLE_CALL = 1 << 1;

        // a call that is an attribute write, so the value being written should be returned
        public static final short ATTRIBUTE_WRITE = 1 << 2;

        // a call that ignores method visibility
        public static final short IGNORE_VISIBILITY = 1 << 3;

        public static boolean isSafeNavigation(short flags) {
            return (flags & SAFE_NAVIGATION) != 0;
        }

        public static boolean isVariableCall(short flags) {
            return (flags & VARIABLE_CALL) != 0;
        }

        public static boolean isAttributeWrite(short flags) {
            return (flags & ATTRIBUTE_WRITE) != 0;
        }

        public static boolean isIgnoreVisibility(short flags) {
            return (flags & IGNORE_VISIBILITY) != 0;
        }

        private final short flags;

        public CallNodeFlags(short flags) {
            this.flags = flags;
        }

        @Override
        public int hashCode() {
            return flags;
        }

        @Override
        public boolean equals(Object other) {
            if (!(other instanceof CallNodeFlags)) {
                return false;
            }

            return flags == ((CallNodeFlags) other).flags;
        }

        @Override
        public int compareTo(CallNodeFlags other) {
            return flags - other.flags;
        }

        public boolean isSafeNavigation() {
            return (flags & SAFE_NAVIGATION) != 0;
        }

        public boolean isVariableCall() {
            return (flags & VARIABLE_CALL) != 0;
        }

        public boolean isAttributeWrite() {
            return (flags & ATTRIBUTE_WRITE) != 0;
        }

        public boolean isIgnoreVisibility() {
            return (flags & IGNORE_VISIBILITY) != 0;
        }

    }

    /**
     * Flags for nodes that have unescaped content.
     */
    public static final class EncodingFlags implements Comparable<EncodingFlags> {

        // internal bytes forced the encoding to UTF-8
        public static final short FORCED_UTF8_ENCODING = 1 << 0;

        // internal bytes forced the encoding to binary
        public static final short FORCED_BINARY_ENCODING = 1 << 1;

        public static boolean isForcedUtf8Encoding(short flags) {
            return (flags & FORCED_UTF8_ENCODING) != 0;
        }

        public static boolean isForcedBinaryEncoding(short flags) {
            return (flags & FORCED_BINARY_ENCODING) != 0;
        }

        private final short flags;

        public EncodingFlags(short flags) {
            this.flags = flags;
        }

        @Override
        public int hashCode() {
            return flags;
        }

        @Override
        public boolean equals(Object other) {
            if (!(other instanceof EncodingFlags)) {
                return false;
            }

            return flags == ((EncodingFlags) other).flags;
        }

        @Override
        public int compareTo(EncodingFlags other) {
            return flags - other.flags;
        }

        public boolean isForcedUtf8Encoding() {
            return (flags & FORCED_UTF8_ENCODING) != 0;
        }

        public boolean isForcedBinaryEncoding() {
            return (flags & FORCED_BINARY_ENCODING) != 0;
        }

    }

    /**
     * Flags for integer nodes that correspond to the base of the integer.
     */
    public static final class IntegerBaseFlags implements Comparable<IntegerBaseFlags> {

        // 0b prefix
        public static final short BINARY = 1 << 0;

        // 0d or no prefix
        public static final short DECIMAL = 1 << 1;

        // 0o or 0 prefix
        public static final short OCTAL = 1 << 2;

        // 0x prefix
        public static final short HEXADECIMAL = 1 << 3;

        public static boolean isBinary(short flags) {
            return (flags & BINARY) != 0;
        }

        public static boolean isDecimal(short flags) {
            return (flags & DECIMAL) != 0;
        }

        public static boolean isOctal(short flags) {
            return (flags & OCTAL) != 0;
        }

        public static boolean isHexadecimal(short flags) {
            return (flags & HEXADECIMAL) != 0;
        }

        private final short flags;

        public IntegerBaseFlags(short flags) {
            this.flags = flags;
        }

        @Override
        public int hashCode() {
            return flags;
        }

        @Override
        public boolean equals(Object other) {
            if (!(other instanceof IntegerBaseFlags)) {
                return false;
            }

            return flags == ((IntegerBaseFlags) other).flags;
        }

        @Override
        public int compareTo(IntegerBaseFlags other) {
            return flags - other.flags;
        }

        public boolean isBinary() {
            return (flags & BINARY) != 0;
        }

        public boolean isDecimal() {
            return (flags & DECIMAL) != 0;
        }

        public boolean isOctal() {
            return (flags & OCTAL) != 0;
        }

        public boolean isHexadecimal() {
            return (flags & HEXADECIMAL) != 0;
        }

    }

    /**
     * Flags for interpolated string nodes that indicated mutability if they are also marked as literals.
     */
    public static final class InterpolatedStringNodeFlags implements Comparable<InterpolatedStringNodeFlags> {

        // frozen by virtue of a `frozen_string_literal: true` comment or `--enable-frozen-string-literal`; only for adjacent string literals like `'a' 'b'`
        public static final short FROZEN = 1 << 0;

        // mutable by virtue of a `frozen_string_literal: false` comment or `--disable-frozen-string-literal`; only for adjacent string literals like `'a' 'b'`
        public static final short MUTABLE = 1 << 1;

        public static boolean isFrozen(short flags) {
            return (flags & FROZEN) != 0;
        }

        public static boolean isMutable(short flags) {
            return (flags & MUTABLE) != 0;
        }

        private final short flags;

        public InterpolatedStringNodeFlags(short flags) {
            this.flags = flags;
        }

        @Override
        public int hashCode() {
            return flags;
        }

        @Override
        public boolean equals(Object other) {
            if (!(other instanceof InterpolatedStringNodeFlags)) {
                return false;
            }

            return flags == ((InterpolatedStringNodeFlags) other).flags;
        }

        @Override
        public int compareTo(InterpolatedStringNodeFlags other) {
            return flags - other.flags;
        }

        public boolean isFrozen() {
            return (flags & FROZEN) != 0;
        }

        public boolean isMutable() {
            return (flags & MUTABLE) != 0;
        }

    }

    /**
     * Flags for keyword hash nodes.
     */
    public static final class KeywordHashNodeFlags implements Comparable<KeywordHashNodeFlags> {

        // a keyword hash which only has `AssocNode` elements all with symbol keys, which means the elements can be treated as keyword arguments
        public static final short SYMBOL_KEYS = 1 << 0;

        public static boolean isSymbolKeys(short flags) {
            return (flags & SYMBOL_KEYS) != 0;
        }

        private final short flags;

        public KeywordHashNodeFlags(short flags) {
            this.flags = flags;
        }

        @Override
        public int hashCode() {
            return flags;
        }

        @Override
        public boolean equals(Object other) {
            if (!(other instanceof KeywordHashNodeFlags)) {
                return false;
            }

            return flags == ((KeywordHashNodeFlags) other).flags;
        }

        @Override
        public int compareTo(KeywordHashNodeFlags other) {
            return flags - other.flags;
        }

        public boolean isSymbolKeys() {
            return (flags & SYMBOL_KEYS) != 0;
        }

    }

    /**
     * Flags for while and until loop nodes.
     */
    public static final class LoopFlags implements Comparable<LoopFlags> {

        // a loop after a begin statement, so the body is executed first before the condition
        public static final short BEGIN_MODIFIER = 1 << 0;

        public static boolean isBeginModifier(short flags) {
            return (flags & BEGIN_MODIFIER) != 0;
        }

        private final short flags;

        public LoopFlags(short flags) {
            this.flags = flags;
        }

        @Override
        public int hashCode() {
            return flags;
        }

        @Override
        public boolean equals(Object other) {
            if (!(other instanceof LoopFlags)) {
                return false;
            }

            return flags == ((LoopFlags) other).flags;
        }

        @Override
        public int compareTo(LoopFlags other) {
            return flags - other.flags;
        }

        public boolean isBeginModifier() {
            return (flags & BEGIN_MODIFIER) != 0;
        }

    }

    /**
     * Flags for parameter nodes.
     */
    public static final class ParameterFlags implements Comparable<ParameterFlags> {

        // a parameter name that has been repeated in the method signature
        public static final short REPEATED_PARAMETER = 1 << 0;

        public static boolean isRepeatedParameter(short flags) {
            return (flags & REPEATED_PARAMETER) != 0;
        }

        private final short flags;

        public ParameterFlags(short flags) {
            this.flags = flags;
        }

        @Override
        public int hashCode() {
            return flags;
        }

        @Override
        public boolean equals(Object other) {
            if (!(other instanceof ParameterFlags)) {
                return false;
            }

            return flags == ((ParameterFlags) other).flags;
        }

        @Override
        public int compareTo(ParameterFlags other) {
            return flags - other.flags;
        }

        public boolean isRepeatedParameter() {
            return (flags & REPEATED_PARAMETER) != 0;
        }

    }

    /**
     * Flags for range and flip-flop nodes.
     */
    public static final class RangeFlags implements Comparable<RangeFlags> {

        // ... operator
        public static final short EXCLUDE_END = 1 << 0;

        public static boolean isExcludeEnd(short flags) {
            return (flags & EXCLUDE_END) != 0;
        }

        private final short flags;

        public RangeFlags(short flags) {
            this.flags = flags;
        }

        @Override
        public int hashCode() {
            return flags;
        }

        @Override
        public boolean equals(Object other) {
            if (!(other instanceof RangeFlags)) {
                return false;
            }

            return flags == ((RangeFlags) other).flags;
        }

        @Override
        public int compareTo(RangeFlags other) {
            return flags - other.flags;
        }

        public boolean isExcludeEnd() {
            return (flags & EXCLUDE_END) != 0;
        }

    }

    /**
     * Flags for regular expression and match last line nodes.
     */
    public static final class RegularExpressionFlags implements Comparable<RegularExpressionFlags> {

        // i - ignores the case of characters when matching
        public static final short IGNORE_CASE = 1 << 0;

        // x - ignores whitespace and allows comments in regular expressions
        public static final short EXTENDED = 1 << 1;

        // m - allows $ to match the end of lines within strings
        public static final short MULTI_LINE = 1 << 2;

        // o - only interpolates values into the regular expression once
        public static final short ONCE = 1 << 3;

        // e - forces the EUC-JP encoding
        public static final short EUC_JP = 1 << 4;

        // n - forces the ASCII-8BIT encoding
        public static final short ASCII_8BIT = 1 << 5;

        // s - forces the Windows-31J encoding
        public static final short WINDOWS_31J = 1 << 6;

        // u - forces the UTF-8 encoding
        public static final short UTF_8 = 1 << 7;

        // internal bytes forced the encoding to UTF-8
        public static final short FORCED_UTF8_ENCODING = 1 << 8;

        // internal bytes forced the encoding to binary
        public static final short FORCED_BINARY_ENCODING = 1 << 9;

        // internal bytes forced the encoding to US-ASCII
        public static final short FORCED_US_ASCII_ENCODING = 1 << 10;

        public static boolean isIgnoreCase(short flags) {
            return (flags & IGNORE_CASE) != 0;
        }

        public static boolean isExtended(short flags) {
            return (flags & EXTENDED) != 0;
        }

        public static boolean isMultiLine(short flags) {
            return (flags & MULTI_LINE) != 0;
        }

        public static boolean isOnce(short flags) {
            return (flags & ONCE) != 0;
        }

        public static boolean isEucJp(short flags) {
            return (flags & EUC_JP) != 0;
        }

        public static boolean isAscii8bit(short flags) {
            return (flags & ASCII_8BIT) != 0;
        }

        public static boolean isWindows31j(short flags) {
            return (flags & WINDOWS_31J) != 0;
        }

        public static boolean isUtf8(short flags) {
            return (flags & UTF_8) != 0;
        }

        public static boolean isForcedUtf8Encoding(short flags) {
            return (flags & FORCED_UTF8_ENCODING) != 0;
        }

        public static boolean isForcedBinaryEncoding(short flags) {
            return (flags & FORCED_BINARY_ENCODING) != 0;
        }

        public static boolean isForcedUsAsciiEncoding(short flags) {
            return (flags & FORCED_US_ASCII_ENCODING) != 0;
        }

        private final short flags;

        public RegularExpressionFlags(short flags) {
            this.flags = flags;
        }

        @Override
        public int hashCode() {
            return flags;
        }

        @Override
        public boolean equals(Object other) {
            if (!(other instanceof RegularExpressionFlags)) {
                return false;
            }

            return flags == ((RegularExpressionFlags) other).flags;
        }

        @Override
        public int compareTo(RegularExpressionFlags other) {
            return flags - other.flags;
        }

        public boolean isIgnoreCase() {
            return (flags & IGNORE_CASE) != 0;
        }

        public boolean isExtended() {
            return (flags & EXTENDED) != 0;
        }

        public boolean isMultiLine() {
            return (flags & MULTI_LINE) != 0;
        }

        public boolean isOnce() {
            return (flags & ONCE) != 0;
        }

        public boolean isEucJp() {
            return (flags & EUC_JP) != 0;
        }

        public boolean isAscii8bit() {
            return (flags & ASCII_8BIT) != 0;
        }

        public boolean isWindows31j() {
            return (flags & WINDOWS_31J) != 0;
        }

        public boolean isUtf8() {
            return (flags & UTF_8) != 0;
        }

        public boolean isForcedUtf8Encoding() {
            return (flags & FORCED_UTF8_ENCODING) != 0;
        }

        public boolean isForcedBinaryEncoding() {
            return (flags & FORCED_BINARY_ENCODING) != 0;
        }

        public boolean isForcedUsAsciiEncoding() {
            return (flags & FORCED_US_ASCII_ENCODING) != 0;
        }

    }

    /**
     * Flags for shareable constant nodes.
     */
    public static final class ShareableConstantNodeFlags implements Comparable<ShareableConstantNodeFlags> {

        // constant writes that should be modified with shareable constant value literal
        public static final short LITERAL = 1 << 0;

        // constant writes that should be modified with shareable constant value experimental everything
        public static final short EXPERIMENTAL_EVERYTHING = 1 << 1;

        // constant writes that should be modified with shareable constant value experimental copy
        public static final short EXPERIMENTAL_COPY = 1 << 2;

        public static boolean isLiteral(short flags) {
            return (flags & LITERAL) != 0;
        }

        public static boolean isExperimentalEverything(short flags) {
            return (flags & EXPERIMENTAL_EVERYTHING) != 0;
        }

        public static boolean isExperimentalCopy(short flags) {
            return (flags & EXPERIMENTAL_COPY) != 0;
        }

        private final short flags;

        public ShareableConstantNodeFlags(short flags) {
            this.flags = flags;
        }

        @Override
        public int hashCode() {
            return flags;
        }

        @Override
        public boolean equals(Object other) {
            if (!(other instanceof ShareableConstantNodeFlags)) {
                return false;
            }

            return flags == ((ShareableConstantNodeFlags) other).flags;
        }

        @Override
        public int compareTo(ShareableConstantNodeFlags other) {
            return flags - other.flags;
        }

        public boolean isLiteral() {
            return (flags & LITERAL) != 0;
        }

        public boolean isExperimentalEverything() {
            return (flags & EXPERIMENTAL_EVERYTHING) != 0;
        }

        public boolean isExperimentalCopy() {
            return (flags & EXPERIMENTAL_COPY) != 0;
        }

    }

    /**
     * Flags for string nodes.
     */
    public static final class StringFlags implements Comparable<StringFlags> {

        // internal bytes forced the encoding to UTF-8
        public static final short FORCED_UTF8_ENCODING = 1 << 0;

        // internal bytes forced the encoding to binary
        public static final short FORCED_BINARY_ENCODING = 1 << 1;

        // frozen by virtue of a `frozen_string_literal: true` comment or `--enable-frozen-string-literal`
        public static final short FROZEN = 1 << 2;

        // mutable by virtue of a `frozen_string_literal: false` comment or `--disable-frozen-string-literal`
        public static final short MUTABLE = 1 << 3;

        public static boolean isForcedUtf8Encoding(short flags) {
            return (flags & FORCED_UTF8_ENCODING) != 0;
        }

        public static boolean isForcedBinaryEncoding(short flags) {
            return (flags & FORCED_BINARY_ENCODING) != 0;
        }

        public static boolean isFrozen(short flags) {
            return (flags & FROZEN) != 0;
        }

        public static boolean isMutable(short flags) {
            return (flags & MUTABLE) != 0;
        }

        private final short flags;

        public StringFlags(short flags) {
            this.flags = flags;
        }

        @Override
        public int hashCode() {
            return flags;
        }

        @Override
        public boolean equals(Object other) {
            if (!(other instanceof StringFlags)) {
                return false;
            }

            return flags == ((StringFlags) other).flags;
        }

        @Override
        public int compareTo(StringFlags other) {
            return flags - other.flags;
        }

        public boolean isForcedUtf8Encoding() {
            return (flags & FORCED_UTF8_ENCODING) != 0;
        }

        public boolean isForcedBinaryEncoding() {
            return (flags & FORCED_BINARY_ENCODING) != 0;
        }

        public boolean isFrozen() {
            return (flags & FROZEN) != 0;
        }

        public boolean isMutable() {
            return (flags & MUTABLE) != 0;
        }

    }

    /**
     * Flags for symbol nodes.
     */
    public static final class SymbolFlags implements Comparable<SymbolFlags> {

        // internal bytes forced the encoding to UTF-8
        public static final short FORCED_UTF8_ENCODING = 1 << 0;

        // internal bytes forced the encoding to binary
        public static final short FORCED_BINARY_ENCODING = 1 << 1;

        // internal bytes forced the encoding to US-ASCII
        public static final short FORCED_US_ASCII_ENCODING = 1 << 2;

        public static boolean isForcedUtf8Encoding(short flags) {
            return (flags & FORCED_UTF8_ENCODING) != 0;
        }

        public static boolean isForcedBinaryEncoding(short flags) {
            return (flags & FORCED_BINARY_ENCODING) != 0;
        }

        public static boolean isForcedUsAsciiEncoding(short flags) {
            return (flags & FORCED_US_ASCII_ENCODING) != 0;
        }

        private final short flags;

        public SymbolFlags(short flags) {
            this.flags = flags;
        }

        @Override
        public int hashCode() {
            return flags;
        }

        @Override
        public boolean equals(Object other) {
            if (!(other instanceof SymbolFlags)) {
                return false;
            }

            return flags == ((SymbolFlags) other).flags;
        }

        @Override
        public int compareTo(SymbolFlags other) {
            return flags - other.flags;
        }

        public boolean isForcedUtf8Encoding() {
            return (flags & FORCED_UTF8_ENCODING) != 0;
        }

        public boolean isForcedBinaryEncoding() {
            return (flags & FORCED_BINARY_ENCODING) != 0;
        }

        public boolean isForcedUsAsciiEncoding() {
            return (flags & FORCED_US_ASCII_ENCODING) != 0;
        }

    }

    /**
     * <pre>
     * Represents the use of the `alias` keyword to alias a global variable.
     *
     *     alias $foo $bar
     *     ^^^^^^^^^^^^^^^
     * </pre>
     */
    public static final class AliasGlobalVariableNode extends Node {
        /**
         * <pre>
         * Represents the new name of the global variable that can be used after aliasing.
         *
         *     alias $foo $bar
         *           ^^^^
         * </pre>
         */
        @UnionType({ GlobalVariableReadNode.class, BackReferenceReadNode.class, NumberedReferenceReadNode.class })
        public final Node new_name;
        /**
         * <pre>
         * Represents the old name of the global variable that can be used before aliasing.
         *
         *     alias $foo $bar
         *                ^^^^
         * </pre>
         */
        @UnionType({ GlobalVariableReadNode.class, BackReferenceReadNode.class, NumberedReferenceReadNode.class, SymbolNode.class, MissingNode.class })
        public final Node old_name;

        public AliasGlobalVariableNode(int startOffset, int length, Node new_name, Node old_name) {
            super(startOffset, length);
            this.new_name = new_name;
            this.old_name = old_name;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            this.new_name.accept(visitor);
            this.old_name.accept(visitor);
        }

        public Node[] childNodes() {
            return new Node[] { this.new_name, this.old_name };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitAliasGlobalVariableNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            builder.append(nextIndent);
            builder.append("new_name: ");
            builder.append(this.new_name.toString(nextIndent));
            builder.append(nextIndent);
            builder.append("old_name: ");
            builder.append(this.old_name.toString(nextIndent));
            return builder.toString();
        }
    }

    /**
     * <pre>
     * Represents the use of the `alias` keyword to alias a method.
     *
     *     alias foo bar
     *     ^^^^^^^^^^^^^
     * </pre>
     */
    public static final class AliasMethodNode extends Node {
        @UnionType({ SymbolNode.class, InterpolatedSymbolNode.class })
        public final Node new_name;
        @UnionType({ SymbolNode.class, InterpolatedSymbolNode.class, GlobalVariableReadNode.class, MissingNode.class })
        public final Node old_name;

        public AliasMethodNode(int startOffset, int length, Node new_name, Node old_name) {
            super(startOffset, length);
            this.new_name = new_name;
            this.old_name = old_name;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            this.new_name.accept(visitor);
            this.old_name.accept(visitor);
        }

        public Node[] childNodes() {
            return new Node[] { this.new_name, this.old_name };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitAliasMethodNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            builder.append(nextIndent);
            builder.append("new_name: ");
            builder.append(this.new_name.toString(nextIndent));
            builder.append(nextIndent);
            builder.append("old_name: ");
            builder.append(this.old_name.toString(nextIndent));
            return builder.toString();
        }
    }

    /**
     * <pre>
     * Represents an alternation pattern in pattern matching.
     *
     *     foo =&gt; bar | baz
     *            ^^^^^^^^^
     * </pre>
     */
    public static final class AlternationPatternNode extends Node {
        public final Node left;
        public final Node right;

        public AlternationPatternNode(int startOffset, int length, Node left, Node right) {
            super(startOffset, length);
            this.left = left;
            this.right = right;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            this.left.accept(visitor);
            this.right.accept(visitor);
        }

        public Node[] childNodes() {
            return new Node[] { this.left, this.right };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitAlternationPatternNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            builder.append(nextIndent);
            builder.append("left: ");
            builder.append(this.left.toString(nextIndent));
            builder.append(nextIndent);
            builder.append("right: ");
            builder.append(this.right.toString(nextIndent));
            return builder.toString();
        }
    }

    /**
     * <pre>
     * Represents the use of the `&amp;&amp;` operator or the `and` keyword.
     *
     *     left and right
     *     ^^^^^^^^^^^^^^
     * </pre>
     */
    public static final class AndNode extends Node {
        /**
         * <pre>
         * Represents the left side of the expression. It can be any [non-void expression](https://github.com/ruby/prism/blob/main/docs/parsing_rules.md#non-void-expression).
         *
         *     left and right
         *     ^^^^
         *
         *     1 &amp;&amp; 2
         *     ^
         * </pre>
         */
        public final Node left;
        /**
         * <pre>
         * Represents the right side of the expression. It can be any [non-void expression](https://github.com/ruby/prism/blob/main/docs/parsing_rules.md#non-void-expression).
         *
         *     left &amp;&amp; right
         *             ^^^^^
         *
         *     1 and 2
         *           ^
         * </pre>
         */
        public final Node right;

        public AndNode(int startOffset, int length, Node left, Node right) {
            super(startOffset, length);
            this.left = left;
            this.right = right;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            this.left.accept(visitor);
            this.right.accept(visitor);
        }

        public Node[] childNodes() {
            return new Node[] { this.left, this.right };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitAndNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            builder.append(nextIndent);
            builder.append("left: ");
            builder.append(this.left.toString(nextIndent));
            builder.append(nextIndent);
            builder.append("right: ");
            builder.append(this.right.toString(nextIndent));
            return builder.toString();
        }
    }

    /**
     * <pre>
     * Represents a set of arguments to a method or a keyword.
     *
     *     return foo, bar, baz
     *            ^^^^^^^^^^^^^
     * </pre>
     */
    public static final class ArgumentsNode extends Node {
        public final short flags;
        public final Node[] arguments;

        public ArgumentsNode(int startOffset, int length, short flags, Node[] arguments) {
            super(startOffset, length);
            this.flags = flags;
            this.arguments = arguments;
        }
        
        public boolean isContainsKeywords() {
            return ArgumentsNodeFlags.isContainsKeywords(flags);
        }

        public boolean isContainsKeywordSplat() {
            return ArgumentsNodeFlags.isContainsKeywordSplat(flags);
        }

        public boolean isContainsSplat() {
            return ArgumentsNodeFlags.isContainsSplat(flags);
        }
        
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            for (Nodes.Node child : this.arguments) {
                child.accept(visitor);
            }
        }

        public Node[] childNodes() {
            ArrayList<Node> childNodes = new ArrayList<>();
            childNodes.addAll(Arrays.asList(this.arguments));
            return childNodes.toArray(EMPTY_ARRAY);
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitArgumentsNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            String nextNextIndent = nextIndent + "  ";
            builder.append(nextIndent);
            builder.append("ArgumentsNodeFlags: ");
            builder.append(flags);
            builder.append('\n');
            builder.append(nextIndent);
            builder.append("arguments: ");
            builder.append('\n');
            for (Node child : this.arguments) {
                builder.append(nextNextIndent).append(child.toString(nextNextIndent));
            }
            return builder.toString();
        }
    }

    /**
     * <pre>
     * Represents an array literal. This can be a regular array using brackets or a special array using % like %w or %i.
     *
     *     [1, 2, 3]
     *     ^^^^^^^^^
     * </pre>
     */
    public static final class ArrayNode extends Node {
        public final short flags;
        /**
         * <pre>
         * Represent the list of zero or more [non-void expressions](https://github.com/ruby/prism/blob/main/docs/parsing_rules.md#non-void-expression) within the array.
         * </pre>
         */
        public final Node[] elements;

        public ArrayNode(int startOffset, int length, short flags, Node[] elements) {
            super(startOffset, length);
            this.flags = flags;
            this.elements = elements;
        }
        
        public boolean isContainsSplat() {
            return ArrayNodeFlags.isContainsSplat(flags);
        }
        
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            for (Nodes.Node child : this.elements) {
                child.accept(visitor);
            }
        }

        public Node[] childNodes() {
            ArrayList<Node> childNodes = new ArrayList<>();
            childNodes.addAll(Arrays.asList(this.elements));
            return childNodes.toArray(EMPTY_ARRAY);
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitArrayNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            String nextNextIndent = nextIndent + "  ";
            builder.append(nextIndent);
            builder.append("ArrayNodeFlags: ");
            builder.append(flags);
            builder.append('\n');
            builder.append(nextIndent);
            builder.append("elements: ");
            builder.append('\n');
            for (Node child : this.elements) {
                builder.append(nextNextIndent).append(child.toString(nextNextIndent));
            }
            return builder.toString();
        }
    }

    /**
     * <pre>
     * Represents an array pattern in pattern matching.
     *
     *     foo in 1, 2
     *     ^^^^^^^^^^^
     *
     *     foo in [1, 2]
     *     ^^^^^^^^^^^^^
     *
     *     foo in *1
     *     ^^^^^^^^^
     *
     *     foo in Bar[]
     *     ^^^^^^^^^^^^
     *
     *     foo in Bar[1, 2, 3]
     *     ^^^^^^^^^^^^^^^^^^^
     * </pre>
     */
    public static final class ArrayPatternNode extends Node {
        @Nullable
        public final Node constant;
        public final Node[] requireds;
        @Nullable
        public final Node rest;
        public final Node[] posts;

        public ArrayPatternNode(int startOffset, int length, Node constant, Node[] requireds, Node rest, Node[] posts) {
            super(startOffset, length);
            this.constant = constant;
            this.requireds = requireds;
            this.rest = rest;
            this.posts = posts;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            if (this.constant != null) {
                this.constant.accept(visitor);
            }
            for (Nodes.Node child : this.requireds) {
                child.accept(visitor);
            }
            if (this.rest != null) {
                this.rest.accept(visitor);
            }
            for (Nodes.Node child : this.posts) {
                child.accept(visitor);
            }
        }

        public Node[] childNodes() {
            ArrayList<Node> childNodes = new ArrayList<>();
            childNodes.add(this.constant);
            childNodes.addAll(Arrays.asList(this.requireds));
            childNodes.add(this.rest);
            childNodes.addAll(Arrays.asList(this.posts));
            return childNodes.toArray(EMPTY_ARRAY);
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitArrayPatternNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            String nextNextIndent = nextIndent + "  ";
            builder.append(nextIndent);
            builder.append("constant: ");
            builder.append(this.constant == null ? "null\n" : this.constant.toString(nextIndent));
            builder.append(nextIndent);
            builder.append("requireds: ");
            builder.append('\n');
            for (Node child : this.requireds) {
                builder.append(nextNextIndent).append(child.toString(nextNextIndent));
            }
            builder.append(nextIndent);
            builder.append("rest: ");
            builder.append(this.rest == null ? "null\n" : this.rest.toString(nextIndent));
            builder.append(nextIndent);
            builder.append("posts: ");
            builder.append('\n');
            for (Node child : this.posts) {
                builder.append(nextNextIndent).append(child.toString(nextNextIndent));
            }
            return builder.toString();
        }
    }

    /**
     * <pre>
     * Represents a hash key/value pair.
     *
     *     { a =&gt; b }
     *       ^^^^^^
     * </pre>
     */
    public static final class AssocNode extends Node {
        /**
         * <pre>
         * The key of the association. This can be any [non-void expression](https://github.com/ruby/prism/blob/main/docs/parsing_rules.md#non-void-expression).
         *
         *     { a: b }
         *       ^
         *
         *     { foo =&gt; bar }
         *       ^^^
         *
         *     { def a; end =&gt; 1 }
         *       ^^^^^^^^^^
         * </pre>
         */
        public final Node key;
        /**
         * <pre>
         * The value of the association, if present. This can be any [non-void expression](https://github.com/ruby/prism/blob/main/docs/parsing_rules.md#non-void-expression).
         *
         *     { foo =&gt; bar }
         *              ^^^
         *
         *     { x: 1 }
         *          ^
         * </pre>
         */
        public final Node value;

        public AssocNode(int startOffset, int length, Node key, Node value) {
            super(startOffset, length);
            this.key = key;
            this.value = value;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            this.key.accept(visitor);
            this.value.accept(visitor);
        }

        public Node[] childNodes() {
            return new Node[] { this.key, this.value };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitAssocNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            builder.append(nextIndent);
            builder.append("key: ");
            builder.append(this.key.toString(nextIndent));
            builder.append(nextIndent);
            builder.append("value: ");
            builder.append(this.value.toString(nextIndent));
            return builder.toString();
        }
    }

    /**
     * <pre>
     * Represents a splat in a hash literal.
     *
     *     { **foo }
     *       ^^^^^
     * </pre>
     */
    public static final class AssocSplatNode extends Node {
        /**
         * <pre>
         * The value to be splatted, if present. Will be missing when keyword rest argument forwarding is used.
         *
         *     { **foo }
         *         ^^^
         * </pre>
         */
        @Nullable
        public final Node value;

        public AssocSplatNode(int startOffset, int length, Node value) {
            super(startOffset, length);
            this.value = value;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            if (this.value != null) {
                this.value.accept(visitor);
            }
        }

        public Node[] childNodes() {
            return new Node[] { this.value };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitAssocSplatNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            builder.append(nextIndent);
            builder.append("value: ");
            builder.append(this.value == null ? "null\n" : this.value.toString(nextIndent));
            return builder.toString();
        }
    }

    /**
     * <pre>
     * Represents reading a reference to a field in the previous match.
     *
     *     $&#39;
     *     ^^
     * </pre>
     */
    public static final class BackReferenceReadNode extends Node {
        /**
         * <pre>
         * The name of the back-reference variable, including the leading `$`.
         *
         *     $&amp; # name `:$&amp;`
         *
         *     $+ # name `:$+`
         * </pre>
         */
        public final String name;

        public BackReferenceReadNode(int startOffset, int length, String name) {
            super(startOffset, length);
            this.name = name;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
        }

        public Node[] childNodes() {
            return EMPTY_ARRAY;
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitBackReferenceReadNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            builder.append(nextIndent);
            builder.append("name: ");
            builder.append('"').append(this.name).append('"');
            builder.append('\n');
            return builder.toString();
        }
    }

    /**
     * <pre>
     * Represents a begin statement.
     *
     *     begin
     *       foo
     *     end
     *     ^^^^^
     * </pre>
     */
    public static final class BeginNode extends Node {
        @Nullable
        public final StatementsNode statements;
        @Nullable
        public final RescueNode rescue_clause;
        @Nullable
        public final ElseNode else_clause;
        @Nullable
        public final EnsureNode ensure_clause;

        public BeginNode(int startOffset, int length, StatementsNode statements, RescueNode rescue_clause, ElseNode else_clause, EnsureNode ensure_clause) {
            super(startOffset, length);
            this.statements = statements;
            this.rescue_clause = rescue_clause;
            this.else_clause = else_clause;
            this.ensure_clause = ensure_clause;
        }
                
        @Override
        public void setNewLineFlag(Source source, boolean[] newlineMarked) {
            // Never mark BeginNode with a newline flag, mark children instead
        }

        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            if (this.statements != null) {
                this.statements.accept(visitor);
            }
            if (this.rescue_clause != null) {
                this.rescue_clause.accept(visitor);
            }
            if (this.else_clause != null) {
                this.else_clause.accept(visitor);
            }
            if (this.ensure_clause != null) {
                this.ensure_clause.accept(visitor);
            }
        }

        public Node[] childNodes() {
            return new Node[] { this.statements, this.rescue_clause, this.else_clause, this.ensure_clause };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitBeginNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            builder.append(nextIndent);
            builder.append("statements: ");
            builder.append(this.statements == null ? "null\n" : this.statements.toString(nextIndent));
            builder.append(nextIndent);
            builder.append("rescue_clause: ");
            builder.append(this.rescue_clause == null ? "null\n" : this.rescue_clause.toString(nextIndent));
            builder.append(nextIndent);
            builder.append("else_clause: ");
            builder.append(this.else_clause == null ? "null\n" : this.else_clause.toString(nextIndent));
            builder.append(nextIndent);
            builder.append("ensure_clause: ");
            builder.append(this.ensure_clause == null ? "null\n" : this.ensure_clause.toString(nextIndent));
            return builder.toString();
        }
    }

    /**
     * <pre>
     * Represents a block argument using `&amp;`.
     *
     *     bar(&amp;args)
     *     ^^^^^^^^^^
     * </pre>
     */
    public static final class BlockArgumentNode extends Node {
        @Nullable
        public final Node expression;

        public BlockArgumentNode(int startOffset, int length, Node expression) {
            super(startOffset, length);
            this.expression = expression;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            if (this.expression != null) {
                this.expression.accept(visitor);
            }
        }

        public Node[] childNodes() {
            return new Node[] { this.expression };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitBlockArgumentNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            builder.append(nextIndent);
            builder.append("expression: ");
            builder.append(this.expression == null ? "null\n" : this.expression.toString(nextIndent));
            return builder.toString();
        }
    }

    /**
     * <pre>
     * Represents a block local variable.
     *
     *     a { |; b| }
     *            ^
     * </pre>
     */
    public static final class BlockLocalVariableNode extends Node {
        public final short flags;
        public final String name;

        public BlockLocalVariableNode(int startOffset, int length, short flags, String name) {
            super(startOffset, length);
            this.flags = flags;
            this.name = name;
        }
        
        public boolean isRepeatedParameter() {
            return ParameterFlags.isRepeatedParameter(flags);
        }
        
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
        }

        public Node[] childNodes() {
            return EMPTY_ARRAY;
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitBlockLocalVariableNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            builder.append(nextIndent);
            builder.append("ParameterFlags: ");
            builder.append(flags);
            builder.append('\n');
            builder.append(nextIndent);
            builder.append("name: ");
            builder.append('"').append(this.name).append('"');
            builder.append('\n');
            return builder.toString();
        }
    }

    /**
     * <pre>
     * Represents a block of ruby code.
     *
     *     [1, 2, 3].each { |i| puts x }
     *                    ^^^^^^^^^^^^^^
     * </pre>
     */
    public static final class BlockNode extends Node {
        public final String[] locals;
        @Nullable
        @UnionType({ BlockParametersNode.class, NumberedParametersNode.class, ItParametersNode.class })
        public final Node parameters;
        @Nullable
        @UnionType({ StatementsNode.class, BeginNode.class })
        public final Node body;

        public BlockNode(int startOffset, int length, String[] locals, Node parameters, Node body) {
            super(startOffset, length);
            this.locals = locals;
            this.parameters = parameters;
            this.body = body;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            if (this.parameters != null) {
                this.parameters.accept(visitor);
            }
            if (this.body != null) {
                this.body.accept(visitor);
            }
        }

        public Node[] childNodes() {
            return new Node[] { this.parameters, this.body };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitBlockNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            String nextNextIndent = nextIndent + "  ";
            builder.append(nextIndent);
            builder.append("locals: ");
            builder.append('\n');
            for (String constant : this.locals) {
                builder.append(nextNextIndent).append('"').append(constant).append('"').append('\n');
            }
            builder.append(nextIndent);
            builder.append("parameters: ");
            builder.append(this.parameters == null ? "null\n" : this.parameters.toString(nextIndent));
            builder.append(nextIndent);
            builder.append("body: ");
            builder.append(this.body == null ? "null\n" : this.body.toString(nextIndent));
            return builder.toString();
        }
    }

    /**
     * <pre>
     * Represents a block parameter of a method, block, or lambda definition.
     *
     *     def a(&amp;b)
     *           ^^
     *     end
     * </pre>
     */
    public static final class BlockParameterNode extends Node {
        public final short flags;
        @Nullable
        public final String name;

        public BlockParameterNode(int startOffset, int length, short flags, String name) {
            super(startOffset, length);
            this.flags = flags;
            this.name = name;
        }
        
        public boolean isRepeatedParameter() {
            return ParameterFlags.isRepeatedParameter(flags);
        }
        
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
        }

        public Node[] childNodes() {
            return EMPTY_ARRAY;
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitBlockParameterNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            builder.append(nextIndent);
            builder.append("ParameterFlags: ");
            builder.append(flags);
            builder.append('\n');
            builder.append(nextIndent);
            builder.append("name: ");
            builder.append(this.name == null ? "null" : "\"" + this.name + "\"");
            builder.append('\n');
            return builder.toString();
        }
    }

    /**
     * <pre>
     * Represents a block&#39;s parameters declaration.
     *
     *     -&gt; (a, b = 1; local) { }
     *        ^^^^^^^^^^^^^^^^^
     *
     *     foo do |a, b = 1; local|
     *            ^^^^^^^^^^^^^^^^^
     *     end
     * </pre>
     */
    public static final class BlockParametersNode extends Node {
        @Nullable
        public final ParametersNode parameters;
        public final BlockLocalVariableNode[] locals;

        public BlockParametersNode(int startOffset, int length, ParametersNode parameters, BlockLocalVariableNode[] locals) {
            super(startOffset, length);
            this.parameters = parameters;
            this.locals = locals;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            if (this.parameters != null) {
                this.parameters.accept(visitor);
            }
            for (Nodes.Node child : this.locals) {
                child.accept(visitor);
            }
        }

        public Node[] childNodes() {
            ArrayList<Node> childNodes = new ArrayList<>();
            childNodes.add(this.parameters);
            childNodes.addAll(Arrays.asList(this.locals));
            return childNodes.toArray(EMPTY_ARRAY);
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitBlockParametersNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            String nextNextIndent = nextIndent + "  ";
            builder.append(nextIndent);
            builder.append("parameters: ");
            builder.append(this.parameters == null ? "null\n" : this.parameters.toString(nextIndent));
            builder.append(nextIndent);
            builder.append("locals: ");
            builder.append('\n');
            for (Node child : this.locals) {
                builder.append(nextNextIndent).append(child.toString(nextNextIndent));
            }
            return builder.toString();
        }
    }

    /**
     * <pre>
     * Represents the use of the `break` keyword.
     *
     *     break foo
     *     ^^^^^^^^^
     * </pre>
     */
    public static final class BreakNode extends Node {
        /**
         * <pre>
         * The arguments to the break statement, if present. These can be any [non-void expressions](https://github.com/ruby/prism/blob/main/docs/parsing_rules.md#non-void-expression).
         *
         *     break foo
         *           ^^^
         * </pre>
         */
        @Nullable
        public final ArgumentsNode arguments;

        public BreakNode(int startOffset, int length, ArgumentsNode arguments) {
            super(startOffset, length);
            this.arguments = arguments;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            if (this.arguments != null) {
                this.arguments.accept(visitor);
            }
        }

        public Node[] childNodes() {
            return new Node[] { this.arguments };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitBreakNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            builder.append(nextIndent);
            builder.append("arguments: ");
            builder.append(this.arguments == null ? "null\n" : this.arguments.toString(nextIndent));
            return builder.toString();
        }
    }

    /**
     * <pre>
     * Represents the use of the `&amp;&amp;=` operator on a call.
     *
     *     foo.bar &amp;&amp;= value
     *     ^^^^^^^^^^^^^^^^^
     * </pre>
     */
    public static final class CallAndWriteNode extends Node {
        public final short flags;
        @Nullable
        public final Node receiver;
        public final String read_name;
        public final String write_name;
        public final Node value;

        public CallAndWriteNode(int startOffset, int length, short flags, Node receiver, String read_name, String write_name, Node value) {
            super(startOffset, length);
            this.flags = flags;
            this.receiver = receiver;
            this.read_name = read_name;
            this.write_name = write_name;
            this.value = value;
        }
        
        public boolean isSafeNavigation() {
            return CallNodeFlags.isSafeNavigation(flags);
        }

        public boolean isVariableCall() {
            return CallNodeFlags.isVariableCall(flags);
        }

        public boolean isAttributeWrite() {
            return CallNodeFlags.isAttributeWrite(flags);
        }

        public boolean isIgnoreVisibility() {
            return CallNodeFlags.isIgnoreVisibility(flags);
        }
        
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            if (this.receiver != null) {
                this.receiver.accept(visitor);
            }
            this.value.accept(visitor);
        }

        public Node[] childNodes() {
            return new Node[] { this.receiver, this.value };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitCallAndWriteNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            builder.append(nextIndent);
            builder.append("CallNodeFlags: ");
            builder.append(flags);
            builder.append('\n');
            builder.append(nextIndent);
            builder.append("receiver: ");
            builder.append(this.receiver == null ? "null\n" : this.receiver.toString(nextIndent));
            builder.append(nextIndent);
            builder.append("read_name: ");
            builder.append('"').append(this.read_name).append('"');
            builder.append('\n');
            builder.append(nextIndent);
            builder.append("write_name: ");
            builder.append('"').append(this.write_name).append('"');
            builder.append('\n');
            builder.append(nextIndent);
            builder.append("value: ");
            builder.append(this.value.toString(nextIndent));
            return builder.toString();
        }
    }

    /**
     * <pre>
     * Represents a method call, in all of the various forms that can take.
     *
     *     foo
     *     ^^^
     *
     *     foo()
     *     ^^^^^
     *
     *     +foo
     *     ^^^^
     *
     *     foo + bar
     *     ^^^^^^^^^
     *
     *     foo.bar
     *     ^^^^^^^
     *
     *     foo&amp;.bar
     *     ^^^^^^^^
     * </pre>
     */
    public static final class CallNode extends Node {
        public final short flags;
        /**
         * <pre>
         * The object that the method is being called on. This can be either `nil` or any [non-void expression](https://github.com/ruby/prism/blob/main/docs/parsing_rules.md#non-void-expression).
         *
         *     foo.bar
         *     ^^^
         *
         *     +foo
         *      ^^^
         *
         *     foo + bar
         *     ^^^
         * </pre>
         */
        @Nullable
        public final Node receiver;
        public final String name;
        @Nullable
        public final ArgumentsNode arguments;
        @Nullable
        public final Node block;

        public CallNode(int startOffset, int length, short flags, Node receiver, String name, ArgumentsNode arguments, Node block) {
            super(startOffset, length);
            this.flags = flags;
            this.receiver = receiver;
            this.name = name;
            this.arguments = arguments;
            this.block = block;
        }
        
        public boolean isSafeNavigation() {
            return CallNodeFlags.isSafeNavigation(flags);
        }

        public boolean isVariableCall() {
            return CallNodeFlags.isVariableCall(flags);
        }

        public boolean isAttributeWrite() {
            return CallNodeFlags.isAttributeWrite(flags);
        }

        public boolean isIgnoreVisibility() {
            return CallNodeFlags.isIgnoreVisibility(flags);
        }
        
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            if (this.receiver != null) {
                this.receiver.accept(visitor);
            }
            if (this.arguments != null) {
                this.arguments.accept(visitor);
            }
            if (this.block != null) {
                this.block.accept(visitor);
            }
        }

        public Node[] childNodes() {
            return new Node[] { this.receiver, this.arguments, this.block };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitCallNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            builder.append(nextIndent);
            builder.append("CallNodeFlags: ");
            builder.append(flags);
            builder.append('\n');
            builder.append(nextIndent);
            builder.append("receiver: ");
            builder.append(this.receiver == null ? "null\n" : this.receiver.toString(nextIndent));
            builder.append(nextIndent);
            builder.append("name: ");
            builder.append('"').append(this.name).append('"');
            builder.append('\n');
            builder.append(nextIndent);
            builder.append("arguments: ");
            builder.append(this.arguments == null ? "null\n" : this.arguments.toString(nextIndent));
            builder.append(nextIndent);
            builder.append("block: ");
            builder.append(this.block == null ? "null\n" : this.block.toString(nextIndent));
            return builder.toString();
        }
    }

    /**
     * <pre>
     * Represents the use of an assignment operator on a call.
     *
     *     foo.bar += baz
     *     ^^^^^^^^^^^^^^
     * </pre>
     */
    public static final class CallOperatorWriteNode extends Node {
        public final short flags;
        @Nullable
        public final Node receiver;
        public final String read_name;
        public final String write_name;
        public final String binary_operator;
        public final Node value;

        public CallOperatorWriteNode(int startOffset, int length, short flags, Node receiver, String read_name, String write_name, String binary_operator, Node value) {
            super(startOffset, length);
            this.flags = flags;
            this.receiver = receiver;
            this.read_name = read_name;
            this.write_name = write_name;
            this.binary_operator = binary_operator;
            this.value = value;
        }
        
        public boolean isSafeNavigation() {
            return CallNodeFlags.isSafeNavigation(flags);
        }

        public boolean isVariableCall() {
            return CallNodeFlags.isVariableCall(flags);
        }

        public boolean isAttributeWrite() {
            return CallNodeFlags.isAttributeWrite(flags);
        }

        public boolean isIgnoreVisibility() {
            return CallNodeFlags.isIgnoreVisibility(flags);
        }
        
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            if (this.receiver != null) {
                this.receiver.accept(visitor);
            }
            this.value.accept(visitor);
        }

        public Node[] childNodes() {
            return new Node[] { this.receiver, this.value };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitCallOperatorWriteNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            builder.append(nextIndent);
            builder.append("CallNodeFlags: ");
            builder.append(flags);
            builder.append('\n');
            builder.append(nextIndent);
            builder.append("receiver: ");
            builder.append(this.receiver == null ? "null\n" : this.receiver.toString(nextIndent));
            builder.append(nextIndent);
            builder.append("read_name: ");
            builder.append('"').append(this.read_name).append('"');
            builder.append('\n');
            builder.append(nextIndent);
            builder.append("write_name: ");
            builder.append('"').append(this.write_name).append('"');
            builder.append('\n');
            builder.append(nextIndent);
            builder.append("binary_operator: ");
            builder.append('"').append(this.binary_operator).append('"');
            builder.append('\n');
            builder.append(nextIndent);
            builder.append("value: ");
            builder.append(this.value.toString(nextIndent));
            return builder.toString();
        }
    }

    /**
     * <pre>
     * Represents the use of the `||=` operator on a call.
     *
     *     foo.bar ||= value
     *     ^^^^^^^^^^^^^^^^^
     * </pre>
     */
    public static final class CallOrWriteNode extends Node {
        public final short flags;
        @Nullable
        public final Node receiver;
        public final String read_name;
        public final String write_name;
        public final Node value;

        public CallOrWriteNode(int startOffset, int length, short flags, Node receiver, String read_name, String write_name, Node value) {
            super(startOffset, length);
            this.flags = flags;
            this.receiver = receiver;
            this.read_name = read_name;
            this.write_name = write_name;
            this.value = value;
        }
        
        public boolean isSafeNavigation() {
            return CallNodeFlags.isSafeNavigation(flags);
        }

        public boolean isVariableCall() {
            return CallNodeFlags.isVariableCall(flags);
        }

        public boolean isAttributeWrite() {
            return CallNodeFlags.isAttributeWrite(flags);
        }

        public boolean isIgnoreVisibility() {
            return CallNodeFlags.isIgnoreVisibility(flags);
        }
        
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            if (this.receiver != null) {
                this.receiver.accept(visitor);
            }
            this.value.accept(visitor);
        }

        public Node[] childNodes() {
            return new Node[] { this.receiver, this.value };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitCallOrWriteNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            builder.append(nextIndent);
            builder.append("CallNodeFlags: ");
            builder.append(flags);
            builder.append('\n');
            builder.append(nextIndent);
            builder.append("receiver: ");
            builder.append(this.receiver == null ? "null\n" : this.receiver.toString(nextIndent));
            builder.append(nextIndent);
            builder.append("read_name: ");
            builder.append('"').append(this.read_name).append('"');
            builder.append('\n');
            builder.append(nextIndent);
            builder.append("write_name: ");
            builder.append('"').append(this.write_name).append('"');
            builder.append('\n');
            builder.append(nextIndent);
            builder.append("value: ");
            builder.append(this.value.toString(nextIndent));
            return builder.toString();
        }
    }

    /**
     * <pre>
     * Represents assigning to a method call.
     *
     *     foo.bar, = 1
     *     ^^^^^^^
     *
     *     begin
     *     rescue =&gt; foo.bar
     *               ^^^^^^^
     *     end
     *
     *     for foo.bar in baz do end
     *         ^^^^^^^
     * </pre>
     */
    public static final class CallTargetNode extends Node {
        public final short flags;
        public final Node receiver;
        public final String name;

        public CallTargetNode(int startOffset, int length, short flags, Node receiver, String name) {
            super(startOffset, length);
            this.flags = flags;
            this.receiver = receiver;
            this.name = name;
        }
        
        public boolean isSafeNavigation() {
            return CallNodeFlags.isSafeNavigation(flags);
        }

        public boolean isVariableCall() {
            return CallNodeFlags.isVariableCall(flags);
        }

        public boolean isAttributeWrite() {
            return CallNodeFlags.isAttributeWrite(flags);
        }

        public boolean isIgnoreVisibility() {
            return CallNodeFlags.isIgnoreVisibility(flags);
        }
        
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            this.receiver.accept(visitor);
        }

        public Node[] childNodes() {
            return new Node[] { this.receiver };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitCallTargetNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            builder.append(nextIndent);
            builder.append("CallNodeFlags: ");
            builder.append(flags);
            builder.append('\n');
            builder.append(nextIndent);
            builder.append("receiver: ");
            builder.append(this.receiver.toString(nextIndent));
            builder.append(nextIndent);
            builder.append("name: ");
            builder.append('"').append(this.name).append('"');
            builder.append('\n');
            return builder.toString();
        }
    }

    /**
     * <pre>
     * Represents assigning to a local variable in pattern matching.
     *
     *     foo =&gt; [bar =&gt; baz]
     *            ^^^^^^^^^^^^
     * </pre>
     */
    public static final class CapturePatternNode extends Node {
        public final Node value;
        public final Node target;

        public CapturePatternNode(int startOffset, int length, Node value, Node target) {
            super(startOffset, length);
            this.value = value;
            this.target = target;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            this.value.accept(visitor);
            this.target.accept(visitor);
        }

        public Node[] childNodes() {
            return new Node[] { this.value, this.target };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitCapturePatternNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            builder.append(nextIndent);
            builder.append("value: ");
            builder.append(this.value.toString(nextIndent));
            builder.append(nextIndent);
            builder.append("target: ");
            builder.append(this.target.toString(nextIndent));
            return builder.toString();
        }
    }

    /**
     * <pre>
     * Represents the use of a case statement for pattern matching.
     *
     *     case true
     *     in false
     *     end
     *     ^^^^^^^^^
     * </pre>
     */
    public static final class CaseMatchNode extends Node {
        @Nullable
        public final Node predicate;
        public final Node[] conditions;
        @Nullable
        public final ElseNode else_clause;

        public CaseMatchNode(int startOffset, int length, Node predicate, Node[] conditions, ElseNode else_clause) {
            super(startOffset, length);
            this.predicate = predicate;
            this.conditions = conditions;
            this.else_clause = else_clause;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            if (this.predicate != null) {
                this.predicate.accept(visitor);
            }
            for (Nodes.Node child : this.conditions) {
                child.accept(visitor);
            }
            if (this.else_clause != null) {
                this.else_clause.accept(visitor);
            }
        }

        public Node[] childNodes() {
            ArrayList<Node> childNodes = new ArrayList<>();
            childNodes.add(this.predicate);
            childNodes.addAll(Arrays.asList(this.conditions));
            childNodes.add(this.else_clause);
            return childNodes.toArray(EMPTY_ARRAY);
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitCaseMatchNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            String nextNextIndent = nextIndent + "  ";
            builder.append(nextIndent);
            builder.append("predicate: ");
            builder.append(this.predicate == null ? "null\n" : this.predicate.toString(nextIndent));
            builder.append(nextIndent);
            builder.append("conditions: ");
            builder.append('\n');
            for (Node child : this.conditions) {
                builder.append(nextNextIndent).append(child.toString(nextNextIndent));
            }
            builder.append(nextIndent);
            builder.append("else_clause: ");
            builder.append(this.else_clause == null ? "null\n" : this.else_clause.toString(nextIndent));
            return builder.toString();
        }
    }

    /**
     * <pre>
     * Represents the use of a case statement.
     *
     *     case true
     *     when false
     *     end
     *     ^^^^^^^^^^
     * </pre>
     */
    public static final class CaseNode extends Node {
        @Nullable
        public final Node predicate;
        public final Node[] conditions;
        @Nullable
        public final ElseNode else_clause;

        public CaseNode(int startOffset, int length, Node predicate, Node[] conditions, ElseNode else_clause) {
            super(startOffset, length);
            this.predicate = predicate;
            this.conditions = conditions;
            this.else_clause = else_clause;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            if (this.predicate != null) {
                this.predicate.accept(visitor);
            }
            for (Nodes.Node child : this.conditions) {
                child.accept(visitor);
            }
            if (this.else_clause != null) {
                this.else_clause.accept(visitor);
            }
        }

        public Node[] childNodes() {
            ArrayList<Node> childNodes = new ArrayList<>();
            childNodes.add(this.predicate);
            childNodes.addAll(Arrays.asList(this.conditions));
            childNodes.add(this.else_clause);
            return childNodes.toArray(EMPTY_ARRAY);
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitCaseNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            String nextNextIndent = nextIndent + "  ";
            builder.append(nextIndent);
            builder.append("predicate: ");
            builder.append(this.predicate == null ? "null\n" : this.predicate.toString(nextIndent));
            builder.append(nextIndent);
            builder.append("conditions: ");
            builder.append('\n');
            for (Node child : this.conditions) {
                builder.append(nextNextIndent).append(child.toString(nextNextIndent));
            }
            builder.append(nextIndent);
            builder.append("else_clause: ");
            builder.append(this.else_clause == null ? "null\n" : this.else_clause.toString(nextIndent));
            return builder.toString();
        }
    }

    /**
     * <pre>
     * Represents a class declaration involving the `class` keyword.
     *
     *     class Foo end
     *     ^^^^^^^^^^^^^
     * </pre>
     */
    public static final class ClassNode extends Node {
        public final String[] locals;
        public final Node constant_path;
        @Nullable
        public final Node superclass;
        @Nullable
        public final Node body;
        public final String name;

        public ClassNode(int startOffset, int length, String[] locals, Node constant_path, Node superclass, Node body, String name) {
            super(startOffset, length);
            this.locals = locals;
            this.constant_path = constant_path;
            this.superclass = superclass;
            this.body = body;
            this.name = name;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            this.constant_path.accept(visitor);
            if (this.superclass != null) {
                this.superclass.accept(visitor);
            }
            if (this.body != null) {
                this.body.accept(visitor);
            }
        }

        public Node[] childNodes() {
            return new Node[] { this.constant_path, this.superclass, this.body };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitClassNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            String nextNextIndent = nextIndent + "  ";
            builder.append(nextIndent);
            builder.append("locals: ");
            builder.append('\n');
            for (String constant : this.locals) {
                builder.append(nextNextIndent).append('"').append(constant).append('"').append('\n');
            }
            builder.append(nextIndent);
            builder.append("constant_path: ");
            builder.append(this.constant_path.toString(nextIndent));
            builder.append(nextIndent);
            builder.append("superclass: ");
            builder.append(this.superclass == null ? "null\n" : this.superclass.toString(nextIndent));
            builder.append(nextIndent);
            builder.append("body: ");
            builder.append(this.body == null ? "null\n" : this.body.toString(nextIndent));
            builder.append(nextIndent);
            builder.append("name: ");
            builder.append('"').append(this.name).append('"');
            builder.append('\n');
            return builder.toString();
        }
    }

    /**
     * <pre>
     * Represents the use of the `&amp;&amp;=` operator for assignment to a class variable.
     *
     *     &#64;&#64;target &amp;&amp;= value
     *     ^^^^^^^^^^^^^^^^^^
     * </pre>
     */
    public static final class ClassVariableAndWriteNode extends Node {
        public final String name;
        public final Node value;

        public ClassVariableAndWriteNode(int startOffset, int length, String name, Node value) {
            super(startOffset, length);
            this.name = name;
            this.value = value;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            this.value.accept(visitor);
        }

        public Node[] childNodes() {
            return new Node[] { this.value };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitClassVariableAndWriteNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            builder.append(nextIndent);
            builder.append("name: ");
            builder.append('"').append(this.name).append('"');
            builder.append('\n');
            builder.append(nextIndent);
            builder.append("value: ");
            builder.append(this.value.toString(nextIndent));
            return builder.toString();
        }
    }

    /**
     * <pre>
     * Represents assigning to a class variable using an operator that isn&#39;t `=`.
     *
     *     &#64;&#64;target += value
     *     ^^^^^^^^^^^^^^^^^
     * </pre>
     */
    public static final class ClassVariableOperatorWriteNode extends Node {
        public final String name;
        public final Node value;
        public final String binary_operator;

        public ClassVariableOperatorWriteNode(int startOffset, int length, String name, Node value, String binary_operator) {
            super(startOffset, length);
            this.name = name;
            this.value = value;
            this.binary_operator = binary_operator;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            this.value.accept(visitor);
        }

        public Node[] childNodes() {
            return new Node[] { this.value };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitClassVariableOperatorWriteNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            builder.append(nextIndent);
            builder.append("name: ");
            builder.append('"').append(this.name).append('"');
            builder.append('\n');
            builder.append(nextIndent);
            builder.append("value: ");
            builder.append(this.value.toString(nextIndent));
            builder.append(nextIndent);
            builder.append("binary_operator: ");
            builder.append('"').append(this.binary_operator).append('"');
            builder.append('\n');
            return builder.toString();
        }
    }

    /**
     * <pre>
     * Represents the use of the `||=` operator for assignment to a class variable.
     *
     *     &#64;&#64;target ||= value
     *     ^^^^^^^^^^^^^^^^^^
     * </pre>
     */
    public static final class ClassVariableOrWriteNode extends Node {
        public final String name;
        public final Node value;

        public ClassVariableOrWriteNode(int startOffset, int length, String name, Node value) {
            super(startOffset, length);
            this.name = name;
            this.value = value;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            this.value.accept(visitor);
        }

        public Node[] childNodes() {
            return new Node[] { this.value };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitClassVariableOrWriteNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            builder.append(nextIndent);
            builder.append("name: ");
            builder.append('"').append(this.name).append('"');
            builder.append('\n');
            builder.append(nextIndent);
            builder.append("value: ");
            builder.append(this.value.toString(nextIndent));
            return builder.toString();
        }
    }

    /**
     * <pre>
     * Represents referencing a class variable.
     *
     *     &#64;&#64;foo
     *     ^^^^^
     * </pre>
     */
    public static final class ClassVariableReadNode extends Node {
        /**
         * <pre>
         * The name of the class variable, which is a `&#64;&#64;` followed by an [identifier](https://github.com/ruby/prism/blob/main/docs/parsing_rules.md#identifiers).
         *
         *     &#64;&#64;abc   # name `:&#64;&#64;abc`
         *
         *     &#64;&#64;_test # name `:&#64;&#64;_test`
         * </pre>
         */
        public final String name;

        public ClassVariableReadNode(int startOffset, int length, String name) {
            super(startOffset, length);
            this.name = name;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
        }

        public Node[] childNodes() {
            return EMPTY_ARRAY;
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitClassVariableReadNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            builder.append(nextIndent);
            builder.append("name: ");
            builder.append('"').append(this.name).append('"');
            builder.append('\n');
            return builder.toString();
        }
    }

    /**
     * <pre>
     * Represents writing to a class variable in a context that doesn&#39;t have an explicit value.
     *
     *     &#64;&#64;foo, &#64;&#64;bar = baz
     *     ^^^^^  ^^^^^
     * </pre>
     */
    public static final class ClassVariableTargetNode extends Node {
        public final String name;

        public ClassVariableTargetNode(int startOffset, int length, String name) {
            super(startOffset, length);
            this.name = name;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
        }

        public Node[] childNodes() {
            return EMPTY_ARRAY;
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitClassVariableTargetNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            builder.append(nextIndent);
            builder.append("name: ");
            builder.append('"').append(this.name).append('"');
            builder.append('\n');
            return builder.toString();
        }
    }

    /**
     * <pre>
     * Represents writing to a class variable.
     *
     *     &#64;&#64;foo = 1
     *     ^^^^^^^^^
     * </pre>
     */
    public static final class ClassVariableWriteNode extends Node {
        /**
         * <pre>
         * The name of the class variable, which is a `&#64;&#64;` followed by an [identifier](https://github.com/ruby/prism/blob/main/docs/parsing_rules.md#identifiers).
         *
         *     &#64;&#64;abc = 123     # name `&#64;&#64;abc`
         *
         *     &#64;&#64;_test = :test # name `&#64;&#64;_test`
         * </pre>
         */
        public final String name;
        /**
         * <pre>
         * The value to write to the class variable. This can be any [non-void expression](https://github.com/ruby/prism/blob/main/docs/parsing_rules.md#non-void-expression).
         *
         *     &#64;&#64;foo = :bar
         *             ^^^^
         *
         *     &#64;&#64;_xyz = 123
         *              ^^^
         * </pre>
         */
        public final Node value;

        public ClassVariableWriteNode(int startOffset, int length, String name, Node value) {
            super(startOffset, length);
            this.name = name;
            this.value = value;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            this.value.accept(visitor);
        }

        public Node[] childNodes() {
            return new Node[] { this.value };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitClassVariableWriteNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            builder.append(nextIndent);
            builder.append("name: ");
            builder.append('"').append(this.name).append('"');
            builder.append('\n');
            builder.append(nextIndent);
            builder.append("value: ");
            builder.append(this.value.toString(nextIndent));
            return builder.toString();
        }
    }

    /**
     * <pre>
     * Represents the use of the `&amp;&amp;=` operator for assignment to a constant.
     *
     *     Target &amp;&amp;= value
     *     ^^^^^^^^^^^^^^^^
     * </pre>
     */
    public static final class ConstantAndWriteNode extends Node {
        public final String name;
        public final Node value;

        public ConstantAndWriteNode(int startOffset, int length, String name, Node value) {
            super(startOffset, length);
            this.name = name;
            this.value = value;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            this.value.accept(visitor);
        }

        public Node[] childNodes() {
            return new Node[] { this.value };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitConstantAndWriteNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            builder.append(nextIndent);
            builder.append("name: ");
            builder.append('"').append(this.name).append('"');
            builder.append('\n');
            builder.append(nextIndent);
            builder.append("value: ");
            builder.append(this.value.toString(nextIndent));
            return builder.toString();
        }
    }

    /**
     * <pre>
     * Represents assigning to a constant using an operator that isn&#39;t `=`.
     *
     *     Target += value
     *     ^^^^^^^^^^^^^^^
     * </pre>
     */
    public static final class ConstantOperatorWriteNode extends Node {
        public final String name;
        public final Node value;
        public final String binary_operator;

        public ConstantOperatorWriteNode(int startOffset, int length, String name, Node value, String binary_operator) {
            super(startOffset, length);
            this.name = name;
            this.value = value;
            this.binary_operator = binary_operator;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            this.value.accept(visitor);
        }

        public Node[] childNodes() {
            return new Node[] { this.value };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitConstantOperatorWriteNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            builder.append(nextIndent);
            builder.append("name: ");
            builder.append('"').append(this.name).append('"');
            builder.append('\n');
            builder.append(nextIndent);
            builder.append("value: ");
            builder.append(this.value.toString(nextIndent));
            builder.append(nextIndent);
            builder.append("binary_operator: ");
            builder.append('"').append(this.binary_operator).append('"');
            builder.append('\n');
            return builder.toString();
        }
    }

    /**
     * <pre>
     * Represents the use of the `||=` operator for assignment to a constant.
     *
     *     Target ||= value
     *     ^^^^^^^^^^^^^^^^
     * </pre>
     */
    public static final class ConstantOrWriteNode extends Node {
        public final String name;
        public final Node value;

        public ConstantOrWriteNode(int startOffset, int length, String name, Node value) {
            super(startOffset, length);
            this.name = name;
            this.value = value;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            this.value.accept(visitor);
        }

        public Node[] childNodes() {
            return new Node[] { this.value };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitConstantOrWriteNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            builder.append(nextIndent);
            builder.append("name: ");
            builder.append('"').append(this.name).append('"');
            builder.append('\n');
            builder.append(nextIndent);
            builder.append("value: ");
            builder.append(this.value.toString(nextIndent));
            return builder.toString();
        }
    }

    /**
     * <pre>
     * Represents the use of the `&amp;&amp;=` operator for assignment to a constant path.
     *
     *     Parent::Child &amp;&amp;= value
     *     ^^^^^^^^^^^^^^^^^^^^^^^
     * </pre>
     */
    public static final class ConstantPathAndWriteNode extends Node {
        public final ConstantPathNode target;
        public final Node value;

        public ConstantPathAndWriteNode(int startOffset, int length, ConstantPathNode target, Node value) {
            super(startOffset, length);
            this.target = target;
            this.value = value;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            this.target.accept(visitor);
            this.value.accept(visitor);
        }

        public Node[] childNodes() {
            return new Node[] { this.target, this.value };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitConstantPathAndWriteNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            builder.append(nextIndent);
            builder.append("target: ");
            builder.append(this.target.toString(nextIndent));
            builder.append(nextIndent);
            builder.append("value: ");
            builder.append(this.value.toString(nextIndent));
            return builder.toString();
        }
    }

    /**
     * <pre>
     * Represents accessing a constant through a path of `::` operators.
     *
     *     Foo::Bar
     *     ^^^^^^^^
     * </pre>
     */
    public static final class ConstantPathNode extends Node {
        /**
         * <pre>
         * The left-hand node of the path, if present. It can be `nil` or any [non-void expression](https://github.com/ruby/prism/blob/main/docs/parsing_rules.md#non-void-expression). It will be `nil` when the constant lookup is at the root of the module tree.
         *
         *     Foo::Bar
         *     ^^^
         *
         *     self::Test
         *     ^^^^
         *
         *     a.b::C
         *     ^^^
         * </pre>
         */
        @Nullable
        public final Node parent;
        /**
         * <pre>
         * The name of the constant being accessed. This could be `nil` in the event of a syntax error.
         * </pre>
         */
        @Nullable
        public final String name;

        public ConstantPathNode(int startOffset, int length, Node parent, String name) {
            super(startOffset, length);
            this.parent = parent;
            this.name = name;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            if (this.parent != null) {
                this.parent.accept(visitor);
            }
        }

        public Node[] childNodes() {
            return new Node[] { this.parent };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitConstantPathNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            builder.append(nextIndent);
            builder.append("parent: ");
            builder.append(this.parent == null ? "null\n" : this.parent.toString(nextIndent));
            builder.append(nextIndent);
            builder.append("name: ");
            builder.append(this.name == null ? "null" : "\"" + this.name + "\"");
            builder.append('\n');
            return builder.toString();
        }
    }

    /**
     * <pre>
     * Represents assigning to a constant path using an operator that isn&#39;t `=`.
     *
     *     Parent::Child += value
     *     ^^^^^^^^^^^^^^^^^^^^^^
     * </pre>
     */
    public static final class ConstantPathOperatorWriteNode extends Node {
        public final ConstantPathNode target;
        public final Node value;
        public final String binary_operator;

        public ConstantPathOperatorWriteNode(int startOffset, int length, ConstantPathNode target, Node value, String binary_operator) {
            super(startOffset, length);
            this.target = target;
            this.value = value;
            this.binary_operator = binary_operator;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            this.target.accept(visitor);
            this.value.accept(visitor);
        }

        public Node[] childNodes() {
            return new Node[] { this.target, this.value };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitConstantPathOperatorWriteNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            builder.append(nextIndent);
            builder.append("target: ");
            builder.append(this.target.toString(nextIndent));
            builder.append(nextIndent);
            builder.append("value: ");
            builder.append(this.value.toString(nextIndent));
            builder.append(nextIndent);
            builder.append("binary_operator: ");
            builder.append('"').append(this.binary_operator).append('"');
            builder.append('\n');
            return builder.toString();
        }
    }

    /**
     * <pre>
     * Represents the use of the `||=` operator for assignment to a constant path.
     *
     *     Parent::Child ||= value
     *     ^^^^^^^^^^^^^^^^^^^^^^^
     * </pre>
     */
    public static final class ConstantPathOrWriteNode extends Node {
        public final ConstantPathNode target;
        public final Node value;

        public ConstantPathOrWriteNode(int startOffset, int length, ConstantPathNode target, Node value) {
            super(startOffset, length);
            this.target = target;
            this.value = value;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            this.target.accept(visitor);
            this.value.accept(visitor);
        }

        public Node[] childNodes() {
            return new Node[] { this.target, this.value };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitConstantPathOrWriteNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            builder.append(nextIndent);
            builder.append("target: ");
            builder.append(this.target.toString(nextIndent));
            builder.append(nextIndent);
            builder.append("value: ");
            builder.append(this.value.toString(nextIndent));
            return builder.toString();
        }
    }

    /**
     * <pre>
     * Represents writing to a constant path in a context that doesn&#39;t have an explicit value.
     *
     *     Foo::Foo, Bar::Bar = baz
     *     ^^^^^^^^  ^^^^^^^^
     * </pre>
     */
    public static final class ConstantPathTargetNode extends Node {
        @Nullable
        public final Node parent;
        @Nullable
        public final String name;

        public ConstantPathTargetNode(int startOffset, int length, Node parent, String name) {
            super(startOffset, length);
            this.parent = parent;
            this.name = name;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            if (this.parent != null) {
                this.parent.accept(visitor);
            }
        }

        public Node[] childNodes() {
            return new Node[] { this.parent };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitConstantPathTargetNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            builder.append(nextIndent);
            builder.append("parent: ");
            builder.append(this.parent == null ? "null\n" : this.parent.toString(nextIndent));
            builder.append(nextIndent);
            builder.append("name: ");
            builder.append(this.name == null ? "null" : "\"" + this.name + "\"");
            builder.append('\n');
            return builder.toString();
        }
    }

    /**
     * <pre>
     * Represents writing to a constant path.
     *
     *     ::Foo = 1
     *     ^^^^^^^^^
     *
     *     Foo::Bar = 1
     *     ^^^^^^^^^^^^
     *
     *     ::Foo::Bar = 1
     *     ^^^^^^^^^^^^^^
     * </pre>
     */
    public static final class ConstantPathWriteNode extends Node {
        /**
         * <pre>
         * A node representing the constant path being written to.
         *
         *     Foo::Bar = 1
         *     ^^^^^^^^
         *
         *     ::Foo = :abc
         *     ^^^^^
         * </pre>
         */
        public final ConstantPathNode target;
        /**
         * <pre>
         * The value to write to the constant path. It can be any [non-void expression](https://github.com/ruby/prism/blob/main/docs/parsing_rules.md#non-void-expression).
         *
         *     FOO::BAR = :abc
         *                ^^^^
         * </pre>
         */
        public final Node value;

        public ConstantPathWriteNode(int startOffset, int length, ConstantPathNode target, Node value) {
            super(startOffset, length);
            this.target = target;
            this.value = value;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            this.target.accept(visitor);
            this.value.accept(visitor);
        }

        public Node[] childNodes() {
            return new Node[] { this.target, this.value };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitConstantPathWriteNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            builder.append(nextIndent);
            builder.append("target: ");
            builder.append(this.target.toString(nextIndent));
            builder.append(nextIndent);
            builder.append("value: ");
            builder.append(this.value.toString(nextIndent));
            return builder.toString();
        }
    }

    /**
     * <pre>
     * Represents referencing a constant.
     *
     *     Foo
     *     ^^^
     * </pre>
     */
    public static final class ConstantReadNode extends Node {
        /**
         * <pre>
         * The name of the [constant](https://github.com/ruby/prism/blob/main/docs/parsing_rules.md#constants).
         *
         *     X              # name `:X`
         *
         *     SOME_CONSTANT  # name `:SOME_CONSTANT`
         * </pre>
         */
        public final String name;

        public ConstantReadNode(int startOffset, int length, String name) {
            super(startOffset, length);
            this.name = name;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
        }

        public Node[] childNodes() {
            return EMPTY_ARRAY;
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitConstantReadNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            builder.append(nextIndent);
            builder.append("name: ");
            builder.append('"').append(this.name).append('"');
            builder.append('\n');
            return builder.toString();
        }
    }

    /**
     * <pre>
     * Represents writing to a constant in a context that doesn&#39;t have an explicit value.
     *
     *     Foo, Bar = baz
     *     ^^^  ^^^
     * </pre>
     */
    public static final class ConstantTargetNode extends Node {
        public final String name;

        public ConstantTargetNode(int startOffset, int length, String name) {
            super(startOffset, length);
            this.name = name;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
        }

        public Node[] childNodes() {
            return EMPTY_ARRAY;
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitConstantTargetNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            builder.append(nextIndent);
            builder.append("name: ");
            builder.append('"').append(this.name).append('"');
            builder.append('\n');
            return builder.toString();
        }
    }

    /**
     * <pre>
     * Represents writing to a constant.
     *
     *     Foo = 1
     *     ^^^^^^^
     * </pre>
     */
    public static final class ConstantWriteNode extends Node {
        /**
         * <pre>
         * The name of the [constant](https://github.com/ruby/prism/blob/main/docs/parsing_rules.md#constants).
         *
         *     Foo = :bar # name `:Foo`
         *
         *     XYZ = 1    # name `:XYZ`
         * </pre>
         */
        public final String name;
        /**
         * <pre>
         * The value to write to the constant. It can be any [non-void expression](https://github.com/ruby/prism/blob/main/docs/parsing_rules.md#non-void-expression).
         *
         *     FOO = :bar
         *           ^^^^
         *
         *     MyClass = Class.new
         *               ^^^^^^^^^
         * </pre>
         */
        public final Node value;

        public ConstantWriteNode(int startOffset, int length, String name, Node value) {
            super(startOffset, length);
            this.name = name;
            this.value = value;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            this.value.accept(visitor);
        }

        public Node[] childNodes() {
            return new Node[] { this.value };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitConstantWriteNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            builder.append(nextIndent);
            builder.append("name: ");
            builder.append('"').append(this.name).append('"');
            builder.append('\n');
            builder.append(nextIndent);
            builder.append("value: ");
            builder.append(this.value.toString(nextIndent));
            return builder.toString();
        }
    }

    /**
     * <pre>
     * Represents a method definition.
     *
     *     def method
     *     end
     *     ^^^^^^^^^^
     * </pre>
     */
    public static final class DefNode extends Node {
        public final int serializedLength;
        public final String name;
        @Nullable
        public final Node receiver;
        @Nullable
        public final ParametersNode parameters;
        @Nullable
        public final Node body;
        public final String[] locals;

        public DefNode(int startOffset, int length, int serializedLength, String name, Node receiver, ParametersNode parameters, Node body, String[] locals) {
            super(startOffset, length);
            this.serializedLength = serializedLength;
            this.name = name;
            this.receiver = receiver;
            this.parameters = parameters;
            this.body = body;
            this.locals = locals;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            if (this.receiver != null) {
                this.receiver.accept(visitor);
            }
            if (this.parameters != null) {
                this.parameters.accept(visitor);
            }
            if (this.body != null) {
                this.body.accept(visitor);
            }
        }

        public Node[] childNodes() {
            return new Node[] { this.receiver, this.parameters, this.body };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitDefNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            String nextNextIndent = nextIndent + "  ";
            builder.append(nextIndent);
            builder.append("name: ");
            builder.append('"').append(this.name).append('"');
            builder.append('\n');
            builder.append(nextIndent);
            builder.append("receiver: ");
            builder.append(this.receiver == null ? "null\n" : this.receiver.toString(nextIndent));
            builder.append(nextIndent);
            builder.append("parameters: ");
            builder.append(this.parameters == null ? "null\n" : this.parameters.toString(nextIndent));
            builder.append(nextIndent);
            builder.append("body: ");
            builder.append(this.body == null ? "null\n" : this.body.toString(nextIndent));
            builder.append(nextIndent);
            builder.append("locals: ");
            builder.append('\n');
            for (String constant : this.locals) {
                builder.append(nextNextIndent).append('"').append(constant).append('"').append('\n');
            }
            return builder.toString();
        }
    }

    /**
     * <pre>
     * Represents the use of the `defined?` keyword.
     *
     *     defined?(a)
     *     ^^^^^^^^^^^
     * </pre>
     */
    public static final class DefinedNode extends Node {
        public final Node value;

        public DefinedNode(int startOffset, int length, Node value) {
            super(startOffset, length);
            this.value = value;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            this.value.accept(visitor);
        }

        public Node[] childNodes() {
            return new Node[] { this.value };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitDefinedNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            builder.append(nextIndent);
            builder.append("value: ");
            builder.append(this.value.toString(nextIndent));
            return builder.toString();
        }
    }

    /**
     * <pre>
     * Represents an `else` clause in a `case`, `if`, or `unless` statement.
     *
     *     if a then b else c end
     *                 ^^^^^^^^^^
     * </pre>
     */
    public static final class ElseNode extends Node {
        @Nullable
        public final StatementsNode statements;

        public ElseNode(int startOffset, int length, StatementsNode statements) {
            super(startOffset, length);
            this.statements = statements;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            if (this.statements != null) {
                this.statements.accept(visitor);
            }
        }

        public Node[] childNodes() {
            return new Node[] { this.statements };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitElseNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            builder.append(nextIndent);
            builder.append("statements: ");
            builder.append(this.statements == null ? "null\n" : this.statements.toString(nextIndent));
            return builder.toString();
        }
    }

    /**
     * <pre>
     * Represents an interpolated set of statements.
     *
     *     &quot;foo #{bar}&quot;
     *          ^^^^^^
     * </pre>
     */
    public static final class EmbeddedStatementsNode extends Node {
        @Nullable
        public final StatementsNode statements;

        public EmbeddedStatementsNode(int startOffset, int length, StatementsNode statements) {
            super(startOffset, length);
            this.statements = statements;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            if (this.statements != null) {
                this.statements.accept(visitor);
            }
        }

        public Node[] childNodes() {
            return new Node[] { this.statements };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitEmbeddedStatementsNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            builder.append(nextIndent);
            builder.append("statements: ");
            builder.append(this.statements == null ? "null\n" : this.statements.toString(nextIndent));
            return builder.toString();
        }
    }

    /**
     * <pre>
     * Represents an interpolated variable.
     *
     *     &quot;foo #&#64;bar&quot;
     *          ^^^^^
     * </pre>
     */
    public static final class EmbeddedVariableNode extends Node {
        public final Node variable;

        public EmbeddedVariableNode(int startOffset, int length, Node variable) {
            super(startOffset, length);
            this.variable = variable;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            this.variable.accept(visitor);
        }

        public Node[] childNodes() {
            return new Node[] { this.variable };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitEmbeddedVariableNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            builder.append(nextIndent);
            builder.append("variable: ");
            builder.append(this.variable.toString(nextIndent));
            return builder.toString();
        }
    }

    /**
     * <pre>
     * Represents an `ensure` clause in a `begin` statement.
     *
     *     begin
     *       foo
     *     ensure
     *     ^^^^^^
     *       bar
     *     end
     * </pre>
     */
    public static final class EnsureNode extends Node {
        @Nullable
        public final StatementsNode statements;

        public EnsureNode(int startOffset, int length, StatementsNode statements) {
            super(startOffset, length);
            this.statements = statements;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            if (this.statements != null) {
                this.statements.accept(visitor);
            }
        }

        public Node[] childNodes() {
            return new Node[] { this.statements };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitEnsureNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            builder.append(nextIndent);
            builder.append("statements: ");
            builder.append(this.statements == null ? "null\n" : this.statements.toString(nextIndent));
            return builder.toString();
        }
    }

    /**
     * <pre>
     * Represents the use of the literal `false` keyword.
     *
     *     false
     *     ^^^^^
     * </pre>
     */
    public static final class FalseNode extends Node {

        public FalseNode(int startOffset, int length) {
            super(startOffset, length);
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
        }

        public Node[] childNodes() {
            return EMPTY_ARRAY;
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitFalseNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            return builder.toString();
        }
    }

    /**
     * <pre>
     * Represents a find pattern in pattern matching.
     *
     *     foo in *bar, baz, *qux
     *            ^^^^^^^^^^^^^^^
     *
     *     foo in [*bar, baz, *qux]
     *            ^^^^^^^^^^^^^^^^^
     *
     *     foo in Foo(*bar, baz, *qux)
     *            ^^^^^^^^^^^^^^^^^^^^
     * </pre>
     */
    public static final class FindPatternNode extends Node {
        @Nullable
        public final Node constant;
        public final Node left;
        public final Node[] requireds;
        public final Node right;

        public FindPatternNode(int startOffset, int length, Node constant, Node left, Node[] requireds, Node right) {
            super(startOffset, length);
            this.constant = constant;
            this.left = left;
            this.requireds = requireds;
            this.right = right;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            if (this.constant != null) {
                this.constant.accept(visitor);
            }
            this.left.accept(visitor);
            for (Nodes.Node child : this.requireds) {
                child.accept(visitor);
            }
            this.right.accept(visitor);
        }

        public Node[] childNodes() {
            ArrayList<Node> childNodes = new ArrayList<>();
            childNodes.add(this.constant);
            childNodes.add(this.left);
            childNodes.addAll(Arrays.asList(this.requireds));
            childNodes.add(this.right);
            return childNodes.toArray(EMPTY_ARRAY);
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitFindPatternNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            String nextNextIndent = nextIndent + "  ";
            builder.append(nextIndent);
            builder.append("constant: ");
            builder.append(this.constant == null ? "null\n" : this.constant.toString(nextIndent));
            builder.append(nextIndent);
            builder.append("left: ");
            builder.append(this.left.toString(nextIndent));
            builder.append(nextIndent);
            builder.append("requireds: ");
            builder.append('\n');
            for (Node child : this.requireds) {
                builder.append(nextNextIndent).append(child.toString(nextNextIndent));
            }
            builder.append(nextIndent);
            builder.append("right: ");
            builder.append(this.right.toString(nextIndent));
            return builder.toString();
        }
    }

    /**
     * <pre>
     * Represents the use of the `..` or `...` operators to create flip flops.
     *
     *     baz if foo .. bar
     *            ^^^^^^^^^^
     * </pre>
     */
    public static final class FlipFlopNode extends Node {
        public final short flags;
        @Nullable
        public final Node left;
        @Nullable
        public final Node right;

        public FlipFlopNode(int startOffset, int length, short flags, Node left, Node right) {
            super(startOffset, length);
            this.flags = flags;
            this.left = left;
            this.right = right;
        }
        
        public boolean isExcludeEnd() {
            return RangeFlags.isExcludeEnd(flags);
        }
        
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            if (this.left != null) {
                this.left.accept(visitor);
            }
            if (this.right != null) {
                this.right.accept(visitor);
            }
        }

        public Node[] childNodes() {
            return new Node[] { this.left, this.right };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitFlipFlopNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            builder.append(nextIndent);
            builder.append("RangeFlags: ");
            builder.append(flags);
            builder.append('\n');
            builder.append(nextIndent);
            builder.append("left: ");
            builder.append(this.left == null ? "null\n" : this.left.toString(nextIndent));
            builder.append(nextIndent);
            builder.append("right: ");
            builder.append(this.right == null ? "null\n" : this.right.toString(nextIndent));
            return builder.toString();
        }
    }

    /**
     * <pre>
     * Represents a floating point number literal.
     *
     *     1.0
     *     ^^^
     * </pre>
     */
    public static final class FloatNode extends Node {
        /**
         * <pre>
         * The value of the floating point number as a Float.
         * </pre>
         */
        public final double value;

        public FloatNode(int startOffset, int length, double value) {
            super(startOffset, length);
            this.value = value;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
        }

        public Node[] childNodes() {
            return EMPTY_ARRAY;
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitFloatNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            builder.append(nextIndent);
            builder.append("value: ");
            builder.append(this.value);
            builder.append('\n');
            return builder.toString();
        }
    }

    /**
     * <pre>
     * Represents the use of the `for` keyword.
     *
     *     for i in a end
     *     ^^^^^^^^^^^^^^
     * </pre>
     */
    public static final class ForNode extends Node {
        /**
         * <pre>
         * The index expression for `for` loops.
         *
         *     for i in a end
         *         ^
         * </pre>
         */
        public final Node index;
        /**
         * <pre>
         * The collection to iterate over.
         *
         *     for i in a end
         *              ^
         * </pre>
         */
        public final Node collection;
        /**
         * <pre>
         * Represents the body of statements to execute for each iteration of the loop.
         *
         *     for i in a
         *       foo(i)
         *       ^^^^^^
         *     end
         * </pre>
         */
        @Nullable
        public final StatementsNode statements;

        public ForNode(int startOffset, int length, Node index, Node collection, StatementsNode statements) {
            super(startOffset, length);
            this.index = index;
            this.collection = collection;
            this.statements = statements;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            this.index.accept(visitor);
            this.collection.accept(visitor);
            if (this.statements != null) {
                this.statements.accept(visitor);
            }
        }

        public Node[] childNodes() {
            return new Node[] { this.index, this.collection, this.statements };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitForNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            builder.append(nextIndent);
            builder.append("index: ");
            builder.append(this.index.toString(nextIndent));
            builder.append(nextIndent);
            builder.append("collection: ");
            builder.append(this.collection.toString(nextIndent));
            builder.append(nextIndent);
            builder.append("statements: ");
            builder.append(this.statements == null ? "null\n" : this.statements.toString(nextIndent));
            return builder.toString();
        }
    }

    /**
     * <pre>
     * Represents forwarding all arguments to this method to another method.
     *
     *     def foo(...)
     *       bar(...)
     *           ^^^
     *     end
     * </pre>
     */
    public static final class ForwardingArgumentsNode extends Node {

        public ForwardingArgumentsNode(int startOffset, int length) {
            super(startOffset, length);
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
        }

        public Node[] childNodes() {
            return EMPTY_ARRAY;
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitForwardingArgumentsNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            return builder.toString();
        }
    }

    /**
     * <pre>
     * Represents the use of the forwarding parameter in a method, block, or lambda declaration.
     *
     *     def foo(...)
     *             ^^^
     *     end
     * </pre>
     */
    public static final class ForwardingParameterNode extends Node {

        public ForwardingParameterNode(int startOffset, int length) {
            super(startOffset, length);
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
        }

        public Node[] childNodes() {
            return EMPTY_ARRAY;
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitForwardingParameterNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            return builder.toString();
        }
    }

    /**
     * <pre>
     * Represents the use of the `super` keyword without parentheses or arguments.
     *
     *     super
     *     ^^^^^
     * </pre>
     */
    public static final class ForwardingSuperNode extends Node {
        @Nullable
        public final BlockNode block;

        public ForwardingSuperNode(int startOffset, int length, BlockNode block) {
            super(startOffset, length);
            this.block = block;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            if (this.block != null) {
                this.block.accept(visitor);
            }
        }

        public Node[] childNodes() {
            return new Node[] { this.block };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitForwardingSuperNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            builder.append(nextIndent);
            builder.append("block: ");
            builder.append(this.block == null ? "null\n" : this.block.toString(nextIndent));
            return builder.toString();
        }
    }

    /**
     * <pre>
     * Represents the use of the `&amp;&amp;=` operator for assignment to a global variable.
     *
     *     $target &amp;&amp;= value
     *     ^^^^^^^^^^^^^^^^^
     * </pre>
     */
    public static final class GlobalVariableAndWriteNode extends Node {
        public final String name;
        public final Node value;

        public GlobalVariableAndWriteNode(int startOffset, int length, String name, Node value) {
            super(startOffset, length);
            this.name = name;
            this.value = value;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            this.value.accept(visitor);
        }

        public Node[] childNodes() {
            return new Node[] { this.value };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitGlobalVariableAndWriteNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            builder.append(nextIndent);
            builder.append("name: ");
            builder.append('"').append(this.name).append('"');
            builder.append('\n');
            builder.append(nextIndent);
            builder.append("value: ");
            builder.append(this.value.toString(nextIndent));
            return builder.toString();
        }
    }

    /**
     * <pre>
     * Represents assigning to a global variable using an operator that isn&#39;t `=`.
     *
     *     $target += value
     *     ^^^^^^^^^^^^^^^^
     * </pre>
     */
    public static final class GlobalVariableOperatorWriteNode extends Node {
        public final String name;
        public final Node value;
        public final String binary_operator;

        public GlobalVariableOperatorWriteNode(int startOffset, int length, String name, Node value, String binary_operator) {
            super(startOffset, length);
            this.name = name;
            this.value = value;
            this.binary_operator = binary_operator;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            this.value.accept(visitor);
        }

        public Node[] childNodes() {
            return new Node[] { this.value };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitGlobalVariableOperatorWriteNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            builder.append(nextIndent);
            builder.append("name: ");
            builder.append('"').append(this.name).append('"');
            builder.append('\n');
            builder.append(nextIndent);
            builder.append("value: ");
            builder.append(this.value.toString(nextIndent));
            builder.append(nextIndent);
            builder.append("binary_operator: ");
            builder.append('"').append(this.binary_operator).append('"');
            builder.append('\n');
            return builder.toString();
        }
    }

    /**
     * <pre>
     * Represents the use of the `||=` operator for assignment to a global variable.
     *
     *     $target ||= value
     *     ^^^^^^^^^^^^^^^^^
     * </pre>
     */
    public static final class GlobalVariableOrWriteNode extends Node {
        public final String name;
        public final Node value;

        public GlobalVariableOrWriteNode(int startOffset, int length, String name, Node value) {
            super(startOffset, length);
            this.name = name;
            this.value = value;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            this.value.accept(visitor);
        }

        public Node[] childNodes() {
            return new Node[] { this.value };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitGlobalVariableOrWriteNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            builder.append(nextIndent);
            builder.append("name: ");
            builder.append('"').append(this.name).append('"');
            builder.append('\n');
            builder.append(nextIndent);
            builder.append("value: ");
            builder.append(this.value.toString(nextIndent));
            return builder.toString();
        }
    }

    /**
     * <pre>
     * Represents referencing a global variable.
     *
     *     $foo
     *     ^^^^
     * </pre>
     */
    public static final class GlobalVariableReadNode extends Node {
        /**
         * <pre>
         * The name of the global variable, which is a `$` followed by an [identifier](https://github.com/ruby/prism/blob/main/docs/parsing_rules.md#identifier). Alternatively, it can be one of the special global variables designated by a symbol.
         *
         *     $foo   # name `:$foo`
         *
         *     $_Test # name `:$_Test`
         * </pre>
         */
        public final String name;

        public GlobalVariableReadNode(int startOffset, int length, String name) {
            super(startOffset, length);
            this.name = name;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
        }

        public Node[] childNodes() {
            return EMPTY_ARRAY;
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitGlobalVariableReadNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            builder.append(nextIndent);
            builder.append("name: ");
            builder.append('"').append(this.name).append('"');
            builder.append('\n');
            return builder.toString();
        }
    }

    /**
     * <pre>
     * Represents writing to a global variable in a context that doesn&#39;t have an explicit value.
     *
     *     $foo, $bar = baz
     *     ^^^^  ^^^^
     * </pre>
     */
    public static final class GlobalVariableTargetNode extends Node {
        public final String name;

        public GlobalVariableTargetNode(int startOffset, int length, String name) {
            super(startOffset, length);
            this.name = name;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
        }

        public Node[] childNodes() {
            return EMPTY_ARRAY;
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitGlobalVariableTargetNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            builder.append(nextIndent);
            builder.append("name: ");
            builder.append('"').append(this.name).append('"');
            builder.append('\n');
            return builder.toString();
        }
    }

    /**
     * <pre>
     * Represents writing to a global variable.
     *
     *     $foo = 1
     *     ^^^^^^^^
     * </pre>
     */
    public static final class GlobalVariableWriteNode extends Node {
        /**
         * <pre>
         * The name of the global variable, which is a `$` followed by an [identifier](https://github.com/ruby/prism/blob/main/docs/parsing_rules.md#identifier). Alternatively, it can be one of the special global variables designated by a symbol.
         *
         *     $foo = :bar  # name `:$foo`
         *
         *     $_Test = 123 # name `:$_Test`
         * </pre>
         */
        public final String name;
        /**
         * <pre>
         * The value to write to the global variable. It can be any [non-void expression](https://github.com/ruby/prism/blob/main/docs/parsing_rules.md#non-void-expression).
         *
         *     $foo = :bar
         *            ^^^^
         *
         *     $-xyz = 123
         *             ^^^
         * </pre>
         */
        public final Node value;

        public GlobalVariableWriteNode(int startOffset, int length, String name, Node value) {
            super(startOffset, length);
            this.name = name;
            this.value = value;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            this.value.accept(visitor);
        }

        public Node[] childNodes() {
            return new Node[] { this.value };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitGlobalVariableWriteNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            builder.append(nextIndent);
            builder.append("name: ");
            builder.append('"').append(this.name).append('"');
            builder.append('\n');
            builder.append(nextIndent);
            builder.append("value: ");
            builder.append(this.value.toString(nextIndent));
            return builder.toString();
        }
    }

    /**
     * <pre>
     * Represents a hash literal.
     *
     *     { a =&gt; b }
     *     ^^^^^^^^^^
     * </pre>
     */
    public static final class HashNode extends Node {
        /**
         * <pre>
         * The elements of the hash. These can be either `AssocNode`s or `AssocSplatNode`s.
         *
         *     { a: b }
         *       ^^^^
         *
         *     { **foo }
         *       ^^^^^
         * </pre>
         */
        @UnionType({ AssocNode.class, AssocSplatNode.class })
        public final Node[] elements;

        public HashNode(int startOffset, int length, Node[] elements) {
            super(startOffset, length);
            this.elements = elements;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            for (Nodes.Node child : this.elements) {
                child.accept(visitor);
            }
        }

        public Node[] childNodes() {
            ArrayList<Node> childNodes = new ArrayList<>();
            childNodes.addAll(Arrays.asList(this.elements));
            return childNodes.toArray(EMPTY_ARRAY);
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitHashNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            String nextNextIndent = nextIndent + "  ";
            builder.append(nextIndent);
            builder.append("elements: ");
            builder.append('\n');
            for (Node child : this.elements) {
                builder.append(nextNextIndent).append(child.toString(nextNextIndent));
            }
            return builder.toString();
        }
    }

    /**
     * <pre>
     * Represents a hash pattern in pattern matching.
     *
     *     foo =&gt; { a: 1, b: 2 }
     *            ^^^^^^^^^^^^^^
     *
     *     foo =&gt; { a: 1, b: 2, **c }
     *            ^^^^^^^^^^^^^^^^^^^
     * </pre>
     */
    public static final class HashPatternNode extends Node {
        @Nullable
        public final Node constant;
        public final AssocNode[] elements;
        @Nullable
        @UnionType({ AssocSplatNode.class, NoKeywordsParameterNode.class })
        public final Node rest;

        public HashPatternNode(int startOffset, int length, Node constant, AssocNode[] elements, Node rest) {
            super(startOffset, length);
            this.constant = constant;
            this.elements = elements;
            this.rest = rest;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            if (this.constant != null) {
                this.constant.accept(visitor);
            }
            for (Nodes.Node child : this.elements) {
                child.accept(visitor);
            }
            if (this.rest != null) {
                this.rest.accept(visitor);
            }
        }

        public Node[] childNodes() {
            ArrayList<Node> childNodes = new ArrayList<>();
            childNodes.add(this.constant);
            childNodes.addAll(Arrays.asList(this.elements));
            childNodes.add(this.rest);
            return childNodes.toArray(EMPTY_ARRAY);
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitHashPatternNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            String nextNextIndent = nextIndent + "  ";
            builder.append(nextIndent);
            builder.append("constant: ");
            builder.append(this.constant == null ? "null\n" : this.constant.toString(nextIndent));
            builder.append(nextIndent);
            builder.append("elements: ");
            builder.append('\n');
            for (Node child : this.elements) {
                builder.append(nextNextIndent).append(child.toString(nextNextIndent));
            }
            builder.append(nextIndent);
            builder.append("rest: ");
            builder.append(this.rest == null ? "null\n" : this.rest.toString(nextIndent));
            return builder.toString();
        }
    }

    /**
     * <pre>
     * Represents the use of the `if` keyword, either in the block form or the modifier form, or a ternary expression.
     *
     *     bar if foo
     *     ^^^^^^^^^^
     *
     *     if foo then bar end
     *     ^^^^^^^^^^^^^^^^^^^
     *
     *     foo ? bar : baz
     *     ^^^^^^^^^^^^^^^
     * </pre>
     */
    public static final class IfNode extends Node {
        /**
         * <pre>
         * The node for the condition the `IfNode` is testing.
         *
         *     if foo
         *        ^^^
         *       bar
         *     end
         *
         *     bar if foo
         *            ^^^
         *
         *     foo ? bar : baz
         *     ^^^
         * </pre>
         */
        public final Node predicate;
        /**
         * <pre>
         * Represents the body of statements that will be executed when the predicate is evaluated as truthy. Will be `nil` when no body is provided.
         *
         *     if foo
         *       bar
         *       ^^^
         *       baz
         *       ^^^
         *     end
         * </pre>
         */
        @Nullable
        public final StatementsNode statements;
        /**
         * <pre>
         * Represents an `ElseNode` or an `IfNode` when there is an `else` or an `elsif` in the `if` statement.
         *
         *     if foo
         *       bar
         *     elsif baz
         *     ^^^^^^^^^
         *       qux
         *       ^^^
         *     end
         *     ^^^
         *
         *     if foo then bar else baz end
         *                     ^^^^^^^^^^^^
         * </pre>
         */
        @Nullable
        @UnionType({ ElseNode.class, IfNode.class })
        public final Node subsequent;

        public IfNode(int startOffset, int length, Node predicate, StatementsNode statements, Node subsequent) {
            super(startOffset, length);
            this.predicate = predicate;
            this.statements = statements;
            this.subsequent = subsequent;
        }
                
        @Override
        public void setNewLineFlag(Source source, boolean[] newlineMarked) {
            this.predicate.setNewLineFlag(source, newlineMarked);
        }

        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            this.predicate.accept(visitor);
            if (this.statements != null) {
                this.statements.accept(visitor);
            }
            if (this.subsequent != null) {
                this.subsequent.accept(visitor);
            }
        }

        public Node[] childNodes() {
            return new Node[] { this.predicate, this.statements, this.subsequent };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitIfNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            builder.append(nextIndent);
            builder.append("predicate: ");
            builder.append(this.predicate.toString(nextIndent));
            builder.append(nextIndent);
            builder.append("statements: ");
            builder.append(this.statements == null ? "null\n" : this.statements.toString(nextIndent));
            builder.append(nextIndent);
            builder.append("subsequent: ");
            builder.append(this.subsequent == null ? "null\n" : this.subsequent.toString(nextIndent));
            return builder.toString();
        }
    }

    /**
     * <pre>
     * Represents an imaginary number literal.
     *
     *     1.0i
     *     ^^^^
     * </pre>
     */
    public static final class ImaginaryNode extends Node {
        @UnionType({ FloatNode.class, IntegerNode.class, RationalNode.class })
        public final Node numeric;

        public ImaginaryNode(int startOffset, int length, Node numeric) {
            super(startOffset, length);
            this.numeric = numeric;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            this.numeric.accept(visitor);
        }

        public Node[] childNodes() {
            return new Node[] { this.numeric };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitImaginaryNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            builder.append(nextIndent);
            builder.append("numeric: ");
            builder.append(this.numeric.toString(nextIndent));
            return builder.toString();
        }
    }

    /**
     * <pre>
     * Represents a node that is implicitly being added to the tree but doesn&#39;t correspond directly to a node in the source.
     *
     *     { foo: }
     *       ^^^^
     *
     *     { Foo: }
     *       ^^^^
     *
     *     foo in { bar: }
     *              ^^^^
     * </pre>
     */
    public static final class ImplicitNode extends Node {
        public final Node value;

        public ImplicitNode(int startOffset, int length, Node value) {
            super(startOffset, length);
            this.value = value;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            this.value.accept(visitor);
        }

        public Node[] childNodes() {
            return new Node[] { this.value };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitImplicitNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            builder.append(nextIndent);
            builder.append("value: ");
            builder.append(this.value.toString(nextIndent));
            return builder.toString();
        }
    }

    /**
     * <pre>
     * Represents using a trailing comma to indicate an implicit rest parameter.
     *
     *     foo { |bar,| }
     *               ^
     *
     *     foo in [bar,]
     *                ^
     *
     *     for foo, in bar do end
     *            ^
     *
     *     foo, = bar
     *        ^
     * </pre>
     */
    public static final class ImplicitRestNode extends Node {

        public ImplicitRestNode(int startOffset, int length) {
            super(startOffset, length);
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
        }

        public Node[] childNodes() {
            return EMPTY_ARRAY;
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitImplicitRestNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            return builder.toString();
        }
    }

    /**
     * <pre>
     * Represents the use of the `in` keyword in a case statement.
     *
     *     case a; in b then c end
     *             ^^^^^^^^^^^
     * </pre>
     */
    public static final class InNode extends Node {
        public final Node pattern;
        @Nullable
        public final StatementsNode statements;

        public InNode(int startOffset, int length, Node pattern, StatementsNode statements) {
            super(startOffset, length);
            this.pattern = pattern;
            this.statements = statements;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            this.pattern.accept(visitor);
            if (this.statements != null) {
                this.statements.accept(visitor);
            }
        }

        public Node[] childNodes() {
            return new Node[] { this.pattern, this.statements };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitInNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            builder.append(nextIndent);
            builder.append("pattern: ");
            builder.append(this.pattern.toString(nextIndent));
            builder.append(nextIndent);
            builder.append("statements: ");
            builder.append(this.statements == null ? "null\n" : this.statements.toString(nextIndent));
            return builder.toString();
        }
    }

    /**
     * <pre>
     * Represents the use of the `&amp;&amp;=` operator on a call to the `[]` method.
     *
     *     foo.bar[baz] &amp;&amp;= value
     *     ^^^^^^^^^^^^^^^^^^^^^^
     * </pre>
     */
    public static final class IndexAndWriteNode extends Node {
        public final short flags;
        @Nullable
        public final Node receiver;
        @Nullable
        public final ArgumentsNode arguments;
        @Nullable
        public final Node block;
        public final Node value;

        public IndexAndWriteNode(int startOffset, int length, short flags, Node receiver, ArgumentsNode arguments, Node block, Node value) {
            super(startOffset, length);
            this.flags = flags;
            this.receiver = receiver;
            this.arguments = arguments;
            this.block = block;
            this.value = value;
        }
        
        public boolean isSafeNavigation() {
            return CallNodeFlags.isSafeNavigation(flags);
        }

        public boolean isVariableCall() {
            return CallNodeFlags.isVariableCall(flags);
        }

        public boolean isAttributeWrite() {
            return CallNodeFlags.isAttributeWrite(flags);
        }

        public boolean isIgnoreVisibility() {
            return CallNodeFlags.isIgnoreVisibility(flags);
        }
        
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            if (this.receiver != null) {
                this.receiver.accept(visitor);
            }
            if (this.arguments != null) {
                this.arguments.accept(visitor);
            }
            if (this.block != null) {
                this.block.accept(visitor);
            }
            this.value.accept(visitor);
        }

        public Node[] childNodes() {
            return new Node[] { this.receiver, this.arguments, this.block, this.value };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitIndexAndWriteNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            builder.append(nextIndent);
            builder.append("CallNodeFlags: ");
            builder.append(flags);
            builder.append('\n');
            builder.append(nextIndent);
            builder.append("receiver: ");
            builder.append(this.receiver == null ? "null\n" : this.receiver.toString(nextIndent));
            builder.append(nextIndent);
            builder.append("arguments: ");
            builder.append(this.arguments == null ? "null\n" : this.arguments.toString(nextIndent));
            builder.append(nextIndent);
            builder.append("block: ");
            builder.append(this.block == null ? "null\n" : this.block.toString(nextIndent));
            builder.append(nextIndent);
            builder.append("value: ");
            builder.append(this.value.toString(nextIndent));
            return builder.toString();
        }
    }

    /**
     * <pre>
     * Represents the use of an assignment operator on a call to `[]`.
     *
     *     foo.bar[baz] += value
     *     ^^^^^^^^^^^^^^^^^^^^^
     * </pre>
     */
    public static final class IndexOperatorWriteNode extends Node {
        public final short flags;
        @Nullable
        public final Node receiver;
        @Nullable
        public final ArgumentsNode arguments;
        @Nullable
        public final Node block;
        public final String binary_operator;
        public final Node value;

        public IndexOperatorWriteNode(int startOffset, int length, short flags, Node receiver, ArgumentsNode arguments, Node block, String binary_operator, Node value) {
            super(startOffset, length);
            this.flags = flags;
            this.receiver = receiver;
            this.arguments = arguments;
            this.block = block;
            this.binary_operator = binary_operator;
            this.value = value;
        }
        
        public boolean isSafeNavigation() {
            return CallNodeFlags.isSafeNavigation(flags);
        }

        public boolean isVariableCall() {
            return CallNodeFlags.isVariableCall(flags);
        }

        public boolean isAttributeWrite() {
            return CallNodeFlags.isAttributeWrite(flags);
        }

        public boolean isIgnoreVisibility() {
            return CallNodeFlags.isIgnoreVisibility(flags);
        }
        
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            if (this.receiver != null) {
                this.receiver.accept(visitor);
            }
            if (this.arguments != null) {
                this.arguments.accept(visitor);
            }
            if (this.block != null) {
                this.block.accept(visitor);
            }
            this.value.accept(visitor);
        }

        public Node[] childNodes() {
            return new Node[] { this.receiver, this.arguments, this.block, this.value };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitIndexOperatorWriteNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            builder.append(nextIndent);
            builder.append("CallNodeFlags: ");
            builder.append(flags);
            builder.append('\n');
            builder.append(nextIndent);
            builder.append("receiver: ");
            builder.append(this.receiver == null ? "null\n" : this.receiver.toString(nextIndent));
            builder.append(nextIndent);
            builder.append("arguments: ");
            builder.append(this.arguments == null ? "null\n" : this.arguments.toString(nextIndent));
            builder.append(nextIndent);
            builder.append("block: ");
            builder.append(this.block == null ? "null\n" : this.block.toString(nextIndent));
            builder.append(nextIndent);
            builder.append("binary_operator: ");
            builder.append('"').append(this.binary_operator).append('"');
            builder.append('\n');
            builder.append(nextIndent);
            builder.append("value: ");
            builder.append(this.value.toString(nextIndent));
            return builder.toString();
        }
    }

    /**
     * <pre>
     * Represents the use of the `||=` operator on a call to `[]`.
     *
     *     foo.bar[baz] ||= value
     *     ^^^^^^^^^^^^^^^^^^^^^^
     * </pre>
     */
    public static final class IndexOrWriteNode extends Node {
        public final short flags;
        @Nullable
        public final Node receiver;
        @Nullable
        public final ArgumentsNode arguments;
        @Nullable
        public final Node block;
        public final Node value;

        public IndexOrWriteNode(int startOffset, int length, short flags, Node receiver, ArgumentsNode arguments, Node block, Node value) {
            super(startOffset, length);
            this.flags = flags;
            this.receiver = receiver;
            this.arguments = arguments;
            this.block = block;
            this.value = value;
        }
        
        public boolean isSafeNavigation() {
            return CallNodeFlags.isSafeNavigation(flags);
        }

        public boolean isVariableCall() {
            return CallNodeFlags.isVariableCall(flags);
        }

        public boolean isAttributeWrite() {
            return CallNodeFlags.isAttributeWrite(flags);
        }

        public boolean isIgnoreVisibility() {
            return CallNodeFlags.isIgnoreVisibility(flags);
        }
        
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            if (this.receiver != null) {
                this.receiver.accept(visitor);
            }
            if (this.arguments != null) {
                this.arguments.accept(visitor);
            }
            if (this.block != null) {
                this.block.accept(visitor);
            }
            this.value.accept(visitor);
        }

        public Node[] childNodes() {
            return new Node[] { this.receiver, this.arguments, this.block, this.value };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitIndexOrWriteNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            builder.append(nextIndent);
            builder.append("CallNodeFlags: ");
            builder.append(flags);
            builder.append('\n');
            builder.append(nextIndent);
            builder.append("receiver: ");
            builder.append(this.receiver == null ? "null\n" : this.receiver.toString(nextIndent));
            builder.append(nextIndent);
            builder.append("arguments: ");
            builder.append(this.arguments == null ? "null\n" : this.arguments.toString(nextIndent));
            builder.append(nextIndent);
            builder.append("block: ");
            builder.append(this.block == null ? "null\n" : this.block.toString(nextIndent));
            builder.append(nextIndent);
            builder.append("value: ");
            builder.append(this.value.toString(nextIndent));
            return builder.toString();
        }
    }

    /**
     * <pre>
     * Represents assigning to an index.
     *
     *     foo[bar], = 1
     *     ^^^^^^^^
     *
     *     begin
     *     rescue =&gt; foo[bar]
     *               ^^^^^^^^
     *     end
     *
     *     for foo[bar] in baz do end
     *         ^^^^^^^^
     * </pre>
     */
    public static final class IndexTargetNode extends Node {
        public final short flags;
        public final Node receiver;
        @Nullable
        public final ArgumentsNode arguments;
        @Nullable
        public final Node block;

        public IndexTargetNode(int startOffset, int length, short flags, Node receiver, ArgumentsNode arguments, Node block) {
            super(startOffset, length);
            this.flags = flags;
            this.receiver = receiver;
            this.arguments = arguments;
            this.block = block;
        }
        
        public boolean isSafeNavigation() {
            return CallNodeFlags.isSafeNavigation(flags);
        }

        public boolean isVariableCall() {
            return CallNodeFlags.isVariableCall(flags);
        }

        public boolean isAttributeWrite() {
            return CallNodeFlags.isAttributeWrite(flags);
        }

        public boolean isIgnoreVisibility() {
            return CallNodeFlags.isIgnoreVisibility(flags);
        }
        
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            this.receiver.accept(visitor);
            if (this.arguments != null) {
                this.arguments.accept(visitor);
            }
            if (this.block != null) {
                this.block.accept(visitor);
            }
        }

        public Node[] childNodes() {
            return new Node[] { this.receiver, this.arguments, this.block };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitIndexTargetNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            builder.append(nextIndent);
            builder.append("CallNodeFlags: ");
            builder.append(flags);
            builder.append('\n');
            builder.append(nextIndent);
            builder.append("receiver: ");
            builder.append(this.receiver.toString(nextIndent));
            builder.append(nextIndent);
            builder.append("arguments: ");
            builder.append(this.arguments == null ? "null\n" : this.arguments.toString(nextIndent));
            builder.append(nextIndent);
            builder.append("block: ");
            builder.append(this.block == null ? "null\n" : this.block.toString(nextIndent));
            return builder.toString();
        }
    }

    /**
     * <pre>
     * Represents the use of the `&amp;&amp;=` operator for assignment to an instance variable.
     *
     *     &#64;target &amp;&amp;= value
     *     ^^^^^^^^^^^^^^^^^
     * </pre>
     */
    public static final class InstanceVariableAndWriteNode extends Node {
        public final String name;
        public final Node value;

        public InstanceVariableAndWriteNode(int startOffset, int length, String name, Node value) {
            super(startOffset, length);
            this.name = name;
            this.value = value;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            this.value.accept(visitor);
        }

        public Node[] childNodes() {
            return new Node[] { this.value };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitInstanceVariableAndWriteNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            builder.append(nextIndent);
            builder.append("name: ");
            builder.append('"').append(this.name).append('"');
            builder.append('\n');
            builder.append(nextIndent);
            builder.append("value: ");
            builder.append(this.value.toString(nextIndent));
            return builder.toString();
        }
    }

    /**
     * <pre>
     * Represents assigning to an instance variable using an operator that isn&#39;t `=`.
     *
     *     &#64;target += value
     *     ^^^^^^^^^^^^^^^^
     * </pre>
     */
    public static final class InstanceVariableOperatorWriteNode extends Node {
        public final String name;
        public final Node value;
        public final String binary_operator;

        public InstanceVariableOperatorWriteNode(int startOffset, int length, String name, Node value, String binary_operator) {
            super(startOffset, length);
            this.name = name;
            this.value = value;
            this.binary_operator = binary_operator;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            this.value.accept(visitor);
        }

        public Node[] childNodes() {
            return new Node[] { this.value };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitInstanceVariableOperatorWriteNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            builder.append(nextIndent);
            builder.append("name: ");
            builder.append('"').append(this.name).append('"');
            builder.append('\n');
            builder.append(nextIndent);
            builder.append("value: ");
            builder.append(this.value.toString(nextIndent));
            builder.append(nextIndent);
            builder.append("binary_operator: ");
            builder.append('"').append(this.binary_operator).append('"');
            builder.append('\n');
            return builder.toString();
        }
    }

    /**
     * <pre>
     * Represents the use of the `||=` operator for assignment to an instance variable.
     *
     *     &#64;target ||= value
     *     ^^^^^^^^^^^^^^^^^
     * </pre>
     */
    public static final class InstanceVariableOrWriteNode extends Node {
        public final String name;
        public final Node value;

        public InstanceVariableOrWriteNode(int startOffset, int length, String name, Node value) {
            super(startOffset, length);
            this.name = name;
            this.value = value;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            this.value.accept(visitor);
        }

        public Node[] childNodes() {
            return new Node[] { this.value };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitInstanceVariableOrWriteNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            builder.append(nextIndent);
            builder.append("name: ");
            builder.append('"').append(this.name).append('"');
            builder.append('\n');
            builder.append(nextIndent);
            builder.append("value: ");
            builder.append(this.value.toString(nextIndent));
            return builder.toString();
        }
    }

    /**
     * <pre>
     * Represents referencing an instance variable.
     *
     *     &#64;foo
     *     ^^^^
     * </pre>
     */
    public static final class InstanceVariableReadNode extends Node {
        /**
         * <pre>
         * The name of the instance variable, which is a `&#64;` followed by an [identifier](https://github.com/ruby/prism/blob/main/docs/parsing_rules.md#identifiers).
         *
         *     &#64;x     # name `:&#64;x`
         *
         *     &#64;_test # name `:&#64;_test`
         * </pre>
         */
        public final String name;

        public InstanceVariableReadNode(int startOffset, int length, String name) {
            super(startOffset, length);
            this.name = name;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
        }

        public Node[] childNodes() {
            return EMPTY_ARRAY;
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitInstanceVariableReadNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            builder.append(nextIndent);
            builder.append("name: ");
            builder.append('"').append(this.name).append('"');
            builder.append('\n');
            return builder.toString();
        }
    }

    /**
     * <pre>
     * Represents writing to an instance variable in a context that doesn&#39;t have an explicit value.
     *
     *     &#64;foo, &#64;bar = baz
     *     ^^^^  ^^^^
     * </pre>
     */
    public static final class InstanceVariableTargetNode extends Node {
        public final String name;

        public InstanceVariableTargetNode(int startOffset, int length, String name) {
            super(startOffset, length);
            this.name = name;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
        }

        public Node[] childNodes() {
            return EMPTY_ARRAY;
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitInstanceVariableTargetNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            builder.append(nextIndent);
            builder.append("name: ");
            builder.append('"').append(this.name).append('"');
            builder.append('\n');
            return builder.toString();
        }
    }

    /**
     * <pre>
     * Represents writing to an instance variable.
     *
     *     &#64;foo = 1
     *     ^^^^^^^^
     * </pre>
     */
    public static final class InstanceVariableWriteNode extends Node {
        /**
         * <pre>
         * The name of the instance variable, which is a `&#64;` followed by an [identifier](https://github.com/ruby/prism/blob/main/docs/parsing_rules.md#identifiers).
         *
         *     &#64;x = :y       # name `:&#64;x`
         *
         *     &#64;_foo = &quot;bar&quot; # name `&#64;_foo`
         * </pre>
         */
        public final String name;
        /**
         * <pre>
         * The value to write to the instance variable. It can be any [non-void expression](https://github.com/ruby/prism/blob/main/docs/parsing_rules.md#non-void-expression).
         *
         *     &#64;foo = :bar
         *            ^^^^
         *
         *     &#64;_x = 1234
         *           ^^^^
         * </pre>
         */
        public final Node value;

        public InstanceVariableWriteNode(int startOffset, int length, String name, Node value) {
            super(startOffset, length);
            this.name = name;
            this.value = value;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            this.value.accept(visitor);
        }

        public Node[] childNodes() {
            return new Node[] { this.value };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitInstanceVariableWriteNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            builder.append(nextIndent);
            builder.append("name: ");
            builder.append('"').append(this.name).append('"');
            builder.append('\n');
            builder.append(nextIndent);
            builder.append("value: ");
            builder.append(this.value.toString(nextIndent));
            return builder.toString();
        }
    }

    /**
     * <pre>
     * Represents an integer number literal.
     *
     *     1
     *     ^
     * </pre>
     */
    public static final class IntegerNode extends Node {
        public final short flags;
        /**
         * <pre>
         * The value of the integer literal as a number.
         * </pre>
         */
        public final Object value;

        public IntegerNode(int startOffset, int length, short flags, Object value) {
            super(startOffset, length);
            this.flags = flags;
            this.value = value;
        }
        
        public boolean isBinary() {
            return IntegerBaseFlags.isBinary(flags);
        }

        public boolean isDecimal() {
            return IntegerBaseFlags.isDecimal(flags);
        }

        public boolean isOctal() {
            return IntegerBaseFlags.isOctal(flags);
        }

        public boolean isHexadecimal() {
            return IntegerBaseFlags.isHexadecimal(flags);
        }
        
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
        }

        public Node[] childNodes() {
            return EMPTY_ARRAY;
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitIntegerNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            builder.append(nextIndent);
            builder.append("IntegerBaseFlags: ");
            builder.append(flags);
            builder.append('\n');
            builder.append(nextIndent);
            builder.append("value: ");
            builder.append(this.value);
            builder.append('\n');
            return builder.toString();
        }
    }

    /**
     * <pre>
     * Represents a regular expression literal that contains interpolation that is being used in the predicate of a conditional to implicitly match against the last line read by an IO object.
     *
     *     if /foo #{bar} baz/ then end
     *        ^^^^^^^^^^^^^^^^
     * </pre>
     */
    public static final class InterpolatedMatchLastLineNode extends Node {
        public final short flags;
        @UnionType({ StringNode.class, EmbeddedStatementsNode.class, EmbeddedVariableNode.class })
        public final Node[] parts;

        public InterpolatedMatchLastLineNode(int startOffset, int length, short flags, Node[] parts) {
            super(startOffset, length);
            this.flags = flags;
            this.parts = parts;
        }
        
        public boolean isIgnoreCase() {
            return RegularExpressionFlags.isIgnoreCase(flags);
        }

        public boolean isExtended() {
            return RegularExpressionFlags.isExtended(flags);
        }

        public boolean isMultiLine() {
            return RegularExpressionFlags.isMultiLine(flags);
        }

        public boolean isOnce() {
            return RegularExpressionFlags.isOnce(flags);
        }

        public boolean isEucJp() {
            return RegularExpressionFlags.isEucJp(flags);
        }

        public boolean isAscii8bit() {
            return RegularExpressionFlags.isAscii8bit(flags);
        }

        public boolean isWindows31j() {
            return RegularExpressionFlags.isWindows31j(flags);
        }

        public boolean isUtf8() {
            return RegularExpressionFlags.isUtf8(flags);
        }

        public boolean isForcedUtf8Encoding() {
            return RegularExpressionFlags.isForcedUtf8Encoding(flags);
        }

        public boolean isForcedBinaryEncoding() {
            return RegularExpressionFlags.isForcedBinaryEncoding(flags);
        }

        public boolean isForcedUsAsciiEncoding() {
            return RegularExpressionFlags.isForcedUsAsciiEncoding(flags);
        }
        
        @Override
        public void setNewLineFlag(Source source, boolean[] newlineMarked) {
            Node first = this.parts.length > 0 ? this.parts[0] : null;
            if (first != null) {
                first.setNewLineFlag(source, newlineMarked);
            }
        }

        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            for (Nodes.Node child : this.parts) {
                child.accept(visitor);
            }
        }

        public Node[] childNodes() {
            ArrayList<Node> childNodes = new ArrayList<>();
            childNodes.addAll(Arrays.asList(this.parts));
            return childNodes.toArray(EMPTY_ARRAY);
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitInterpolatedMatchLastLineNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            String nextNextIndent = nextIndent + "  ";
            builder.append(nextIndent);
            builder.append("RegularExpressionFlags: ");
            builder.append(flags);
            builder.append('\n');
            builder.append(nextIndent);
            builder.append("parts: ");
            builder.append('\n');
            for (Node child : this.parts) {
                builder.append(nextNextIndent).append(child.toString(nextNextIndent));
            }
            return builder.toString();
        }
    }

    /**
     * <pre>
     * Represents a regular expression literal that contains interpolation.
     *
     *     /foo #{bar} baz/
     *     ^^^^^^^^^^^^^^^^
     * </pre>
     */
    public static final class InterpolatedRegularExpressionNode extends Node {
        public final short flags;
        @UnionType({ StringNode.class, EmbeddedStatementsNode.class, EmbeddedVariableNode.class })
        public final Node[] parts;

        public InterpolatedRegularExpressionNode(int startOffset, int length, short flags, Node[] parts) {
            super(startOffset, length);
            this.flags = flags;
            this.parts = parts;
        }
        
        public boolean isIgnoreCase() {
            return RegularExpressionFlags.isIgnoreCase(flags);
        }

        public boolean isExtended() {
            return RegularExpressionFlags.isExtended(flags);
        }

        public boolean isMultiLine() {
            return RegularExpressionFlags.isMultiLine(flags);
        }

        public boolean isOnce() {
            return RegularExpressionFlags.isOnce(flags);
        }

        public boolean isEucJp() {
            return RegularExpressionFlags.isEucJp(flags);
        }

        public boolean isAscii8bit() {
            return RegularExpressionFlags.isAscii8bit(flags);
        }

        public boolean isWindows31j() {
            return RegularExpressionFlags.isWindows31j(flags);
        }

        public boolean isUtf8() {
            return RegularExpressionFlags.isUtf8(flags);
        }

        public boolean isForcedUtf8Encoding() {
            return RegularExpressionFlags.isForcedUtf8Encoding(flags);
        }

        public boolean isForcedBinaryEncoding() {
            return RegularExpressionFlags.isForcedBinaryEncoding(flags);
        }

        public boolean isForcedUsAsciiEncoding() {
            return RegularExpressionFlags.isForcedUsAsciiEncoding(flags);
        }
        
        @Override
        public void setNewLineFlag(Source source, boolean[] newlineMarked) {
            Node first = this.parts.length > 0 ? this.parts[0] : null;
            if (first != null) {
                first.setNewLineFlag(source, newlineMarked);
            }
        }

        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            for (Nodes.Node child : this.parts) {
                child.accept(visitor);
            }
        }

        public Node[] childNodes() {
            ArrayList<Node> childNodes = new ArrayList<>();
            childNodes.addAll(Arrays.asList(this.parts));
            return childNodes.toArray(EMPTY_ARRAY);
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitInterpolatedRegularExpressionNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            String nextNextIndent = nextIndent + "  ";
            builder.append(nextIndent);
            builder.append("RegularExpressionFlags: ");
            builder.append(flags);
            builder.append('\n');
            builder.append(nextIndent);
            builder.append("parts: ");
            builder.append('\n');
            for (Node child : this.parts) {
                builder.append(nextNextIndent).append(child.toString(nextNextIndent));
            }
            return builder.toString();
        }
    }

    /**
     * <pre>
     * Represents a string literal that contains interpolation.
     *
     *     &quot;foo #{bar} baz&quot;
     *     ^^^^^^^^^^^^^^^^
     * </pre>
     */
    public static final class InterpolatedStringNode extends Node {
        public final short flags;
        @UnionType({ StringNode.class, EmbeddedStatementsNode.class, EmbeddedVariableNode.class, InterpolatedStringNode.class })
        public final Node[] parts;

        public InterpolatedStringNode(int startOffset, int length, short flags, Node[] parts) {
            super(startOffset, length);
            this.flags = flags;
            this.parts = parts;
        }
        
        public boolean isFrozen() {
            return InterpolatedStringNodeFlags.isFrozen(flags);
        }

        public boolean isMutable() {
            return InterpolatedStringNodeFlags.isMutable(flags);
        }
        
        @Override
        public void setNewLineFlag(Source source, boolean[] newlineMarked) {
            Node first = this.parts.length > 0 ? this.parts[0] : null;
            if (first != null) {
                first.setNewLineFlag(source, newlineMarked);
            }
        }

        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            for (Nodes.Node child : this.parts) {
                child.accept(visitor);
            }
        }

        public Node[] childNodes() {
            ArrayList<Node> childNodes = new ArrayList<>();
            childNodes.addAll(Arrays.asList(this.parts));
            return childNodes.toArray(EMPTY_ARRAY);
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitInterpolatedStringNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            String nextNextIndent = nextIndent + "  ";
            builder.append(nextIndent);
            builder.append("InterpolatedStringNodeFlags: ");
            builder.append(flags);
            builder.append('\n');
            builder.append(nextIndent);
            builder.append("parts: ");
            builder.append('\n');
            for (Node child : this.parts) {
                builder.append(nextNextIndent).append(child.toString(nextNextIndent));
            }
            return builder.toString();
        }
    }

    /**
     * <pre>
     * Represents a symbol literal that contains interpolation.
     *
     *     :&quot;foo #{bar} baz&quot;
     *     ^^^^^^^^^^^^^^^^^
     * </pre>
     */
    public static final class InterpolatedSymbolNode extends Node {
        @UnionType({ StringNode.class, EmbeddedStatementsNode.class, EmbeddedVariableNode.class })
        public final Node[] parts;

        public InterpolatedSymbolNode(int startOffset, int length, Node[] parts) {
            super(startOffset, length);
            this.parts = parts;
        }
                
        @Override
        public void setNewLineFlag(Source source, boolean[] newlineMarked) {
            Node first = this.parts.length > 0 ? this.parts[0] : null;
            if (first != null) {
                first.setNewLineFlag(source, newlineMarked);
            }
        }

        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            for (Nodes.Node child : this.parts) {
                child.accept(visitor);
            }
        }

        public Node[] childNodes() {
            ArrayList<Node> childNodes = new ArrayList<>();
            childNodes.addAll(Arrays.asList(this.parts));
            return childNodes.toArray(EMPTY_ARRAY);
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitInterpolatedSymbolNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            String nextNextIndent = nextIndent + "  ";
            builder.append(nextIndent);
            builder.append("parts: ");
            builder.append('\n');
            for (Node child : this.parts) {
                builder.append(nextNextIndent).append(child.toString(nextNextIndent));
            }
            return builder.toString();
        }
    }

    /**
     * <pre>
     * Represents an xstring literal that contains interpolation.
     *
     *     `foo #{bar} baz`
     *     ^^^^^^^^^^^^^^^^
     * </pre>
     */
    public static final class InterpolatedXStringNode extends Node {
        @UnionType({ StringNode.class, EmbeddedStatementsNode.class, EmbeddedVariableNode.class })
        public final Node[] parts;

        public InterpolatedXStringNode(int startOffset, int length, Node[] parts) {
            super(startOffset, length);
            this.parts = parts;
        }
                
        @Override
        public void setNewLineFlag(Source source, boolean[] newlineMarked) {
            Node first = this.parts.length > 0 ? this.parts[0] : null;
            if (first != null) {
                first.setNewLineFlag(source, newlineMarked);
            }
        }

        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            for (Nodes.Node child : this.parts) {
                child.accept(visitor);
            }
        }

        public Node[] childNodes() {
            ArrayList<Node> childNodes = new ArrayList<>();
            childNodes.addAll(Arrays.asList(this.parts));
            return childNodes.toArray(EMPTY_ARRAY);
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitInterpolatedXStringNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            String nextNextIndent = nextIndent + "  ";
            builder.append(nextIndent);
            builder.append("parts: ");
            builder.append('\n');
            for (Node child : this.parts) {
                builder.append(nextNextIndent).append(child.toString(nextNextIndent));
            }
            return builder.toString();
        }
    }

    /**
     * <pre>
     * Represents reading from the implicit `it` local variable.
     *
     *     -&gt; { it }
     *          ^^
     * </pre>
     */
    public static final class ItLocalVariableReadNode extends Node {

        public ItLocalVariableReadNode(int startOffset, int length) {
            super(startOffset, length);
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
        }

        public Node[] childNodes() {
            return EMPTY_ARRAY;
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitItLocalVariableReadNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            return builder.toString();
        }
    }

    /**
     * <pre>
     * Represents an implicit set of parameters through the use of the `it` keyword within a block or lambda.
     *
     *     -&gt; { it + it }
     *     ^^^^^^^^^^^^^^
     * </pre>
     */
    public static final class ItParametersNode extends Node {

        public ItParametersNode(int startOffset, int length) {
            super(startOffset, length);
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
        }

        public Node[] childNodes() {
            return EMPTY_ARRAY;
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitItParametersNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            return builder.toString();
        }
    }

    /**
     * <pre>
     * Represents a hash literal without opening and closing braces.
     *
     *     foo(a: b)
     *         ^^^^
     * </pre>
     */
    public static final class KeywordHashNode extends Node {
        public final short flags;
        @UnionType({ AssocNode.class, AssocSplatNode.class })
        public final Node[] elements;

        public KeywordHashNode(int startOffset, int length, short flags, Node[] elements) {
            super(startOffset, length);
            this.flags = flags;
            this.elements = elements;
        }
        
        public boolean isSymbolKeys() {
            return KeywordHashNodeFlags.isSymbolKeys(flags);
        }
        
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            for (Nodes.Node child : this.elements) {
                child.accept(visitor);
            }
        }

        public Node[] childNodes() {
            ArrayList<Node> childNodes = new ArrayList<>();
            childNodes.addAll(Arrays.asList(this.elements));
            return childNodes.toArray(EMPTY_ARRAY);
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitKeywordHashNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            String nextNextIndent = nextIndent + "  ";
            builder.append(nextIndent);
            builder.append("KeywordHashNodeFlags: ");
            builder.append(flags);
            builder.append('\n');
            builder.append(nextIndent);
            builder.append("elements: ");
            builder.append('\n');
            for (Node child : this.elements) {
                builder.append(nextNextIndent).append(child.toString(nextNextIndent));
            }
            return builder.toString();
        }
    }

    /**
     * <pre>
     * Represents a keyword rest parameter to a method, block, or lambda definition.
     *
     *     def a(**b)
     *           ^^^
     *     end
     * </pre>
     */
    public static final class KeywordRestParameterNode extends Node {
        public final short flags;
        @Nullable
        public final String name;

        public KeywordRestParameterNode(int startOffset, int length, short flags, String name) {
            super(startOffset, length);
            this.flags = flags;
            this.name = name;
        }
        
        public boolean isRepeatedParameter() {
            return ParameterFlags.isRepeatedParameter(flags);
        }
        
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
        }

        public Node[] childNodes() {
            return EMPTY_ARRAY;
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitKeywordRestParameterNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            builder.append(nextIndent);
            builder.append("ParameterFlags: ");
            builder.append(flags);
            builder.append('\n');
            builder.append(nextIndent);
            builder.append("name: ");
            builder.append(this.name == null ? "null" : "\"" + this.name + "\"");
            builder.append('\n');
            return builder.toString();
        }
    }

    /**
     * <pre>
     * Represents using a lambda literal (not the lambda method call).
     *
     *     -&gt;(value) { value * 2 }
     *     ^^^^^^^^^^^^^^^^^^^^^^^
     * </pre>
     */
    public static final class LambdaNode extends Node {
        public final String[] locals;
        @Nullable
        public final Node parameters;
        @Nullable
        public final Node body;

        public LambdaNode(int startOffset, int length, String[] locals, Node parameters, Node body) {
            super(startOffset, length);
            this.locals = locals;
            this.parameters = parameters;
            this.body = body;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            if (this.parameters != null) {
                this.parameters.accept(visitor);
            }
            if (this.body != null) {
                this.body.accept(visitor);
            }
        }

        public Node[] childNodes() {
            return new Node[] { this.parameters, this.body };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitLambdaNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            String nextNextIndent = nextIndent + "  ";
            builder.append(nextIndent);
            builder.append("locals: ");
            builder.append('\n');
            for (String constant : this.locals) {
                builder.append(nextNextIndent).append('"').append(constant).append('"').append('\n');
            }
            builder.append(nextIndent);
            builder.append("parameters: ");
            builder.append(this.parameters == null ? "null\n" : this.parameters.toString(nextIndent));
            builder.append(nextIndent);
            builder.append("body: ");
            builder.append(this.body == null ? "null\n" : this.body.toString(nextIndent));
            return builder.toString();
        }
    }

    /**
     * <pre>
     * Represents the use of the `&amp;&amp;=` operator for assignment to a local variable.
     *
     *     target &amp;&amp;= value
     *     ^^^^^^^^^^^^^^^^
     * </pre>
     */
    public static final class LocalVariableAndWriteNode extends Node {
        public final Node value;
        public final String name;
        public final int depth;

        public LocalVariableAndWriteNode(int startOffset, int length, Node value, String name, int depth) {
            super(startOffset, length);
            this.value = value;
            this.name = name;
            this.depth = depth;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            this.value.accept(visitor);
        }

        public Node[] childNodes() {
            return new Node[] { this.value };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitLocalVariableAndWriteNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            builder.append(nextIndent);
            builder.append("value: ");
            builder.append(this.value.toString(nextIndent));
            builder.append(nextIndent);
            builder.append("name: ");
            builder.append('"').append(this.name).append('"');
            builder.append('\n');
            builder.append(nextIndent);
            builder.append("depth: ");
            builder.append(this.depth);
            builder.append('\n');
            return builder.toString();
        }
    }

    /**
     * <pre>
     * Represents assigning to a local variable using an operator that isn&#39;t `=`.
     *
     *     target += value
     *     ^^^^^^^^^^^^^^^
     * </pre>
     */
    public static final class LocalVariableOperatorWriteNode extends Node {
        public final Node value;
        public final String name;
        public final String binary_operator;
        public final int depth;

        public LocalVariableOperatorWriteNode(int startOffset, int length, Node value, String name, String binary_operator, int depth) {
            super(startOffset, length);
            this.value = value;
            this.name = name;
            this.binary_operator = binary_operator;
            this.depth = depth;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            this.value.accept(visitor);
        }

        public Node[] childNodes() {
            return new Node[] { this.value };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitLocalVariableOperatorWriteNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            builder.append(nextIndent);
            builder.append("value: ");
            builder.append(this.value.toString(nextIndent));
            builder.append(nextIndent);
            builder.append("name: ");
            builder.append('"').append(this.name).append('"');
            builder.append('\n');
            builder.append(nextIndent);
            builder.append("binary_operator: ");
            builder.append('"').append(this.binary_operator).append('"');
            builder.append('\n');
            builder.append(nextIndent);
            builder.append("depth: ");
            builder.append(this.depth);
            builder.append('\n');
            return builder.toString();
        }
    }

    /**
     * <pre>
     * Represents the use of the `||=` operator for assignment to a local variable.
     *
     *     target ||= value
     *     ^^^^^^^^^^^^^^^^
     * </pre>
     */
    public static final class LocalVariableOrWriteNode extends Node {
        public final Node value;
        public final String name;
        public final int depth;

        public LocalVariableOrWriteNode(int startOffset, int length, Node value, String name, int depth) {
            super(startOffset, length);
            this.value = value;
            this.name = name;
            this.depth = depth;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            this.value.accept(visitor);
        }

        public Node[] childNodes() {
            return new Node[] { this.value };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitLocalVariableOrWriteNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            builder.append(nextIndent);
            builder.append("value: ");
            builder.append(this.value.toString(nextIndent));
            builder.append(nextIndent);
            builder.append("name: ");
            builder.append('"').append(this.name).append('"');
            builder.append('\n');
            builder.append(nextIndent);
            builder.append("depth: ");
            builder.append(this.depth);
            builder.append('\n');
            return builder.toString();
        }
    }

    /**
     * <pre>
     * Represents reading a local variable. Note that this requires that a local variable of the same name has already been written to in the same scope, otherwise it is parsed as a method call.
     *
     *     foo
     *     ^^^
     * </pre>
     */
    public static final class LocalVariableReadNode extends Node {
        /**
         * <pre>
         * The name of the local variable, which is an [identifier](https://github.com/ruby/prism/blob/main/docs/parsing_rules.md#identifiers).
         *
         *     x      # name `:x`
         *
         *     _Test  # name `:_Test`
         *
         * Note that this can also be an underscore followed by a number for the default block parameters.
         *
         *     _1     # name `:_1`
         * </pre>
         */
        public final String name;
        /**
         * <pre>
         * The number of visible scopes that should be searched to find the origin of this local variable.
         *
         *     foo = 1; foo # depth 0
         *
         *     bar = 2; tap { bar } # depth 1
         *
         * The specific rules for calculating the depth may differ from individual Ruby implementations, as they are not specified by the language. For more information, see [the Prism documentation](https://github.com/ruby/prism/blob/main/docs/local_variable_depth.md).
         * </pre>
         */
        public final int depth;

        public LocalVariableReadNode(int startOffset, int length, String name, int depth) {
            super(startOffset, length);
            this.name = name;
            this.depth = depth;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
        }

        public Node[] childNodes() {
            return EMPTY_ARRAY;
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitLocalVariableReadNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            builder.append(nextIndent);
            builder.append("name: ");
            builder.append('"').append(this.name).append('"');
            builder.append('\n');
            builder.append(nextIndent);
            builder.append("depth: ");
            builder.append(this.depth);
            builder.append('\n');
            return builder.toString();
        }
    }

    /**
     * <pre>
     * Represents writing to a local variable in a context that doesn&#39;t have an explicit value.
     *
     *     foo, bar = baz
     *     ^^^  ^^^
     * </pre>
     */
    public static final class LocalVariableTargetNode extends Node {
        public final String name;
        public final int depth;

        public LocalVariableTargetNode(int startOffset, int length, String name, int depth) {
            super(startOffset, length);
            this.name = name;
            this.depth = depth;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
        }

        public Node[] childNodes() {
            return EMPTY_ARRAY;
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitLocalVariableTargetNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            builder.append(nextIndent);
            builder.append("name: ");
            builder.append('"').append(this.name).append('"');
            builder.append('\n');
            builder.append(nextIndent);
            builder.append("depth: ");
            builder.append(this.depth);
            builder.append('\n');
            return builder.toString();
        }
    }

    /**
     * <pre>
     * Represents writing to a local variable.
     *
     *     foo = 1
     *     ^^^^^^^
     * </pre>
     */
    public static final class LocalVariableWriteNode extends Node {
        /**
         * <pre>
         * The name of the local variable, which is an [identifier](https://github.com/ruby/prism/blob/main/docs/parsing_rules.md#identifiers).
         *
         *     foo = :bar # name `:foo`
         *
         *     abc = 123  # name `:abc`
         * </pre>
         */
        public final String name;
        /**
         * <pre>
         * The number of semantic scopes we have to traverse to find the declaration of this variable.
         *
         *     foo = 1         # depth 0
         *
         *     tap { foo = 1 } # depth 1
         *
         * The specific rules for calculating the depth may differ from individual Ruby implementations, as they are not specified by the language. For more information, see [the Prism documentation](https://github.com/ruby/prism/blob/main/docs/local_variable_depth.md).
         * </pre>
         */
        public final int depth;
        /**
         * <pre>
         * The value to write to the local variable. It can be any [non-void expression](https://github.com/ruby/prism/blob/main/docs/parsing_rules.md#non-void-expression).
         *
         *     foo = :bar
         *           ^^^^
         *
         *     abc = 1234
         *           ^^^^
         *
         * Note that since the name of a local variable is known before the value is parsed, it is valid for a local variable to appear within the value of its own write.
         *
         *     foo = foo
         * </pre>
         */
        public final Node value;

        public LocalVariableWriteNode(int startOffset, int length, String name, int depth, Node value) {
            super(startOffset, length);
            this.name = name;
            this.depth = depth;
            this.value = value;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            this.value.accept(visitor);
        }

        public Node[] childNodes() {
            return new Node[] { this.value };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitLocalVariableWriteNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            builder.append(nextIndent);
            builder.append("name: ");
            builder.append('"').append(this.name).append('"');
            builder.append('\n');
            builder.append(nextIndent);
            builder.append("depth: ");
            builder.append(this.depth);
            builder.append('\n');
            builder.append(nextIndent);
            builder.append("value: ");
            builder.append(this.value.toString(nextIndent));
            return builder.toString();
        }
    }

    /**
     * <pre>
     * Represents a regular expression literal used in the predicate of a conditional to implicitly match against the last line read by an IO object.
     *
     *     if /foo/i then end
     *        ^^^^^^
     * </pre>
     */
    public static final class MatchLastLineNode extends Node {
        public final short flags;
        public final byte[] unescaped;

        public MatchLastLineNode(int startOffset, int length, short flags, byte[] unescaped) {
            super(startOffset, length);
            this.flags = flags;
            this.unescaped = unescaped;
        }
        
        public boolean isIgnoreCase() {
            return RegularExpressionFlags.isIgnoreCase(flags);
        }

        public boolean isExtended() {
            return RegularExpressionFlags.isExtended(flags);
        }

        public boolean isMultiLine() {
            return RegularExpressionFlags.isMultiLine(flags);
        }

        public boolean isOnce() {
            return RegularExpressionFlags.isOnce(flags);
        }

        public boolean isEucJp() {
            return RegularExpressionFlags.isEucJp(flags);
        }

        public boolean isAscii8bit() {
            return RegularExpressionFlags.isAscii8bit(flags);
        }

        public boolean isWindows31j() {
            return RegularExpressionFlags.isWindows31j(flags);
        }

        public boolean isUtf8() {
            return RegularExpressionFlags.isUtf8(flags);
        }

        public boolean isForcedUtf8Encoding() {
            return RegularExpressionFlags.isForcedUtf8Encoding(flags);
        }

        public boolean isForcedBinaryEncoding() {
            return RegularExpressionFlags.isForcedBinaryEncoding(flags);
        }

        public boolean isForcedUsAsciiEncoding() {
            return RegularExpressionFlags.isForcedUsAsciiEncoding(flags);
        }
        
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
        }

        public Node[] childNodes() {
            return EMPTY_ARRAY;
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitMatchLastLineNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            builder.append(nextIndent);
            builder.append("RegularExpressionFlags: ");
            builder.append(flags);
            builder.append('\n');
            builder.append(nextIndent);
            builder.append("unescaped: ");
            builder.append('"' + new String(this.unescaped, StandardCharsets.UTF_8) + '"');
            builder.append('\n');
            return builder.toString();
        }
    }

    /**
     * <pre>
     * Represents the use of the modifier `in` operator.
     *
     *     foo in bar
     *     ^^^^^^^^^^
     * </pre>
     */
    public static final class MatchPredicateNode extends Node {
        public final Node value;
        public final Node pattern;

        public MatchPredicateNode(int startOffset, int length, Node value, Node pattern) {
            super(startOffset, length);
            this.value = value;
            this.pattern = pattern;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            this.value.accept(visitor);
            this.pattern.accept(visitor);
        }

        public Node[] childNodes() {
            return new Node[] { this.value, this.pattern };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitMatchPredicateNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            builder.append(nextIndent);
            builder.append("value: ");
            builder.append(this.value.toString(nextIndent));
            builder.append(nextIndent);
            builder.append("pattern: ");
            builder.append(this.pattern.toString(nextIndent));
            return builder.toString();
        }
    }

    /**
     * <pre>
     * Represents the use of the `=&gt;` operator.
     *
     *     foo =&gt; bar
     *     ^^^^^^^^^^
     * </pre>
     */
    public static final class MatchRequiredNode extends Node {
        public final Node value;
        public final Node pattern;

        public MatchRequiredNode(int startOffset, int length, Node value, Node pattern) {
            super(startOffset, length);
            this.value = value;
            this.pattern = pattern;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            this.value.accept(visitor);
            this.pattern.accept(visitor);
        }

        public Node[] childNodes() {
            return new Node[] { this.value, this.pattern };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitMatchRequiredNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            builder.append(nextIndent);
            builder.append("value: ");
            builder.append(this.value.toString(nextIndent));
            builder.append(nextIndent);
            builder.append("pattern: ");
            builder.append(this.pattern.toString(nextIndent));
            return builder.toString();
        }
    }

    /**
     * <pre>
     * Represents writing local variables using a regular expression match with named capture groups.
     *
     *     /(?&lt;foo&gt;bar)/ =~ baz
     *     ^^^^^^^^^^^^^^^^^^^^
     * </pre>
     */
    public static final class MatchWriteNode extends Node {
        public final CallNode call;
        public final LocalVariableTargetNode[] targets;

        public MatchWriteNode(int startOffset, int length, CallNode call, LocalVariableTargetNode[] targets) {
            super(startOffset, length);
            this.call = call;
            this.targets = targets;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            this.call.accept(visitor);
            for (Nodes.Node child : this.targets) {
                child.accept(visitor);
            }
        }

        public Node[] childNodes() {
            ArrayList<Node> childNodes = new ArrayList<>();
            childNodes.add(this.call);
            childNodes.addAll(Arrays.asList(this.targets));
            return childNodes.toArray(EMPTY_ARRAY);
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitMatchWriteNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            String nextNextIndent = nextIndent + "  ";
            builder.append(nextIndent);
            builder.append("call: ");
            builder.append(this.call.toString(nextIndent));
            builder.append(nextIndent);
            builder.append("targets: ");
            builder.append('\n');
            for (Node child : this.targets) {
                builder.append(nextNextIndent).append(child.toString(nextNextIndent));
            }
            return builder.toString();
        }
    }

    /**
     * <pre>
     * Represents a node that is missing from the source and results in a syntax error.
     * </pre>
     */
    public static final class MissingNode extends Node {

        public MissingNode(int startOffset, int length) {
            super(startOffset, length);
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
        }

        public Node[] childNodes() {
            return EMPTY_ARRAY;
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitMissingNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            return builder.toString();
        }
    }

    /**
     * <pre>
     * Represents a module declaration involving the `module` keyword.
     *
     *     module Foo end
     *     ^^^^^^^^^^^^^^
     * </pre>
     */
    public static final class ModuleNode extends Node {
        public final String[] locals;
        public final Node constant_path;
        @Nullable
        public final Node body;
        public final String name;

        public ModuleNode(int startOffset, int length, String[] locals, Node constant_path, Node body, String name) {
            super(startOffset, length);
            this.locals = locals;
            this.constant_path = constant_path;
            this.body = body;
            this.name = name;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            this.constant_path.accept(visitor);
            if (this.body != null) {
                this.body.accept(visitor);
            }
        }

        public Node[] childNodes() {
            return new Node[] { this.constant_path, this.body };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitModuleNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            String nextNextIndent = nextIndent + "  ";
            builder.append(nextIndent);
            builder.append("locals: ");
            builder.append('\n');
            for (String constant : this.locals) {
                builder.append(nextNextIndent).append('"').append(constant).append('"').append('\n');
            }
            builder.append(nextIndent);
            builder.append("constant_path: ");
            builder.append(this.constant_path.toString(nextIndent));
            builder.append(nextIndent);
            builder.append("body: ");
            builder.append(this.body == null ? "null\n" : this.body.toString(nextIndent));
            builder.append(nextIndent);
            builder.append("name: ");
            builder.append('"').append(this.name).append('"');
            builder.append('\n');
            return builder.toString();
        }
    }

    /**
     * <pre>
     * Represents a multi-target expression.
     *
     *     a, (b, c) = 1, 2, 3
     *        ^^^^^^
     *
     * This can be a part of `MultiWriteNode` as above, or the target of a `for` loop
     *
     *     for a, b in [[1, 2], [3, 4]]
     *         ^^^^
     * </pre>
     */
    public static final class MultiTargetNode extends Node {
        /**
         * <pre>
         * Represents the targets expressions before a splat node.
         *
         *     a, (b, c, *) = 1, 2, 3, 4, 5
         *         ^^^^
         *
         * The splat node can be absent, in that case all target expressions are in the left field.
         *
         *     a, (b, c) = 1, 2, 3, 4, 5
         *         ^^^^
         * </pre>
         */
        @UnionType({ LocalVariableTargetNode.class, InstanceVariableTargetNode.class, ClassVariableTargetNode.class, GlobalVariableTargetNode.class, ConstantTargetNode.class, ConstantPathTargetNode.class, CallTargetNode.class, IndexTargetNode.class, MultiTargetNode.class, RequiredParameterNode.class, BackReferenceReadNode.class, NumberedReferenceReadNode.class })
        public final Node[] lefts;
        /**
         * <pre>
         * Represents a splat node in the target expression.
         *
         *     a, (b, *c) = 1, 2, 3, 4
         *            ^^
         *
         * The variable can be empty, this results in a `SplatNode` with a `nil` expression field.
         *
         *     a, (b, *) = 1, 2, 3, 4
         *            ^
         *
         * If the `*` is omitted, the field will containt an `ImplicitRestNode`
         *
         *     a, (b,) = 1, 2, 3, 4
         *          ^
         * </pre>
         */
        @Nullable
        @UnionType({ ImplicitRestNode.class, SplatNode.class })
        public final Node rest;
        /**
         * <pre>
         * Represents the targets expressions after a splat node.
         *
         *     a, (*, b, c) = 1, 2, 3, 4, 5
         *            ^^^^
         * </pre>
         */
        @UnionType({ LocalVariableTargetNode.class, InstanceVariableTargetNode.class, ClassVariableTargetNode.class, GlobalVariableTargetNode.class, ConstantTargetNode.class, ConstantPathTargetNode.class, CallTargetNode.class, IndexTargetNode.class, MultiTargetNode.class, RequiredParameterNode.class, BackReferenceReadNode.class })
        public final Node[] rights;

        public MultiTargetNode(int startOffset, int length, Node[] lefts, Node rest, Node[] rights) {
            super(startOffset, length);
            this.lefts = lefts;
            this.rest = rest;
            this.rights = rights;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            for (Nodes.Node child : this.lefts) {
                child.accept(visitor);
            }
            if (this.rest != null) {
                this.rest.accept(visitor);
            }
            for (Nodes.Node child : this.rights) {
                child.accept(visitor);
            }
        }

        public Node[] childNodes() {
            ArrayList<Node> childNodes = new ArrayList<>();
            childNodes.addAll(Arrays.asList(this.lefts));
            childNodes.add(this.rest);
            childNodes.addAll(Arrays.asList(this.rights));
            return childNodes.toArray(EMPTY_ARRAY);
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitMultiTargetNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            String nextNextIndent = nextIndent + "  ";
            builder.append(nextIndent);
            builder.append("lefts: ");
            builder.append('\n');
            for (Node child : this.lefts) {
                builder.append(nextNextIndent).append(child.toString(nextNextIndent));
            }
            builder.append(nextIndent);
            builder.append("rest: ");
            builder.append(this.rest == null ? "null\n" : this.rest.toString(nextIndent));
            builder.append(nextIndent);
            builder.append("rights: ");
            builder.append('\n');
            for (Node child : this.rights) {
                builder.append(nextNextIndent).append(child.toString(nextNextIndent));
            }
            return builder.toString();
        }
    }

    /**
     * <pre>
     * Represents a write to a multi-target expression.
     *
     *     a, b, c = 1, 2, 3
     *     ^^^^^^^^^^^^^^^^^
     * </pre>
     */
    public static final class MultiWriteNode extends Node {
        /**
         * <pre>
         * Represents the targets expressions before a splat node.
         *
         *     a, b, * = 1, 2, 3, 4, 5
         *     ^^^^
         *
         * The splat node can be absent, in that case all target expressions are in the left field.
         *
         *     a, b, c = 1, 2, 3, 4, 5
         *     ^^^^^^^
         * </pre>
         */
        @UnionType({ LocalVariableTargetNode.class, InstanceVariableTargetNode.class, ClassVariableTargetNode.class, GlobalVariableTargetNode.class, ConstantTargetNode.class, ConstantPathTargetNode.class, CallTargetNode.class, IndexTargetNode.class, MultiTargetNode.class })
        public final Node[] lefts;
        /**
         * <pre>
         * Represents a splat node in the target expression.
         *
         *     a, b, *c = 1, 2, 3, 4
         *           ^^
         *
         * The variable can be empty, this results in a `SplatNode` with a `nil` expression field.
         *
         *     a, b, * = 1, 2, 3, 4
         *           ^
         *
         * If the `*` is omitted, the field will containt an `ImplicitRestNode`
         *
         *     a, b, = 1, 2, 3, 4
         *         ^
         * </pre>
         */
        @Nullable
        @UnionType({ ImplicitRestNode.class, SplatNode.class })
        public final Node rest;
        /**
         * <pre>
         * Represents the targets expressions after a splat node.
         *
         *     a, *, b, c = 1, 2, 3, 4, 5
         *           ^^^^
         * </pre>
         */
        @UnionType({ LocalVariableTargetNode.class, InstanceVariableTargetNode.class, ClassVariableTargetNode.class, GlobalVariableTargetNode.class, ConstantTargetNode.class, ConstantPathTargetNode.class, CallTargetNode.class, IndexTargetNode.class, MultiTargetNode.class })
        public final Node[] rights;
        /**
         * <pre>
         * The value to write to the targets. It can be any [non-void expression](https://github.com/ruby/prism/blob/main/docs/parsing_rules.md#non-void-expression).
         *
         *     a, b, c = 1, 2, 3
         *               ^^^^^^^
         * </pre>
         */
        public final Node value;

        public MultiWriteNode(int startOffset, int length, Node[] lefts, Node rest, Node[] rights, Node value) {
            super(startOffset, length);
            this.lefts = lefts;
            this.rest = rest;
            this.rights = rights;
            this.value = value;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            for (Nodes.Node child : this.lefts) {
                child.accept(visitor);
            }
            if (this.rest != null) {
                this.rest.accept(visitor);
            }
            for (Nodes.Node child : this.rights) {
                child.accept(visitor);
            }
            this.value.accept(visitor);
        }

        public Node[] childNodes() {
            ArrayList<Node> childNodes = new ArrayList<>();
            childNodes.addAll(Arrays.asList(this.lefts));
            childNodes.add(this.rest);
            childNodes.addAll(Arrays.asList(this.rights));
            childNodes.add(this.value);
            return childNodes.toArray(EMPTY_ARRAY);
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitMultiWriteNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            String nextNextIndent = nextIndent + "  ";
            builder.append(nextIndent);
            builder.append("lefts: ");
            builder.append('\n');
            for (Node child : this.lefts) {
                builder.append(nextNextIndent).append(child.toString(nextNextIndent));
            }
            builder.append(nextIndent);
            builder.append("rest: ");
            builder.append(this.rest == null ? "null\n" : this.rest.toString(nextIndent));
            builder.append(nextIndent);
            builder.append("rights: ");
            builder.append('\n');
            for (Node child : this.rights) {
                builder.append(nextNextIndent).append(child.toString(nextNextIndent));
            }
            builder.append(nextIndent);
            builder.append("value: ");
            builder.append(this.value.toString(nextIndent));
            return builder.toString();
        }
    }

    /**
     * <pre>
     * Represents the use of the `next` keyword.
     *
     *     next 1
     *     ^^^^^^
     * </pre>
     */
    public static final class NextNode extends Node {
        @Nullable
        public final ArgumentsNode arguments;

        public NextNode(int startOffset, int length, ArgumentsNode arguments) {
            super(startOffset, length);
            this.arguments = arguments;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            if (this.arguments != null) {
                this.arguments.accept(visitor);
            }
        }

        public Node[] childNodes() {
            return new Node[] { this.arguments };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitNextNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            builder.append(nextIndent);
            builder.append("arguments: ");
            builder.append(this.arguments == null ? "null\n" : this.arguments.toString(nextIndent));
            return builder.toString();
        }
    }

    /**
     * <pre>
     * Represents the use of the `nil` keyword.
     *
     *     nil
     *     ^^^
     * </pre>
     */
    public static final class NilNode extends Node {

        public NilNode(int startOffset, int length) {
            super(startOffset, length);
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
        }

        public Node[] childNodes() {
            return EMPTY_ARRAY;
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitNilNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            return builder.toString();
        }
    }

    /**
     * <pre>
     * Represents the use of `**nil` inside method arguments.
     *
     *     def a(**nil)
     *           ^^^^^
     *     end
     * </pre>
     */
    public static final class NoKeywordsParameterNode extends Node {

        public NoKeywordsParameterNode(int startOffset, int length) {
            super(startOffset, length);
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
        }

        public Node[] childNodes() {
            return EMPTY_ARRAY;
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitNoKeywordsParameterNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            return builder.toString();
        }
    }

    /**
     * <pre>
     * Represents an implicit set of parameters through the use of numbered parameters within a block or lambda.
     *
     *     -&gt; { _1 + _2 }
     *     ^^^^^^^^^^^^^^
     * </pre>
     */
    public static final class NumberedParametersNode extends Node {
        public final int maximum;

        public NumberedParametersNode(int startOffset, int length, int maximum) {
            super(startOffset, length);
            this.maximum = maximum;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
        }

        public Node[] childNodes() {
            return EMPTY_ARRAY;
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitNumberedParametersNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            builder.append(nextIndent);
            builder.append("maximum: ");
            builder.append(this.maximum);
            builder.append('\n');
            return builder.toString();
        }
    }

    /**
     * <pre>
     * Represents reading a numbered reference to a capture in the previous match.
     *
     *     $1
     *     ^^
     * </pre>
     */
    public static final class NumberedReferenceReadNode extends Node {
        /**
         * <pre>
         * The (1-indexed, from the left) number of the capture group. Numbered references that are too large result in this value being `0`.
         *
         *     $1          # number `1`
         *
         *     $5432       # number `5432`
         *
         *     $4294967296 # number `0`
         * </pre>
         */
        public final int number;

        public NumberedReferenceReadNode(int startOffset, int length, int number) {
            super(startOffset, length);
            this.number = number;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
        }

        public Node[] childNodes() {
            return EMPTY_ARRAY;
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitNumberedReferenceReadNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            builder.append(nextIndent);
            builder.append("number: ");
            builder.append(this.number);
            builder.append('\n');
            return builder.toString();
        }
    }

    /**
     * <pre>
     * Represents an optional keyword parameter to a method, block, or lambda definition.
     *
     *     def a(b: 1)
     *           ^^^^
     *     end
     * </pre>
     */
    public static final class OptionalKeywordParameterNode extends Node {
        public final short flags;
        public final String name;
        public final Node value;

        public OptionalKeywordParameterNode(int startOffset, int length, short flags, String name, Node value) {
            super(startOffset, length);
            this.flags = flags;
            this.name = name;
            this.value = value;
        }
        
        public boolean isRepeatedParameter() {
            return ParameterFlags.isRepeatedParameter(flags);
        }
        
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            this.value.accept(visitor);
        }

        public Node[] childNodes() {
            return new Node[] { this.value };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitOptionalKeywordParameterNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            builder.append(nextIndent);
            builder.append("ParameterFlags: ");
            builder.append(flags);
            builder.append('\n');
            builder.append(nextIndent);
            builder.append("name: ");
            builder.append('"').append(this.name).append('"');
            builder.append('\n');
            builder.append(nextIndent);
            builder.append("value: ");
            builder.append(this.value.toString(nextIndent));
            return builder.toString();
        }
    }

    /**
     * <pre>
     * Represents an optional parameter to a method, block, or lambda definition.
     *
     *     def a(b = 1)
     *           ^^^^^
     *     end
     * </pre>
     */
    public static final class OptionalParameterNode extends Node {
        public final short flags;
        public final String name;
        public final Node value;

        public OptionalParameterNode(int startOffset, int length, short flags, String name, Node value) {
            super(startOffset, length);
            this.flags = flags;
            this.name = name;
            this.value = value;
        }
        
        public boolean isRepeatedParameter() {
            return ParameterFlags.isRepeatedParameter(flags);
        }
        
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            this.value.accept(visitor);
        }

        public Node[] childNodes() {
            return new Node[] { this.value };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitOptionalParameterNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            builder.append(nextIndent);
            builder.append("ParameterFlags: ");
            builder.append(flags);
            builder.append('\n');
            builder.append(nextIndent);
            builder.append("name: ");
            builder.append('"').append(this.name).append('"');
            builder.append('\n');
            builder.append(nextIndent);
            builder.append("value: ");
            builder.append(this.value.toString(nextIndent));
            return builder.toString();
        }
    }

    /**
     * <pre>
     * Represents the use of the `||` operator or the `or` keyword.
     *
     *     left or right
     *     ^^^^^^^^^^^^^
     * </pre>
     */
    public static final class OrNode extends Node {
        /**
         * <pre>
         * Represents the left side of the expression. It can be any [non-void expression](https://github.com/ruby/prism/blob/main/docs/parsing_rules.md#non-void-expression).
         *
         *     left or right
         *     ^^^^
         *
         *     1 || 2
         *     ^
         * </pre>
         */
        public final Node left;
        /**
         * <pre>
         * Represents the right side of the expression. It can be any [non-void expression](https://github.com/ruby/prism/blob/main/docs/parsing_rules.md#non-void-expression).
         *
         *     left || right
         *             ^^^^^
         *
         *     1 or 2
         *          ^
         * </pre>
         */
        public final Node right;

        public OrNode(int startOffset, int length, Node left, Node right) {
            super(startOffset, length);
            this.left = left;
            this.right = right;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            this.left.accept(visitor);
            this.right.accept(visitor);
        }

        public Node[] childNodes() {
            return new Node[] { this.left, this.right };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitOrNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            builder.append(nextIndent);
            builder.append("left: ");
            builder.append(this.left.toString(nextIndent));
            builder.append(nextIndent);
            builder.append("right: ");
            builder.append(this.right.toString(nextIndent));
            return builder.toString();
        }
    }

    /**
     * <pre>
     * Represents the list of parameters on a method, block, or lambda definition.
     *
     *     def a(b, c, d)
     *           ^^^^^^^
     *     end
     * </pre>
     */
    public static final class ParametersNode extends Node {
        @UnionType({ RequiredParameterNode.class, MultiTargetNode.class })
        public final Node[] requireds;
        public final OptionalParameterNode[] optionals;
        @Nullable
        @UnionType({ RestParameterNode.class, ImplicitRestNode.class })
        public final Node rest;
        @UnionType({ RequiredParameterNode.class, MultiTargetNode.class, KeywordRestParameterNode.class, NoKeywordsParameterNode.class, ForwardingParameterNode.class })
        public final Node[] posts;
        @UnionType({ RequiredKeywordParameterNode.class, OptionalKeywordParameterNode.class })
        public final Node[] keywords;
        @Nullable
        @UnionType({ KeywordRestParameterNode.class, ForwardingParameterNode.class, NoKeywordsParameterNode.class })
        public final Node keyword_rest;
        @Nullable
        public final BlockParameterNode block;

        public ParametersNode(int startOffset, int length, Node[] requireds, OptionalParameterNode[] optionals, Node rest, Node[] posts, Node[] keywords, Node keyword_rest, BlockParameterNode block) {
            super(startOffset, length);
            this.requireds = requireds;
            this.optionals = optionals;
            this.rest = rest;
            this.posts = posts;
            this.keywords = keywords;
            this.keyword_rest = keyword_rest;
            this.block = block;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            for (Nodes.Node child : this.requireds) {
                child.accept(visitor);
            }
            for (Nodes.Node child : this.optionals) {
                child.accept(visitor);
            }
            if (this.rest != null) {
                this.rest.accept(visitor);
            }
            for (Nodes.Node child : this.posts) {
                child.accept(visitor);
            }
            for (Nodes.Node child : this.keywords) {
                child.accept(visitor);
            }
            if (this.keyword_rest != null) {
                this.keyword_rest.accept(visitor);
            }
            if (this.block != null) {
                this.block.accept(visitor);
            }
        }

        public Node[] childNodes() {
            ArrayList<Node> childNodes = new ArrayList<>();
            childNodes.addAll(Arrays.asList(this.requireds));
            childNodes.addAll(Arrays.asList(this.optionals));
            childNodes.add(this.rest);
            childNodes.addAll(Arrays.asList(this.posts));
            childNodes.addAll(Arrays.asList(this.keywords));
            childNodes.add(this.keyword_rest);
            childNodes.add(this.block);
            return childNodes.toArray(EMPTY_ARRAY);
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitParametersNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            String nextNextIndent = nextIndent + "  ";
            builder.append(nextIndent);
            builder.append("requireds: ");
            builder.append('\n');
            for (Node child : this.requireds) {
                builder.append(nextNextIndent).append(child.toString(nextNextIndent));
            }
            builder.append(nextIndent);
            builder.append("optionals: ");
            builder.append('\n');
            for (Node child : this.optionals) {
                builder.append(nextNextIndent).append(child.toString(nextNextIndent));
            }
            builder.append(nextIndent);
            builder.append("rest: ");
            builder.append(this.rest == null ? "null\n" : this.rest.toString(nextIndent));
            builder.append(nextIndent);
            builder.append("posts: ");
            builder.append('\n');
            for (Node child : this.posts) {
                builder.append(nextNextIndent).append(child.toString(nextNextIndent));
            }
            builder.append(nextIndent);
            builder.append("keywords: ");
            builder.append('\n');
            for (Node child : this.keywords) {
                builder.append(nextNextIndent).append(child.toString(nextNextIndent));
            }
            builder.append(nextIndent);
            builder.append("keyword_rest: ");
            builder.append(this.keyword_rest == null ? "null\n" : this.keyword_rest.toString(nextIndent));
            builder.append(nextIndent);
            builder.append("block: ");
            builder.append(this.block == null ? "null\n" : this.block.toString(nextIndent));
            return builder.toString();
        }
    }

    /**
     * <pre>
     * Represents a parenthesized expression
     *
     *     (10 + 34)
     *     ^^^^^^^^^
     * </pre>
     */
    public static final class ParenthesesNode extends Node {
        @Nullable
        public final Node body;

        public ParenthesesNode(int startOffset, int length, Node body) {
            super(startOffset, length);
            this.body = body;
        }
                
        @Override
        public void setNewLineFlag(Source source, boolean[] newlineMarked) {
            // Never mark ParenthesesNode with a newline flag, mark children instead
        }

        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            if (this.body != null) {
                this.body.accept(visitor);
            }
        }

        public Node[] childNodes() {
            return new Node[] { this.body };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitParenthesesNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            builder.append(nextIndent);
            builder.append("body: ");
            builder.append(this.body == null ? "null\n" : this.body.toString(nextIndent));
            return builder.toString();
        }
    }

    /**
     * <pre>
     * Represents the use of the `^` operator for pinning an expression in a pattern matching expression.
     *
     *     foo in ^(bar)
     *            ^^^^^^
     * </pre>
     */
    public static final class PinnedExpressionNode extends Node {
        public final Node expression;

        public PinnedExpressionNode(int startOffset, int length, Node expression) {
            super(startOffset, length);
            this.expression = expression;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            this.expression.accept(visitor);
        }

        public Node[] childNodes() {
            return new Node[] { this.expression };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitPinnedExpressionNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            builder.append(nextIndent);
            builder.append("expression: ");
            builder.append(this.expression.toString(nextIndent));
            return builder.toString();
        }
    }

    /**
     * <pre>
     * Represents the use of the `^` operator for pinning a variable in a pattern matching expression.
     *
     *     foo in ^bar
     *            ^^^^
     * </pre>
     */
    public static final class PinnedVariableNode extends Node {
        public final Node variable;

        public PinnedVariableNode(int startOffset, int length, Node variable) {
            super(startOffset, length);
            this.variable = variable;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            this.variable.accept(visitor);
        }

        public Node[] childNodes() {
            return new Node[] { this.variable };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitPinnedVariableNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            builder.append(nextIndent);
            builder.append("variable: ");
            builder.append(this.variable.toString(nextIndent));
            return builder.toString();
        }
    }

    /**
     * <pre>
     * Represents the use of the `END` keyword.
     *
     *     END { foo }
     *     ^^^^^^^^^^^
     * </pre>
     */
    public static final class PostExecutionNode extends Node {
        @Nullable
        public final StatementsNode statements;

        public PostExecutionNode(int startOffset, int length, StatementsNode statements) {
            super(startOffset, length);
            this.statements = statements;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            if (this.statements != null) {
                this.statements.accept(visitor);
            }
        }

        public Node[] childNodes() {
            return new Node[] { this.statements };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitPostExecutionNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            builder.append(nextIndent);
            builder.append("statements: ");
            builder.append(this.statements == null ? "null\n" : this.statements.toString(nextIndent));
            return builder.toString();
        }
    }

    /**
     * <pre>
     * Represents the use of the `BEGIN` keyword.
     *
     *     BEGIN { foo }
     *     ^^^^^^^^^^^^^
     * </pre>
     */
    public static final class PreExecutionNode extends Node {
        @Nullable
        public final StatementsNode statements;

        public PreExecutionNode(int startOffset, int length, StatementsNode statements) {
            super(startOffset, length);
            this.statements = statements;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            if (this.statements != null) {
                this.statements.accept(visitor);
            }
        }

        public Node[] childNodes() {
            return new Node[] { this.statements };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitPreExecutionNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            builder.append(nextIndent);
            builder.append("statements: ");
            builder.append(this.statements == null ? "null\n" : this.statements.toString(nextIndent));
            return builder.toString();
        }
    }

    /**
     * <pre>
     * The top level node of any parse tree.
     * </pre>
     */
    public static final class ProgramNode extends Node {
        public final String[] locals;
        public final StatementsNode statements;

        public ProgramNode(int startOffset, int length, String[] locals, StatementsNode statements) {
            super(startOffset, length);
            this.locals = locals;
            this.statements = statements;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            this.statements.accept(visitor);
        }

        public Node[] childNodes() {
            return new Node[] { this.statements };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitProgramNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            String nextNextIndent = nextIndent + "  ";
            builder.append(nextIndent);
            builder.append("locals: ");
            builder.append('\n');
            for (String constant : this.locals) {
                builder.append(nextNextIndent).append('"').append(constant).append('"').append('\n');
            }
            builder.append(nextIndent);
            builder.append("statements: ");
            builder.append(this.statements.toString(nextIndent));
            return builder.toString();
        }
    }

    /**
     * <pre>
     * Represents the use of the `..` or `...` operators.
     *
     *     1..2
     *     ^^^^
     *
     *     c if a =~ /left/ ... b =~ /right/
     *          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
     * </pre>
     */
    public static final class RangeNode extends Node {
        public final short flags;
        /**
         * <pre>
         * The left-hand side of the range, if present. It can be either `nil` or any [non-void expression](https://github.com/ruby/prism/blob/main/docs/parsing_rules.md#non-void-expression).
         *
         *     1...
         *     ^
         *
         *     hello...goodbye
         *     ^^^^^
         * </pre>
         */
        @Nullable
        public final Node left;
        /**
         * <pre>
         * The right-hand side of the range, if present. It can be either `nil` or any [non-void expression](https://github.com/ruby/prism/blob/main/docs/parsing_rules.md#non-void-expression).
         *
         *     ..5
         *       ^
         *
         *     1...foo
         *         ^^^
         * If neither right-hand or left-hand side was included, this will be a MissingNode.
         * </pre>
         */
        @Nullable
        public final Node right;

        public RangeNode(int startOffset, int length, short flags, Node left, Node right) {
            super(startOffset, length);
            this.flags = flags;
            this.left = left;
            this.right = right;
        }
        
        public boolean isExcludeEnd() {
            return RangeFlags.isExcludeEnd(flags);
        }
        
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            if (this.left != null) {
                this.left.accept(visitor);
            }
            if (this.right != null) {
                this.right.accept(visitor);
            }
        }

        public Node[] childNodes() {
            return new Node[] { this.left, this.right };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitRangeNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            builder.append(nextIndent);
            builder.append("RangeFlags: ");
            builder.append(flags);
            builder.append('\n');
            builder.append(nextIndent);
            builder.append("left: ");
            builder.append(this.left == null ? "null\n" : this.left.toString(nextIndent));
            builder.append(nextIndent);
            builder.append("right: ");
            builder.append(this.right == null ? "null\n" : this.right.toString(nextIndent));
            return builder.toString();
        }
    }

    /**
     * <pre>
     * Represents a rational number literal.
     *
     *     1.0r
     *     ^^^^
     * </pre>
     */
    public static final class RationalNode extends Node {
        public final short flags;
        /**
         * <pre>
         * The numerator of the rational number.
         *
         *     1.5r # numerator 3
         * </pre>
         */
        public final Object numerator;
        /**
         * <pre>
         * The denominator of the rational number.
         *
         *     1.5r # denominator 2
         * </pre>
         */
        public final Object denominator;

        public RationalNode(int startOffset, int length, short flags, Object numerator, Object denominator) {
            super(startOffset, length);
            this.flags = flags;
            this.numerator = numerator;
            this.denominator = denominator;
        }
        
        public boolean isBinary() {
            return IntegerBaseFlags.isBinary(flags);
        }

        public boolean isDecimal() {
            return IntegerBaseFlags.isDecimal(flags);
        }

        public boolean isOctal() {
            return IntegerBaseFlags.isOctal(flags);
        }

        public boolean isHexadecimal() {
            return IntegerBaseFlags.isHexadecimal(flags);
        }
        
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
        }

        public Node[] childNodes() {
            return EMPTY_ARRAY;
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitRationalNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            builder.append(nextIndent);
            builder.append("IntegerBaseFlags: ");
            builder.append(flags);
            builder.append('\n');
            builder.append(nextIndent);
            builder.append("numerator: ");
            builder.append(this.numerator);
            builder.append('\n');
            builder.append(nextIndent);
            builder.append("denominator: ");
            builder.append(this.denominator);
            builder.append('\n');
            return builder.toString();
        }
    }

    /**
     * <pre>
     * Represents the use of the `redo` keyword.
     *
     *     redo
     *     ^^^^
     * </pre>
     */
    public static final class RedoNode extends Node {

        public RedoNode(int startOffset, int length) {
            super(startOffset, length);
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
        }

        public Node[] childNodes() {
            return EMPTY_ARRAY;
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitRedoNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            return builder.toString();
        }
    }

    /**
     * <pre>
     * Represents a regular expression literal with no interpolation.
     *
     *     /foo/i
     *     ^^^^^^
     * </pre>
     */
    public static final class RegularExpressionNode extends Node {
        public final short flags;
        public final byte[] unescaped;

        public RegularExpressionNode(int startOffset, int length, short flags, byte[] unescaped) {
            super(startOffset, length);
            this.flags = flags;
            this.unescaped = unescaped;
        }
        
        public boolean isIgnoreCase() {
            return RegularExpressionFlags.isIgnoreCase(flags);
        }

        public boolean isExtended() {
            return RegularExpressionFlags.isExtended(flags);
        }

        public boolean isMultiLine() {
            return RegularExpressionFlags.isMultiLine(flags);
        }

        public boolean isOnce() {
            return RegularExpressionFlags.isOnce(flags);
        }

        public boolean isEucJp() {
            return RegularExpressionFlags.isEucJp(flags);
        }

        public boolean isAscii8bit() {
            return RegularExpressionFlags.isAscii8bit(flags);
        }

        public boolean isWindows31j() {
            return RegularExpressionFlags.isWindows31j(flags);
        }

        public boolean isUtf8() {
            return RegularExpressionFlags.isUtf8(flags);
        }

        public boolean isForcedUtf8Encoding() {
            return RegularExpressionFlags.isForcedUtf8Encoding(flags);
        }

        public boolean isForcedBinaryEncoding() {
            return RegularExpressionFlags.isForcedBinaryEncoding(flags);
        }

        public boolean isForcedUsAsciiEncoding() {
            return RegularExpressionFlags.isForcedUsAsciiEncoding(flags);
        }
        
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
        }

        public Node[] childNodes() {
            return EMPTY_ARRAY;
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitRegularExpressionNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            builder.append(nextIndent);
            builder.append("RegularExpressionFlags: ");
            builder.append(flags);
            builder.append('\n');
            builder.append(nextIndent);
            builder.append("unescaped: ");
            builder.append('"' + new String(this.unescaped, StandardCharsets.UTF_8) + '"');
            builder.append('\n');
            return builder.toString();
        }
    }

    /**
     * <pre>
     * Represents a required keyword parameter to a method, block, or lambda definition.
     *
     *     def a(b: )
     *           ^^
     *     end
     * </pre>
     */
    public static final class RequiredKeywordParameterNode extends Node {
        public final short flags;
        public final String name;

        public RequiredKeywordParameterNode(int startOffset, int length, short flags, String name) {
            super(startOffset, length);
            this.flags = flags;
            this.name = name;
        }
        
        public boolean isRepeatedParameter() {
            return ParameterFlags.isRepeatedParameter(flags);
        }
        
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
        }

        public Node[] childNodes() {
            return EMPTY_ARRAY;
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitRequiredKeywordParameterNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            builder.append(nextIndent);
            builder.append("ParameterFlags: ");
            builder.append(flags);
            builder.append('\n');
            builder.append(nextIndent);
            builder.append("name: ");
            builder.append('"').append(this.name).append('"');
            builder.append('\n');
            return builder.toString();
        }
    }

    /**
     * <pre>
     * Represents a required parameter to a method, block, or lambda definition.
     *
     *     def a(b)
     *           ^
     *     end
     * </pre>
     */
    public static final class RequiredParameterNode extends Node {
        public final short flags;
        public final String name;

        public RequiredParameterNode(int startOffset, int length, short flags, String name) {
            super(startOffset, length);
            this.flags = flags;
            this.name = name;
        }
        
        public boolean isRepeatedParameter() {
            return ParameterFlags.isRepeatedParameter(flags);
        }
        
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
        }

        public Node[] childNodes() {
            return EMPTY_ARRAY;
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitRequiredParameterNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            builder.append(nextIndent);
            builder.append("ParameterFlags: ");
            builder.append(flags);
            builder.append('\n');
            builder.append(nextIndent);
            builder.append("name: ");
            builder.append('"').append(this.name).append('"');
            builder.append('\n');
            return builder.toString();
        }
    }

    /**
     * <pre>
     * Represents an expression modified with a rescue.
     *
     *     foo rescue nil
     *     ^^^^^^^^^^^^^^
     * </pre>
     */
    public static final class RescueModifierNode extends Node {
        public final Node expression;
        public final Node rescue_expression;

        public RescueModifierNode(int startOffset, int length, Node expression, Node rescue_expression) {
            super(startOffset, length);
            this.expression = expression;
            this.rescue_expression = rescue_expression;
        }
                
        @Override
        public void setNewLineFlag(Source source, boolean[] newlineMarked) {
            this.expression.setNewLineFlag(source, newlineMarked);
        }

        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            this.expression.accept(visitor);
            this.rescue_expression.accept(visitor);
        }

        public Node[] childNodes() {
            return new Node[] { this.expression, this.rescue_expression };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitRescueModifierNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            builder.append(nextIndent);
            builder.append("expression: ");
            builder.append(this.expression.toString(nextIndent));
            builder.append(nextIndent);
            builder.append("rescue_expression: ");
            builder.append(this.rescue_expression.toString(nextIndent));
            return builder.toString();
        }
    }

    /**
     * <pre>
     * Represents a rescue statement.
     *
     *     begin
     *     rescue Foo, *splat, Bar =&gt; ex
     *       foo
     *     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
     *     end
     *
     * `Foo, *splat, Bar` are in the `exceptions` field. `ex` is in the `exception` field.
     * </pre>
     */
    public static final class RescueNode extends Node {
        public final Node[] exceptions;
        @Nullable
        public final Node reference;
        @Nullable
        public final StatementsNode statements;
        @Nullable
        public final RescueNode subsequent;

        public RescueNode(int startOffset, int length, Node[] exceptions, Node reference, StatementsNode statements, RescueNode subsequent) {
            super(startOffset, length);
            this.exceptions = exceptions;
            this.reference = reference;
            this.statements = statements;
            this.subsequent = subsequent;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            for (Nodes.Node child : this.exceptions) {
                child.accept(visitor);
            }
            if (this.reference != null) {
                this.reference.accept(visitor);
            }
            if (this.statements != null) {
                this.statements.accept(visitor);
            }
            if (this.subsequent != null) {
                this.subsequent.accept(visitor);
            }
        }

        public Node[] childNodes() {
            ArrayList<Node> childNodes = new ArrayList<>();
            childNodes.addAll(Arrays.asList(this.exceptions));
            childNodes.add(this.reference);
            childNodes.add(this.statements);
            childNodes.add(this.subsequent);
            return childNodes.toArray(EMPTY_ARRAY);
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitRescueNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            String nextNextIndent = nextIndent + "  ";
            builder.append(nextIndent);
            builder.append("exceptions: ");
            builder.append('\n');
            for (Node child : this.exceptions) {
                builder.append(nextNextIndent).append(child.toString(nextNextIndent));
            }
            builder.append(nextIndent);
            builder.append("reference: ");
            builder.append(this.reference == null ? "null\n" : this.reference.toString(nextIndent));
            builder.append(nextIndent);
            builder.append("statements: ");
            builder.append(this.statements == null ? "null\n" : this.statements.toString(nextIndent));
            builder.append(nextIndent);
            builder.append("subsequent: ");
            builder.append(this.subsequent == null ? "null\n" : this.subsequent.toString(nextIndent));
            return builder.toString();
        }
    }

    /**
     * <pre>
     * Represents a rest parameter to a method, block, or lambda definition.
     *
     *     def a(*b)
     *           ^^
     *     end
     * </pre>
     */
    public static final class RestParameterNode extends Node {
        public final short flags;
        @Nullable
        public final String name;

        public RestParameterNode(int startOffset, int length, short flags, String name) {
            super(startOffset, length);
            this.flags = flags;
            this.name = name;
        }
        
        public boolean isRepeatedParameter() {
            return ParameterFlags.isRepeatedParameter(flags);
        }
        
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
        }

        public Node[] childNodes() {
            return EMPTY_ARRAY;
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitRestParameterNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            builder.append(nextIndent);
            builder.append("ParameterFlags: ");
            builder.append(flags);
            builder.append('\n');
            builder.append(nextIndent);
            builder.append("name: ");
            builder.append(this.name == null ? "null" : "\"" + this.name + "\"");
            builder.append('\n');
            return builder.toString();
        }
    }

    /**
     * <pre>
     * Represents the use of the `retry` keyword.
     *
     *     retry
     *     ^^^^^
     * </pre>
     */
    public static final class RetryNode extends Node {

        public RetryNode(int startOffset, int length) {
            super(startOffset, length);
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
        }

        public Node[] childNodes() {
            return EMPTY_ARRAY;
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitRetryNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            return builder.toString();
        }
    }

    /**
     * <pre>
     * Represents the use of the `return` keyword.
     *
     *     return 1
     *     ^^^^^^^^
     * </pre>
     */
    public static final class ReturnNode extends Node {
        @Nullable
        public final ArgumentsNode arguments;

        public ReturnNode(int startOffset, int length, ArgumentsNode arguments) {
            super(startOffset, length);
            this.arguments = arguments;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            if (this.arguments != null) {
                this.arguments.accept(visitor);
            }
        }

        public Node[] childNodes() {
            return new Node[] { this.arguments };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitReturnNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            builder.append(nextIndent);
            builder.append("arguments: ");
            builder.append(this.arguments == null ? "null\n" : this.arguments.toString(nextIndent));
            return builder.toString();
        }
    }

    /**
     * <pre>
     * Represents the `self` keyword.
     *
     *     self
     *     ^^^^
     * </pre>
     */
    public static final class SelfNode extends Node {

        public SelfNode(int startOffset, int length) {
            super(startOffset, length);
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
        }

        public Node[] childNodes() {
            return EMPTY_ARRAY;
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitSelfNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            return builder.toString();
        }
    }

    /**
     * <pre>
     * This node wraps a constant write to indicate that when the value is written, it should have its shareability state modified.
     *
     *     # shareable_constant_value: literal
     *     C = { a: 1 }
     *     ^^^^^^^^^^^^
     * </pre>
     */
    public static final class ShareableConstantNode extends Node {
        public final short flags;
        /**
         * <pre>
         * The constant write that should be modified with the shareability state.
         * </pre>
         */
        @UnionType({ ConstantWriteNode.class, ConstantAndWriteNode.class, ConstantOrWriteNode.class, ConstantOperatorWriteNode.class, ConstantPathWriteNode.class, ConstantPathAndWriteNode.class, ConstantPathOrWriteNode.class, ConstantPathOperatorWriteNode.class })
        public final Node write;

        public ShareableConstantNode(int startOffset, int length, short flags, Node write) {
            super(startOffset, length);
            this.flags = flags;
            this.write = write;
        }
        
        public boolean isLiteral() {
            return ShareableConstantNodeFlags.isLiteral(flags);
        }

        public boolean isExperimentalEverything() {
            return ShareableConstantNodeFlags.isExperimentalEverything(flags);
        }

        public boolean isExperimentalCopy() {
            return ShareableConstantNodeFlags.isExperimentalCopy(flags);
        }
        
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            this.write.accept(visitor);
        }

        public Node[] childNodes() {
            return new Node[] { this.write };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitShareableConstantNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            builder.append(nextIndent);
            builder.append("ShareableConstantNodeFlags: ");
            builder.append(flags);
            builder.append('\n');
            builder.append(nextIndent);
            builder.append("write: ");
            builder.append(this.write.toString(nextIndent));
            return builder.toString();
        }
    }

    /**
     * <pre>
     * Represents a singleton class declaration involving the `class` keyword.
     *
     *     class &lt;&lt; self end
     *     ^^^^^^^^^^^^^^^^^
     * </pre>
     */
    public static final class SingletonClassNode extends Node {
        public final String[] locals;
        public final Node expression;
        @Nullable
        public final Node body;

        public SingletonClassNode(int startOffset, int length, String[] locals, Node expression, Node body) {
            super(startOffset, length);
            this.locals = locals;
            this.expression = expression;
            this.body = body;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            this.expression.accept(visitor);
            if (this.body != null) {
                this.body.accept(visitor);
            }
        }

        public Node[] childNodes() {
            return new Node[] { this.expression, this.body };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitSingletonClassNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            String nextNextIndent = nextIndent + "  ";
            builder.append(nextIndent);
            builder.append("locals: ");
            builder.append('\n');
            for (String constant : this.locals) {
                builder.append(nextNextIndent).append('"').append(constant).append('"').append('\n');
            }
            builder.append(nextIndent);
            builder.append("expression: ");
            builder.append(this.expression.toString(nextIndent));
            builder.append(nextIndent);
            builder.append("body: ");
            builder.append(this.body == null ? "null\n" : this.body.toString(nextIndent));
            return builder.toString();
        }
    }

    /**
     * <pre>
     * Represents the use of the `__ENCODING__` keyword.
     *
     *     __ENCODING__
     *     ^^^^^^^^^^^^
     * </pre>
     */
    public static final class SourceEncodingNode extends Node {

        public SourceEncodingNode(int startOffset, int length) {
            super(startOffset, length);
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
        }

        public Node[] childNodes() {
            return EMPTY_ARRAY;
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitSourceEncodingNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            return builder.toString();
        }
    }

    /**
     * <pre>
     * Represents the use of the `__FILE__` keyword.
     *
     *     __FILE__
     *     ^^^^^^^^
     * </pre>
     */
    public static final class SourceFileNode extends Node {
        public final short flags;
        /**
         * <pre>
         * Represents the file path being parsed. This corresponds directly to the `filepath` option given to the various `Prism::parse*` APIs.
         * </pre>
         */
        public final byte[] filepath;

        public SourceFileNode(int startOffset, int length, short flags, byte[] filepath) {
            super(startOffset, length);
            this.flags = flags;
            this.filepath = filepath;
        }
        
        public boolean isForcedUtf8Encoding() {
            return StringFlags.isForcedUtf8Encoding(flags);
        }

        public boolean isForcedBinaryEncoding() {
            return StringFlags.isForcedBinaryEncoding(flags);
        }

        public boolean isFrozen() {
            return StringFlags.isFrozen(flags);
        }

        public boolean isMutable() {
            return StringFlags.isMutable(flags);
        }
        
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
        }

        public Node[] childNodes() {
            return EMPTY_ARRAY;
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitSourceFileNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            builder.append(nextIndent);
            builder.append("StringFlags: ");
            builder.append(flags);
            builder.append('\n');
            builder.append(nextIndent);
            builder.append("filepath: ");
            builder.append('"' + new String(this.filepath, StandardCharsets.UTF_8) + '"');
            builder.append('\n');
            return builder.toString();
        }
    }

    /**
     * <pre>
     * Represents the use of the `__LINE__` keyword.
     *
     *     __LINE__
     *     ^^^^^^^^
     * </pre>
     */
    public static final class SourceLineNode extends Node {

        public SourceLineNode(int startOffset, int length) {
            super(startOffset, length);
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
        }

        public Node[] childNodes() {
            return EMPTY_ARRAY;
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitSourceLineNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            return builder.toString();
        }
    }

    /**
     * <pre>
     * Represents the use of the splat operator.
     *
     *     [*a]
     *      ^^
     * </pre>
     */
    public static final class SplatNode extends Node {
        @Nullable
        public final Node expression;

        public SplatNode(int startOffset, int length, Node expression) {
            super(startOffset, length);
            this.expression = expression;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            if (this.expression != null) {
                this.expression.accept(visitor);
            }
        }

        public Node[] childNodes() {
            return new Node[] { this.expression };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitSplatNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            builder.append(nextIndent);
            builder.append("expression: ");
            builder.append(this.expression == null ? "null\n" : this.expression.toString(nextIndent));
            return builder.toString();
        }
    }

    /**
     * <pre>
     * Represents a set of statements contained within some scope.
     *
     *     foo; bar; baz
     *     ^^^^^^^^^^^^^
     * </pre>
     */
    public static final class StatementsNode extends Node {
        public final Node[] body;

        public StatementsNode(int startOffset, int length, Node[] body) {
            super(startOffset, length);
            this.body = body;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            for (Nodes.Node child : this.body) {
                child.accept(visitor);
            }
        }

        public Node[] childNodes() {
            ArrayList<Node> childNodes = new ArrayList<>();
            childNodes.addAll(Arrays.asList(this.body));
            return childNodes.toArray(EMPTY_ARRAY);
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitStatementsNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            String nextNextIndent = nextIndent + "  ";
            builder.append(nextIndent);
            builder.append("body: ");
            builder.append('\n');
            for (Node child : this.body) {
                builder.append(nextNextIndent).append(child.toString(nextNextIndent));
            }
            return builder.toString();
        }
    }

    /**
     * <pre>
     * Represents a string literal, a string contained within a `%w` list, or plain string content within an interpolated string.
     *
     *     &quot;foo&quot;
     *     ^^^^^
     *
     *     %w[foo]
     *        ^^^
     *
     *     &quot;foo #{bar} baz&quot;
     *      ^^^^      ^^^^
     * </pre>
     */
    public static final class StringNode extends Node {
        public final short flags;
        public final byte[] unescaped;

        public StringNode(int startOffset, int length, short flags, byte[] unescaped) {
            super(startOffset, length);
            this.flags = flags;
            this.unescaped = unescaped;
        }
        
        public boolean isForcedUtf8Encoding() {
            return StringFlags.isForcedUtf8Encoding(flags);
        }

        public boolean isForcedBinaryEncoding() {
            return StringFlags.isForcedBinaryEncoding(flags);
        }

        public boolean isFrozen() {
            return StringFlags.isFrozen(flags);
        }

        public boolean isMutable() {
            return StringFlags.isMutable(flags);
        }
        
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
        }

        public Node[] childNodes() {
            return EMPTY_ARRAY;
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitStringNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            builder.append(nextIndent);
            builder.append("StringFlags: ");
            builder.append(flags);
            builder.append('\n');
            builder.append(nextIndent);
            builder.append("unescaped: ");
            builder.append('"' + new String(this.unescaped, StandardCharsets.UTF_8) + '"');
            builder.append('\n');
            return builder.toString();
        }
    }

    /**
     * <pre>
     * Represents the use of the `super` keyword with parentheses or arguments.
     *
     *     super()
     *     ^^^^^^^
     *
     *     super foo, bar
     *     ^^^^^^^^^^^^^^
     * </pre>
     */
    public static final class SuperNode extends Node {
        @Nullable
        public final ArgumentsNode arguments;
        @Nullable
        public final Node block;

        public SuperNode(int startOffset, int length, ArgumentsNode arguments, Node block) {
            super(startOffset, length);
            this.arguments = arguments;
            this.block = block;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            if (this.arguments != null) {
                this.arguments.accept(visitor);
            }
            if (this.block != null) {
                this.block.accept(visitor);
            }
        }

        public Node[] childNodes() {
            return new Node[] { this.arguments, this.block };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitSuperNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            builder.append(nextIndent);
            builder.append("arguments: ");
            builder.append(this.arguments == null ? "null\n" : this.arguments.toString(nextIndent));
            builder.append(nextIndent);
            builder.append("block: ");
            builder.append(this.block == null ? "null\n" : this.block.toString(nextIndent));
            return builder.toString();
        }
    }

    /**
     * <pre>
     * Represents a symbol literal or a symbol contained within a `%i` list.
     *
     *     :foo
     *     ^^^^
     *
     *     %i[foo]
     *        ^^^
     * </pre>
     */
    public static final class SymbolNode extends Node {
        public final short flags;
        public final byte[] unescaped;

        public SymbolNode(int startOffset, int length, short flags, byte[] unescaped) {
            super(startOffset, length);
            this.flags = flags;
            this.unescaped = unescaped;
        }
        
        public boolean isForcedUtf8Encoding() {
            return SymbolFlags.isForcedUtf8Encoding(flags);
        }

        public boolean isForcedBinaryEncoding() {
            return SymbolFlags.isForcedBinaryEncoding(flags);
        }

        public boolean isForcedUsAsciiEncoding() {
            return SymbolFlags.isForcedUsAsciiEncoding(flags);
        }
        
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
        }

        public Node[] childNodes() {
            return EMPTY_ARRAY;
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitSymbolNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            builder.append(nextIndent);
            builder.append("SymbolFlags: ");
            builder.append(flags);
            builder.append('\n');
            builder.append(nextIndent);
            builder.append("unescaped: ");
            builder.append('"' + new String(this.unescaped, StandardCharsets.UTF_8) + '"');
            builder.append('\n');
            return builder.toString();
        }
    }

    /**
     * <pre>
     * Represents the use of the literal `true` keyword.
     *
     *     true
     *     ^^^^
     * </pre>
     */
    public static final class TrueNode extends Node {

        public TrueNode(int startOffset, int length) {
            super(startOffset, length);
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
        }

        public Node[] childNodes() {
            return EMPTY_ARRAY;
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitTrueNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            return builder.toString();
        }
    }

    /**
     * <pre>
     * Represents the use of the `undef` keyword.
     *
     *     undef :foo, :bar, :baz
     *     ^^^^^^^^^^^^^^^^^^^^^^
     * </pre>
     */
    public static final class UndefNode extends Node {
        @UnionType({ SymbolNode.class, InterpolatedSymbolNode.class })
        public final Node[] names;

        public UndefNode(int startOffset, int length, Node[] names) {
            super(startOffset, length);
            this.names = names;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            for (Nodes.Node child : this.names) {
                child.accept(visitor);
            }
        }

        public Node[] childNodes() {
            ArrayList<Node> childNodes = new ArrayList<>();
            childNodes.addAll(Arrays.asList(this.names));
            return childNodes.toArray(EMPTY_ARRAY);
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitUndefNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            String nextNextIndent = nextIndent + "  ";
            builder.append(nextIndent);
            builder.append("names: ");
            builder.append('\n');
            for (Node child : this.names) {
                builder.append(nextNextIndent).append(child.toString(nextNextIndent));
            }
            return builder.toString();
        }
    }

    /**
     * <pre>
     * Represents the use of the `unless` keyword, either in the block form or the modifier form.
     *
     *     bar unless foo
     *     ^^^^^^^^^^^^^^
     *
     *     unless foo then bar end
     *     ^^^^^^^^^^^^^^^^^^^^^^^
     * </pre>
     */
    public static final class UnlessNode extends Node {
        /**
         * <pre>
         * The condition to be evaluated for the unless expression. It can be any [non-void expression](https://github.com/ruby/prism/blob/main/docs/parsing_rules.md#non-void-expression).
         *
         *     unless cond then bar end
         *            ^^^^
         *
         *     bar unless cond
         *                ^^^^
         * </pre>
         */
        public final Node predicate;
        /**
         * <pre>
         * The body of statements that will executed if the unless condition is
         * falsey. Will be `nil` if no body is provided.
         *
         *     unless cond then bar end
         *                      ^^^
         * </pre>
         */
        @Nullable
        public final StatementsNode statements;
        /**
         * <pre>
         * The else clause of the unless expression, if present.
         *
         *     unless cond then bar else baz end
         *                          ^^^^^^^^
         * </pre>
         */
        @Nullable
        public final ElseNode else_clause;

        public UnlessNode(int startOffset, int length, Node predicate, StatementsNode statements, ElseNode else_clause) {
            super(startOffset, length);
            this.predicate = predicate;
            this.statements = statements;
            this.else_clause = else_clause;
        }
                
        @Override
        public void setNewLineFlag(Source source, boolean[] newlineMarked) {
            this.predicate.setNewLineFlag(source, newlineMarked);
        }

        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            this.predicate.accept(visitor);
            if (this.statements != null) {
                this.statements.accept(visitor);
            }
            if (this.else_clause != null) {
                this.else_clause.accept(visitor);
            }
        }

        public Node[] childNodes() {
            return new Node[] { this.predicate, this.statements, this.else_clause };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitUnlessNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            builder.append(nextIndent);
            builder.append("predicate: ");
            builder.append(this.predicate.toString(nextIndent));
            builder.append(nextIndent);
            builder.append("statements: ");
            builder.append(this.statements == null ? "null\n" : this.statements.toString(nextIndent));
            builder.append(nextIndent);
            builder.append("else_clause: ");
            builder.append(this.else_clause == null ? "null\n" : this.else_clause.toString(nextIndent));
            return builder.toString();
        }
    }

    /**
     * <pre>
     * Represents the use of the `until` keyword, either in the block form or the modifier form.
     *
     *     bar until foo
     *     ^^^^^^^^^^^^^
     *
     *     until foo do bar end
     *     ^^^^^^^^^^^^^^^^^^^^
     * </pre>
     */
    public static final class UntilNode extends Node {
        public final short flags;
        public final Node predicate;
        @Nullable
        public final StatementsNode statements;

        public UntilNode(int startOffset, int length, short flags, Node predicate, StatementsNode statements) {
            super(startOffset, length);
            this.flags = flags;
            this.predicate = predicate;
            this.statements = statements;
        }
        
        public boolean isBeginModifier() {
            return LoopFlags.isBeginModifier(flags);
        }
        
        @Override
        public void setNewLineFlag(Source source, boolean[] newlineMarked) {
            this.predicate.setNewLineFlag(source, newlineMarked);
        }

        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            this.predicate.accept(visitor);
            if (this.statements != null) {
                this.statements.accept(visitor);
            }
        }

        public Node[] childNodes() {
            return new Node[] { this.predicate, this.statements };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitUntilNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            builder.append(nextIndent);
            builder.append("LoopFlags: ");
            builder.append(flags);
            builder.append('\n');
            builder.append(nextIndent);
            builder.append("predicate: ");
            builder.append(this.predicate.toString(nextIndent));
            builder.append(nextIndent);
            builder.append("statements: ");
            builder.append(this.statements == null ? "null\n" : this.statements.toString(nextIndent));
            return builder.toString();
        }
    }

    /**
     * <pre>
     * Represents the use of the `when` keyword within a case statement.
     *
     *     case true
     *     when true
     *     ^^^^^^^^^
     *     end
     * </pre>
     */
    public static final class WhenNode extends Node {
        public final Node[] conditions;
        @Nullable
        public final StatementsNode statements;

        public WhenNode(int startOffset, int length, Node[] conditions, StatementsNode statements) {
            super(startOffset, length);
            this.conditions = conditions;
            this.statements = statements;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            for (Nodes.Node child : this.conditions) {
                child.accept(visitor);
            }
            if (this.statements != null) {
                this.statements.accept(visitor);
            }
        }

        public Node[] childNodes() {
            ArrayList<Node> childNodes = new ArrayList<>();
            childNodes.addAll(Arrays.asList(this.conditions));
            childNodes.add(this.statements);
            return childNodes.toArray(EMPTY_ARRAY);
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitWhenNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            String nextNextIndent = nextIndent + "  ";
            builder.append(nextIndent);
            builder.append("conditions: ");
            builder.append('\n');
            for (Node child : this.conditions) {
                builder.append(nextNextIndent).append(child.toString(nextNextIndent));
            }
            builder.append(nextIndent);
            builder.append("statements: ");
            builder.append(this.statements == null ? "null\n" : this.statements.toString(nextIndent));
            return builder.toString();
        }
    }

    /**
     * <pre>
     * Represents the use of the `while` keyword, either in the block form or the modifier form.
     *
     *     bar while foo
     *     ^^^^^^^^^^^^^
     *
     *     while foo do bar end
     *     ^^^^^^^^^^^^^^^^^^^^
     * </pre>
     */
    public static final class WhileNode extends Node {
        public final short flags;
        public final Node predicate;
        @Nullable
        public final StatementsNode statements;

        public WhileNode(int startOffset, int length, short flags, Node predicate, StatementsNode statements) {
            super(startOffset, length);
            this.flags = flags;
            this.predicate = predicate;
            this.statements = statements;
        }
        
        public boolean isBeginModifier() {
            return LoopFlags.isBeginModifier(flags);
        }
        
        @Override
        public void setNewLineFlag(Source source, boolean[] newlineMarked) {
            this.predicate.setNewLineFlag(source, newlineMarked);
        }

        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            this.predicate.accept(visitor);
            if (this.statements != null) {
                this.statements.accept(visitor);
            }
        }

        public Node[] childNodes() {
            return new Node[] { this.predicate, this.statements };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitWhileNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            builder.append(nextIndent);
            builder.append("LoopFlags: ");
            builder.append(flags);
            builder.append('\n');
            builder.append(nextIndent);
            builder.append("predicate: ");
            builder.append(this.predicate.toString(nextIndent));
            builder.append(nextIndent);
            builder.append("statements: ");
            builder.append(this.statements == null ? "null\n" : this.statements.toString(nextIndent));
            return builder.toString();
        }
    }

    /**
     * <pre>
     * Represents an xstring literal with no interpolation.
     *
     *     `foo`
     *     ^^^^^
     * </pre>
     */
    public static final class XStringNode extends Node {
        public final short flags;
        public final byte[] unescaped;

        public XStringNode(int startOffset, int length, short flags, byte[] unescaped) {
            super(startOffset, length);
            this.flags = flags;
            this.unescaped = unescaped;
        }
        
        public boolean isForcedUtf8Encoding() {
            return EncodingFlags.isForcedUtf8Encoding(flags);
        }

        public boolean isForcedBinaryEncoding() {
            return EncodingFlags.isForcedBinaryEncoding(flags);
        }
        
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
        }

        public Node[] childNodes() {
            return EMPTY_ARRAY;
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitXStringNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            builder.append(nextIndent);
            builder.append("EncodingFlags: ");
            builder.append(flags);
            builder.append('\n');
            builder.append(nextIndent);
            builder.append("unescaped: ");
            builder.append('"' + new String(this.unescaped, StandardCharsets.UTF_8) + '"');
            builder.append('\n');
            return builder.toString();
        }
    }

    /**
     * <pre>
     * Represents the use of the `yield` keyword.
     *
     *     yield 1
     *     ^^^^^^^
     * </pre>
     */
    public static final class YieldNode extends Node {
        @Nullable
        public final ArgumentsNode arguments;

        public YieldNode(int startOffset, int length, ArgumentsNode arguments) {
            super(startOffset, length);
            this.arguments = arguments;
        }
                
        public <T> void visitChildNodes(AbstractNodeVisitor<T> visitor) {
            if (this.arguments != null) {
                this.arguments.accept(visitor);
            }
        }

        public Node[] childNodes() {
            return new Node[] { this.arguments };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitYieldNode(this);
        }

        @Override
        protected String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            String nextIndent = indent + "  ";
            builder.append(nextIndent);
            builder.append("arguments: ");
            builder.append(this.arguments == null ? "null\n" : this.arguments.toString(nextIndent));
            return builder.toString();
        }
    }

    public enum ErrorType {
        ALIAS_ARGUMENT,
        ALIAS_ARGUMENT_NUMBERED_REFERENCE,
        AMPAMPEQ_MULTI_ASSIGN,
        ARGUMENT_AFTER_BLOCK,
        ARGUMENT_AFTER_FORWARDING_ELLIPSES,
        ARGUMENT_BARE_HASH,
        ARGUMENT_BLOCK_FORWARDING,
        ARGUMENT_BLOCK_MULTI,
        ARGUMENT_CONFLICT_AMPERSAND,
        ARGUMENT_CONFLICT_STAR,
        ARGUMENT_CONFLICT_STAR_STAR,
        ARGUMENT_FORMAL_CLASS,
        ARGUMENT_FORMAL_CONSTANT,
        ARGUMENT_FORMAL_GLOBAL,
        ARGUMENT_FORMAL_IVAR,
        ARGUMENT_FORWARDING_UNBOUND,
        ARGUMENT_IN,
        ARGUMENT_NO_FORWARDING_AMPERSAND,
        ARGUMENT_NO_FORWARDING_ELLIPSES,
        ARGUMENT_NO_FORWARDING_STAR,
        ARGUMENT_NO_FORWARDING_STAR_STAR,
        ARGUMENT_SPLAT_AFTER_ASSOC_SPLAT,
        ARGUMENT_SPLAT_AFTER_SPLAT,
        ARGUMENT_TERM_PAREN,
        ARGUMENT_UNEXPECTED_BLOCK,
        ARRAY_ELEMENT,
        ARRAY_EXPRESSION,
        ARRAY_EXPRESSION_AFTER_STAR,
        ARRAY_SEPARATOR,
        ARRAY_TERM,
        BEGIN_LONELY_ELSE,
        BEGIN_TERM,
        BEGIN_UPCASE_BRACE,
        BEGIN_UPCASE_TERM,
        BEGIN_UPCASE_TOPLEVEL,
        BLOCK_PARAM_LOCAL_VARIABLE,
        BLOCK_PARAM_PIPE_TERM,
        BLOCK_TERM_BRACE,
        BLOCK_TERM_END,
        CANNOT_PARSE_EXPRESSION,
        CANNOT_PARSE_STRING_PART,
        CASE_EXPRESSION_AFTER_CASE,
        CASE_EXPRESSION_AFTER_WHEN,
        CASE_MATCH_MISSING_PREDICATE,
        CASE_MISSING_CONDITIONS,
        CASE_TERM,
        CLASS_IN_METHOD,
        CLASS_NAME,
        CLASS_SUPERCLASS,
        CLASS_TERM,
        CLASS_UNEXPECTED_END,
        CLASS_VARIABLE_BARE,
        CONDITIONAL_ELSIF_PREDICATE,
        CONDITIONAL_IF_PREDICATE,
        CONDITIONAL_PREDICATE_TERM,
        CONDITIONAL_TERM,
        CONDITIONAL_TERM_ELSE,
        CONDITIONAL_UNLESS_PREDICATE,
        CONDITIONAL_UNTIL_PREDICATE,
        CONDITIONAL_WHILE_PREDICATE,
        CONSTANT_PATH_COLON_COLON_CONSTANT,
        DEF_ENDLESS,
        DEF_ENDLESS_SETTER,
        DEF_NAME,
        DEF_PARAMS_TERM,
        DEF_PARAMS_TERM_PAREN,
        DEF_RECEIVER,
        DEF_RECEIVER_TERM,
        DEF_TERM,
        DEFINED_EXPRESSION,
        EMBDOC_TERM,
        EMBEXPR_END,
        EMBVAR_INVALID,
        END_UPCASE_BRACE,
        END_UPCASE_TERM,
        ESCAPE_INVALID_CONTROL,
        ESCAPE_INVALID_CONTROL_REPEAT,
        ESCAPE_INVALID_HEXADECIMAL,
        ESCAPE_INVALID_META,
        ESCAPE_INVALID_META_REPEAT,
        ESCAPE_INVALID_UNICODE,
        ESCAPE_INVALID_UNICODE_CM_FLAGS,
        ESCAPE_INVALID_UNICODE_LIST,
        ESCAPE_INVALID_UNICODE_LITERAL,
        ESCAPE_INVALID_UNICODE_LONG,
        ESCAPE_INVALID_UNICODE_SHORT,
        ESCAPE_INVALID_UNICODE_TERM,
        EXPECT_ARGUMENT,
        EXPECT_EOL_AFTER_STATEMENT,
        EXPECT_EXPRESSION_AFTER_AMPAMPEQ,
        EXPECT_EXPRESSION_AFTER_COMMA,
        EXPECT_EXPRESSION_AFTER_EQUAL,
        EXPECT_EXPRESSION_AFTER_LESS_LESS,
        EXPECT_EXPRESSION_AFTER_LPAREN,
        EXPECT_EXPRESSION_AFTER_OPERATOR,
        EXPECT_EXPRESSION_AFTER_PIPEPIPEEQ,
        EXPECT_EXPRESSION_AFTER_QUESTION,
        EXPECT_EXPRESSION_AFTER_SPLAT,
        EXPECT_EXPRESSION_AFTER_SPLAT_HASH,
        EXPECT_EXPRESSION_AFTER_STAR,
        EXPECT_IDENT_REQ_PARAMETER,
        EXPECT_IN_DELIMITER,
        EXPECT_LPAREN_REQ_PARAMETER,
        EXPECT_MESSAGE,
        EXPECT_RBRACKET,
        EXPECT_RPAREN,
        EXPECT_RPAREN_AFTER_MULTI,
        EXPECT_RPAREN_REQ_PARAMETER,
        EXPECT_STRING_CONTENT,
        EXPECT_WHEN_DELIMITER,
        EXPRESSION_BARE_HASH,
        EXPRESSION_NOT_WRITABLE,
        EXPRESSION_NOT_WRITABLE_ENCODING,
        EXPRESSION_NOT_WRITABLE_FALSE,
        EXPRESSION_NOT_WRITABLE_FILE,
        EXPRESSION_NOT_WRITABLE_LINE,
        EXPRESSION_NOT_WRITABLE_NIL,
        EXPRESSION_NOT_WRITABLE_NUMBERED,
        EXPRESSION_NOT_WRITABLE_SELF,
        EXPRESSION_NOT_WRITABLE_TRUE,
        FLOAT_PARSE,
        FOR_COLLECTION,
        FOR_IN,
        FOR_INDEX,
        FOR_TERM,
        GLOBAL_VARIABLE_BARE,
        HASH_EXPRESSION_AFTER_LABEL,
        HASH_KEY,
        HASH_ROCKET,
        HASH_TERM,
        HASH_VALUE,
        HEREDOC_IDENTIFIER,
        HEREDOC_TERM,
        INCOMPLETE_QUESTION_MARK,
        INCOMPLETE_VARIABLE_CLASS,
        INCOMPLETE_VARIABLE_CLASS_3_3,
        INCOMPLETE_VARIABLE_INSTANCE,
        INCOMPLETE_VARIABLE_INSTANCE_3_3,
        INSTANCE_VARIABLE_BARE,
        INVALID_BLOCK_EXIT,
        INVALID_CHARACTER,
        INVALID_ENCODING_MAGIC_COMMENT,
        INVALID_ESCAPE_CHARACTER,
        INVALID_FLOAT_EXPONENT,
        INVALID_LOCAL_VARIABLE_READ,
        INVALID_LOCAL_VARIABLE_WRITE,
        INVALID_MULTIBYTE_CHAR,
        INVALID_MULTIBYTE_CHARACTER,
        INVALID_MULTIBYTE_ESCAPE,
        INVALID_NUMBER_BINARY,
        INVALID_NUMBER_DECIMAL,
        INVALID_NUMBER_FRACTION,
        INVALID_NUMBER_HEXADECIMAL,
        INVALID_NUMBER_OCTAL,
        INVALID_NUMBER_UNDERSCORE_INNER,
        INVALID_NUMBER_UNDERSCORE_TRAILING,
        INVALID_PERCENT,
        INVALID_PERCENT_EOF,
        INVALID_PRINTABLE_CHARACTER,
        INVALID_RETRY_AFTER_ELSE,
        INVALID_RETRY_AFTER_ENSURE,
        INVALID_RETRY_WITHOUT_RESCUE,
        INVALID_SYMBOL,
        INVALID_VARIABLE_GLOBAL,
        INVALID_VARIABLE_GLOBAL_3_3,
        INVALID_YIELD,
        IT_NOT_ALLOWED_NUMBERED,
        IT_NOT_ALLOWED_ORDINARY,
        LAMBDA_OPEN,
        LAMBDA_TERM_BRACE,
        LAMBDA_TERM_END,
        LIST_I_LOWER_ELEMENT,
        LIST_I_LOWER_TERM,
        LIST_I_UPPER_ELEMENT,
        LIST_I_UPPER_TERM,
        LIST_W_LOWER_ELEMENT,
        LIST_W_LOWER_TERM,
        LIST_W_UPPER_ELEMENT,
        LIST_W_UPPER_TERM,
        MALLOC_FAILED,
        MIXED_ENCODING,
        MODULE_IN_METHOD,
        MODULE_NAME,
        MODULE_TERM,
        MULTI_ASSIGN_MULTI_SPLATS,
        MULTI_ASSIGN_UNEXPECTED_REST,
        NO_LOCAL_VARIABLE,
        NOT_EXPRESSION,
        NUMBER_LITERAL_UNDERSCORE,
        NUMBERED_PARAMETER_INNER_BLOCK,
        NUMBERED_PARAMETER_IT,
        NUMBERED_PARAMETER_ORDINARY,
        NUMBERED_PARAMETER_OUTER_BLOCK,
        OPERATOR_MULTI_ASSIGN,
        OPERATOR_WRITE_ARGUMENTS,
        OPERATOR_WRITE_BLOCK,
        PARAMETER_ASSOC_SPLAT_MULTI,
        PARAMETER_BLOCK_MULTI,
        PARAMETER_CIRCULAR,
        PARAMETER_FORWARDING_AFTER_REST,
        PARAMETER_METHOD_NAME,
        PARAMETER_NAME_DUPLICATED,
        PARAMETER_NO_DEFAULT,
        PARAMETER_NO_DEFAULT_KW,
        PARAMETER_NUMBERED_RESERVED,
        PARAMETER_ORDER,
        PARAMETER_SPLAT_MULTI,
        PARAMETER_STAR,
        PARAMETER_UNEXPECTED_FWD,
        PARAMETER_UNEXPECTED_NO_KW,
        PARAMETER_WILD_LOOSE_COMMA,
        PATTERN_ARRAY_MULTIPLE_RESTS,
        PATTERN_CAPTURE_DUPLICATE,
        PATTERN_EXPRESSION_AFTER_BRACKET,
        PATTERN_EXPRESSION_AFTER_COMMA,
        PATTERN_EXPRESSION_AFTER_HROCKET,
        PATTERN_EXPRESSION_AFTER_IN,
        PATTERN_EXPRESSION_AFTER_KEY,
        PATTERN_EXPRESSION_AFTER_PAREN,
        PATTERN_EXPRESSION_AFTER_PIN,
        PATTERN_EXPRESSION_AFTER_PIPE,
        PATTERN_EXPRESSION_AFTER_RANGE,
        PATTERN_EXPRESSION_AFTER_REST,
        PATTERN_FIND_MISSING_INNER,
        PATTERN_HASH_IMPLICIT,
        PATTERN_HASH_KEY,
        PATTERN_HASH_KEY_DUPLICATE,
        PATTERN_HASH_KEY_INTERPOLATED,
        PATTERN_HASH_KEY_LABEL,
        PATTERN_HASH_KEY_LOCALS,
        PATTERN_IDENT_AFTER_HROCKET,
        PATTERN_LABEL_AFTER_COMMA,
        PATTERN_REST,
        PATTERN_TERM_BRACE,
        PATTERN_TERM_BRACKET,
        PATTERN_TERM_PAREN,
        PIPEPIPEEQ_MULTI_ASSIGN,
        REGEXP_ENCODING_OPTION_MISMATCH,
        REGEXP_INCOMPAT_CHAR_ENCODING,
        REGEXP_INVALID_UNICODE_RANGE,
        REGEXP_NON_ESCAPED_MBC,
        REGEXP_PARSE_ERROR,
        REGEXP_TERM,
        REGEXP_UNKNOWN_OPTIONS,
        REGEXP_UTF8_CHAR_NON_UTF8_REGEXP,
        RESCUE_EXPRESSION,
        RESCUE_MODIFIER_VALUE,
        RESCUE_TERM,
        RESCUE_VARIABLE,
        RETURN_INVALID,
        SCRIPT_NOT_FOUND,
        SINGLETON_FOR_LITERALS,
        STATEMENT_ALIAS,
        STATEMENT_POSTEXE_END,
        STATEMENT_PREEXE_BEGIN,
        STATEMENT_UNDEF,
        STRING_CONCATENATION,
        STRING_INTERPOLATED_TERM,
        STRING_LITERAL_EOF,
        STRING_LITERAL_TERM,
        SYMBOL_INVALID,
        SYMBOL_TERM_DYNAMIC,
        SYMBOL_TERM_INTERPOLATED,
        TERNARY_COLON,
        TERNARY_EXPRESSION_FALSE,
        TERNARY_EXPRESSION_TRUE,
        UNARY_DISALLOWED,
        UNARY_RECEIVER,
        UNDEF_ARGUMENT,
        UNEXPECTED_BLOCK_ARGUMENT,
        UNEXPECTED_INDEX_BLOCK,
        UNEXPECTED_INDEX_KEYWORDS,
        UNEXPECTED_MULTI_WRITE,
        UNEXPECTED_RANGE_OPERATOR,
        UNEXPECTED_SAFE_NAVIGATION,
        UNEXPECTED_TOKEN_CLOSE_CONTEXT,
        UNEXPECTED_TOKEN_IGNORE,
        UNTIL_TERM,
        VOID_EXPRESSION,
        WHILE_TERM,
        WRITE_TARGET_IN_METHOD,
        WRITE_TARGET_READONLY,
        WRITE_TARGET_UNEXPECTED,
        XSTRING_TERM,
    }

    public static ErrorType[] ERROR_TYPES = ErrorType.values();

    public enum WarningType {
        AMBIGUOUS_BINARY_OPERATOR,
        AMBIGUOUS_FIRST_ARGUMENT_MINUS,
        AMBIGUOUS_FIRST_ARGUMENT_PLUS,
        AMBIGUOUS_PREFIX_AMPERSAND,
        AMBIGUOUS_PREFIX_STAR,
        AMBIGUOUS_PREFIX_STAR_STAR,
        AMBIGUOUS_SLASH,
        COMPARISON_AFTER_COMPARISON,
        DOT_DOT_DOT_EOL,
        EQUAL_IN_CONDITIONAL,
        EQUAL_IN_CONDITIONAL_3_3,
        END_IN_METHOD,
        DUPLICATED_HASH_KEY,
        DUPLICATED_WHEN_CLAUSE,
        FLOAT_OUT_OF_RANGE,
        IGNORED_FROZEN_STRING_LITERAL,
        INDENTATION_MISMATCH,
        INTEGER_IN_FLIP_FLOP,
        INVALID_CHARACTER,
        INVALID_MAGIC_COMMENT_VALUE,
        INVALID_NUMBERED_REFERENCE,
        KEYWORD_EOL,
        LITERAL_IN_CONDITION_DEFAULT,
        LITERAL_IN_CONDITION_VERBOSE,
        SHAREABLE_CONSTANT_VALUE_LINE,
        SHEBANG_CARRIAGE_RETURN,
        UNEXPECTED_CARRIAGE_RETURN,
        UNREACHABLE_STATEMENT,
        UNUSED_LOCAL_VARIABLE,
        VOID_STATEMENT,
    }

    public static WarningType[] WARNING_TYPES = WarningType.values();
}
// @formatter:on
