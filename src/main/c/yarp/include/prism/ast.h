/******************************************************************************/
/* This file is generated by the templates/template.rb script and should not  */
/* be modified manually. See                                                  */
/* templates/include/prism/ast.h.erb                                          */
/* if you are looking to modify the                                           */
/* template                                                                   */
/******************************************************************************/
#ifndef PRISM_AST_H
#define PRISM_AST_H

#include "prism/defines.h"
#include "prism/util/pm_constant_pool.h"
#include "prism/util/pm_string.h"

#include <assert.h>
#include <stddef.h>
#include <stdint.h>

// This enum represents every type of token in the Ruby source.
typedef enum pm_token_type {
    PM_TOKEN_EOF = 1, // final token in the file
    PM_TOKEN_MISSING, // a token that was expected but not found
    PM_TOKEN_NOT_PROVIDED, // a token that was not present but it is okay
    PM_TOKEN_AMPERSAND, // &
    PM_TOKEN_AMPERSAND_AMPERSAND, // &&
    PM_TOKEN_AMPERSAND_AMPERSAND_EQUAL, // &&=
    PM_TOKEN_AMPERSAND_DOT, // &.
    PM_TOKEN_AMPERSAND_EQUAL, // &=
    PM_TOKEN_BACKTICK, // `
    PM_TOKEN_BACK_REFERENCE, // a back reference
    PM_TOKEN_BANG, // ! or !@
    PM_TOKEN_BANG_EQUAL, // !=
    PM_TOKEN_BANG_TILDE, // !~
    PM_TOKEN_BRACE_LEFT, // {
    PM_TOKEN_BRACE_RIGHT, // }
    PM_TOKEN_BRACKET_LEFT, // [
    PM_TOKEN_BRACKET_LEFT_ARRAY, // [ for the beginning of an array
    PM_TOKEN_BRACKET_LEFT_RIGHT, // []
    PM_TOKEN_BRACKET_LEFT_RIGHT_EQUAL, // []=
    PM_TOKEN_BRACKET_RIGHT, // ]
    PM_TOKEN_CARET, // ^
    PM_TOKEN_CARET_EQUAL, // ^=
    PM_TOKEN_CHARACTER_LITERAL, // a character literal
    PM_TOKEN_CLASS_VARIABLE, // a class variable
    PM_TOKEN_COLON, // :
    PM_TOKEN_COLON_COLON, // ::
    PM_TOKEN_COMMA, // ,
    PM_TOKEN_COMMENT, // a comment
    PM_TOKEN_CONSTANT, // a constant
    PM_TOKEN_DOT, // .
    PM_TOKEN_DOT_DOT, // ..
    PM_TOKEN_DOT_DOT_DOT, // ...
    PM_TOKEN_EMBDOC_BEGIN, // =begin
    PM_TOKEN_EMBDOC_END, // =end
    PM_TOKEN_EMBDOC_LINE, // a line inside of embedded documentation
    PM_TOKEN_EMBEXPR_BEGIN, // #{
    PM_TOKEN_EMBEXPR_END, // }
    PM_TOKEN_EMBVAR, // #
    PM_TOKEN_EQUAL, // =
    PM_TOKEN_EQUAL_EQUAL, // ==
    PM_TOKEN_EQUAL_EQUAL_EQUAL, // ===
    PM_TOKEN_EQUAL_GREATER, // =>
    PM_TOKEN_EQUAL_TILDE, // =~
    PM_TOKEN_FLOAT, // a floating point number
    PM_TOKEN_FLOAT_IMAGINARY, // a floating pointer number with an imaginary suffix
    PM_TOKEN_FLOAT_RATIONAL, // a floating pointer number with a rational suffix
    PM_TOKEN_FLOAT_RATIONAL_IMAGINARY, // a floating pointer number with a rational and imaginary suffix
    PM_TOKEN_GLOBAL_VARIABLE, // a global variable
    PM_TOKEN_GREATER, // >
    PM_TOKEN_GREATER_EQUAL, // >=
    PM_TOKEN_GREATER_GREATER, // >>
    PM_TOKEN_GREATER_GREATER_EQUAL, // >>=
    PM_TOKEN_HEREDOC_END, // the end of a heredoc
    PM_TOKEN_HEREDOC_START, // the start of a heredoc
    PM_TOKEN_IDENTIFIER, // an identifier
    PM_TOKEN_IGNORED_NEWLINE, // an ignored newline
    PM_TOKEN_INSTANCE_VARIABLE, // an instance variable
    PM_TOKEN_INTEGER, // an integer (any base)
    PM_TOKEN_INTEGER_IMAGINARY, // an integer with an imaginary suffix
    PM_TOKEN_INTEGER_RATIONAL, // an integer with a rational suffix
    PM_TOKEN_INTEGER_RATIONAL_IMAGINARY, // an integer with a rational and imaginary suffix
    PM_TOKEN_KEYWORD_ALIAS, // alias
    PM_TOKEN_KEYWORD_AND, // and
    PM_TOKEN_KEYWORD_BEGIN, // begin
    PM_TOKEN_KEYWORD_BEGIN_UPCASE, // BEGIN
    PM_TOKEN_KEYWORD_BREAK, // break
    PM_TOKEN_KEYWORD_CASE, // case
    PM_TOKEN_KEYWORD_CLASS, // class
    PM_TOKEN_KEYWORD_DEF, // def
    PM_TOKEN_KEYWORD_DEFINED, // defined?
    PM_TOKEN_KEYWORD_DO, // do
    PM_TOKEN_KEYWORD_DO_LOOP, // do keyword for a predicate in a while, until, or for loop
    PM_TOKEN_KEYWORD_ELSE, // else
    PM_TOKEN_KEYWORD_ELSIF, // elsif
    PM_TOKEN_KEYWORD_END, // end
    PM_TOKEN_KEYWORD_END_UPCASE, // END
    PM_TOKEN_KEYWORD_ENSURE, // ensure
    PM_TOKEN_KEYWORD_FALSE, // false
    PM_TOKEN_KEYWORD_FOR, // for
    PM_TOKEN_KEYWORD_IF, // if
    PM_TOKEN_KEYWORD_IF_MODIFIER, // if in the modifier form
    PM_TOKEN_KEYWORD_IN, // in
    PM_TOKEN_KEYWORD_MODULE, // module
    PM_TOKEN_KEYWORD_NEXT, // next
    PM_TOKEN_KEYWORD_NIL, // nil
    PM_TOKEN_KEYWORD_NOT, // not
    PM_TOKEN_KEYWORD_OR, // or
    PM_TOKEN_KEYWORD_REDO, // redo
    PM_TOKEN_KEYWORD_RESCUE, // rescue
    PM_TOKEN_KEYWORD_RESCUE_MODIFIER, // rescue in the modifier form
    PM_TOKEN_KEYWORD_RETRY, // retry
    PM_TOKEN_KEYWORD_RETURN, // return
    PM_TOKEN_KEYWORD_SELF, // self
    PM_TOKEN_KEYWORD_SUPER, // super
    PM_TOKEN_KEYWORD_THEN, // then
    PM_TOKEN_KEYWORD_TRUE, // true
    PM_TOKEN_KEYWORD_UNDEF, // undef
    PM_TOKEN_KEYWORD_UNLESS, // unless
    PM_TOKEN_KEYWORD_UNLESS_MODIFIER, // unless in the modifier form
    PM_TOKEN_KEYWORD_UNTIL, // until
    PM_TOKEN_KEYWORD_UNTIL_MODIFIER, // until in the modifier form
    PM_TOKEN_KEYWORD_WHEN, // when
    PM_TOKEN_KEYWORD_WHILE, // while
    PM_TOKEN_KEYWORD_WHILE_MODIFIER, // while in the modifier form
    PM_TOKEN_KEYWORD_YIELD, // yield
    PM_TOKEN_KEYWORD___ENCODING__, // __ENCODING__
    PM_TOKEN_KEYWORD___FILE__, // __FILE__
    PM_TOKEN_KEYWORD___LINE__, // __LINE__
    PM_TOKEN_LABEL, // a label
    PM_TOKEN_LABEL_END, // the end of a label
    PM_TOKEN_LAMBDA_BEGIN, // {
    PM_TOKEN_LESS, // <
    PM_TOKEN_LESS_EQUAL, // <=
    PM_TOKEN_LESS_EQUAL_GREATER, // <=>
    PM_TOKEN_LESS_LESS, // <<
    PM_TOKEN_LESS_LESS_EQUAL, // <<=
    PM_TOKEN_METHOD_NAME, // a method name
    PM_TOKEN_MINUS, // -
    PM_TOKEN_MINUS_EQUAL, // -=
    PM_TOKEN_MINUS_GREATER, // ->
    PM_TOKEN_NEWLINE, // a newline character outside of other tokens
    PM_TOKEN_NUMBERED_REFERENCE, // a numbered reference to a capture group in the previous regular expression match
    PM_TOKEN_PARENTHESIS_LEFT, // (
    PM_TOKEN_PARENTHESIS_LEFT_PARENTHESES, // ( for a parentheses node
    PM_TOKEN_PARENTHESIS_RIGHT, // )
    PM_TOKEN_PERCENT, // %
    PM_TOKEN_PERCENT_EQUAL, // %=
    PM_TOKEN_PERCENT_LOWER_I, // %i
    PM_TOKEN_PERCENT_LOWER_W, // %w
    PM_TOKEN_PERCENT_LOWER_X, // %x
    PM_TOKEN_PERCENT_UPPER_I, // %I
    PM_TOKEN_PERCENT_UPPER_W, // %W
    PM_TOKEN_PIPE, // |
    PM_TOKEN_PIPE_EQUAL, // |=
    PM_TOKEN_PIPE_PIPE, // ||
    PM_TOKEN_PIPE_PIPE_EQUAL, // ||=
    PM_TOKEN_PLUS, // +
    PM_TOKEN_PLUS_EQUAL, // +=
    PM_TOKEN_QUESTION_MARK, // ?
    PM_TOKEN_REGEXP_BEGIN, // the beginning of a regular expression
    PM_TOKEN_REGEXP_END, // the end of a regular expression
    PM_TOKEN_SEMICOLON, // ;
    PM_TOKEN_SLASH, // /
    PM_TOKEN_SLASH_EQUAL, // /=
    PM_TOKEN_STAR, // *
    PM_TOKEN_STAR_EQUAL, // *=
    PM_TOKEN_STAR_STAR, // **
    PM_TOKEN_STAR_STAR_EQUAL, // **=
    PM_TOKEN_STRING_BEGIN, // the beginning of a string
    PM_TOKEN_STRING_CONTENT, // the contents of a string
    PM_TOKEN_STRING_END, // the end of a string
    PM_TOKEN_SYMBOL_BEGIN, // the beginning of a symbol
    PM_TOKEN_TILDE, // ~ or ~@
    PM_TOKEN_UAMPERSAND, // unary &
    PM_TOKEN_UCOLON_COLON, // unary ::
    PM_TOKEN_UDOT_DOT, // unary ..
    PM_TOKEN_UDOT_DOT_DOT, // unary ...
    PM_TOKEN_UMINUS, // -@
    PM_TOKEN_UMINUS_NUM, // -@ for a number
    PM_TOKEN_UPLUS, // +@
    PM_TOKEN_USTAR, // unary *
    PM_TOKEN_USTAR_STAR, // unary **
    PM_TOKEN_WORDS_SEP, // a separator between words in a list
    PM_TOKEN___END__, // marker for the point in the file at which the parser should stop
    PM_TOKEN_MAXIMUM, // the maximum token value
} pm_token_type_t;

// This struct represents a token in the Ruby source. We use it to track both
// type and location information.
typedef struct {
    pm_token_type_t type;
    const uint8_t *start;
    const uint8_t *end;
} pm_token_t;

// This represents a range of bytes in the source string to which a node or
// token corresponds.
typedef struct {
    const uint8_t *start;
    const uint8_t *end;
} pm_location_t;

struct pm_node;

typedef struct pm_node_list {
    struct pm_node **nodes;
    size_t size;
    size_t capacity;
} pm_node_list_t;

enum pm_node_type {
    PM_ALIAS_GLOBAL_VARIABLE_NODE = 1,
    PM_ALIAS_METHOD_NODE = 2,
    PM_ALTERNATION_PATTERN_NODE = 3,
    PM_AND_NODE = 4,
    PM_ARGUMENTS_NODE = 5,
    PM_ARRAY_NODE = 6,
    PM_ARRAY_PATTERN_NODE = 7,
    PM_ASSOC_NODE = 8,
    PM_ASSOC_SPLAT_NODE = 9,
    PM_BACK_REFERENCE_READ_NODE = 10,
    PM_BEGIN_NODE = 11,
    PM_BLOCK_ARGUMENT_NODE = 12,
    PM_BLOCK_LOCAL_VARIABLE_NODE = 13,
    PM_BLOCK_NODE = 14,
    PM_BLOCK_PARAMETER_NODE = 15,
    PM_BLOCK_PARAMETERS_NODE = 16,
    PM_BREAK_NODE = 17,
    PM_CALL_AND_WRITE_NODE = 18,
    PM_CALL_NODE = 19,
    PM_CALL_OPERATOR_WRITE_NODE = 20,
    PM_CALL_OR_WRITE_NODE = 21,
    PM_CAPTURE_PATTERN_NODE = 22,
    PM_CASE_NODE = 23,
    PM_CLASS_NODE = 24,
    PM_CLASS_VARIABLE_AND_WRITE_NODE = 25,
    PM_CLASS_VARIABLE_OPERATOR_WRITE_NODE = 26,
    PM_CLASS_VARIABLE_OR_WRITE_NODE = 27,
    PM_CLASS_VARIABLE_READ_NODE = 28,
    PM_CLASS_VARIABLE_TARGET_NODE = 29,
    PM_CLASS_VARIABLE_WRITE_NODE = 30,
    PM_CONSTANT_AND_WRITE_NODE = 31,
    PM_CONSTANT_OPERATOR_WRITE_NODE = 32,
    PM_CONSTANT_OR_WRITE_NODE = 33,
    PM_CONSTANT_PATH_AND_WRITE_NODE = 34,
    PM_CONSTANT_PATH_NODE = 35,
    PM_CONSTANT_PATH_OPERATOR_WRITE_NODE = 36,
    PM_CONSTANT_PATH_OR_WRITE_NODE = 37,
    PM_CONSTANT_PATH_TARGET_NODE = 38,
    PM_CONSTANT_PATH_WRITE_NODE = 39,
    PM_CONSTANT_READ_NODE = 40,
    PM_CONSTANT_TARGET_NODE = 41,
    PM_CONSTANT_WRITE_NODE = 42,
    PM_DEF_NODE = 43,
    PM_DEFINED_NODE = 44,
    PM_ELSE_NODE = 45,
    PM_EMBEDDED_STATEMENTS_NODE = 46,
    PM_EMBEDDED_VARIABLE_NODE = 47,
    PM_ENSURE_NODE = 48,
    PM_FALSE_NODE = 49,
    PM_FIND_PATTERN_NODE = 50,
    PM_FLIP_FLOP_NODE = 51,
    PM_FLOAT_NODE = 52,
    PM_FOR_NODE = 53,
    PM_FORWARDING_ARGUMENTS_NODE = 54,
    PM_FORWARDING_PARAMETER_NODE = 55,
    PM_FORWARDING_SUPER_NODE = 56,
    PM_GLOBAL_VARIABLE_AND_WRITE_NODE = 57,
    PM_GLOBAL_VARIABLE_OPERATOR_WRITE_NODE = 58,
    PM_GLOBAL_VARIABLE_OR_WRITE_NODE = 59,
    PM_GLOBAL_VARIABLE_READ_NODE = 60,
    PM_GLOBAL_VARIABLE_TARGET_NODE = 61,
    PM_GLOBAL_VARIABLE_WRITE_NODE = 62,
    PM_HASH_NODE = 63,
    PM_HASH_PATTERN_NODE = 64,
    PM_IF_NODE = 65,
    PM_IMAGINARY_NODE = 66,
    PM_IMPLICIT_NODE = 67,
    PM_IN_NODE = 68,
    PM_INDEX_AND_WRITE_NODE = 69,
    PM_INDEX_OPERATOR_WRITE_NODE = 70,
    PM_INDEX_OR_WRITE_NODE = 71,
    PM_INSTANCE_VARIABLE_AND_WRITE_NODE = 72,
    PM_INSTANCE_VARIABLE_OPERATOR_WRITE_NODE = 73,
    PM_INSTANCE_VARIABLE_OR_WRITE_NODE = 74,
    PM_INSTANCE_VARIABLE_READ_NODE = 75,
    PM_INSTANCE_VARIABLE_TARGET_NODE = 76,
    PM_INSTANCE_VARIABLE_WRITE_NODE = 77,
    PM_INTEGER_NODE = 78,
    PM_INTERPOLATED_MATCH_LAST_LINE_NODE = 79,
    PM_INTERPOLATED_REGULAR_EXPRESSION_NODE = 80,
    PM_INTERPOLATED_STRING_NODE = 81,
    PM_INTERPOLATED_SYMBOL_NODE = 82,
    PM_INTERPOLATED_X_STRING_NODE = 83,
    PM_KEYWORD_HASH_NODE = 84,
    PM_KEYWORD_PARAMETER_NODE = 85,
    PM_KEYWORD_REST_PARAMETER_NODE = 86,
    PM_LAMBDA_NODE = 87,
    PM_LOCAL_VARIABLE_AND_WRITE_NODE = 88,
    PM_LOCAL_VARIABLE_OPERATOR_WRITE_NODE = 89,
    PM_LOCAL_VARIABLE_OR_WRITE_NODE = 90,
    PM_LOCAL_VARIABLE_READ_NODE = 91,
    PM_LOCAL_VARIABLE_TARGET_NODE = 92,
    PM_LOCAL_VARIABLE_WRITE_NODE = 93,
    PM_MATCH_LAST_LINE_NODE = 94,
    PM_MATCH_PREDICATE_NODE = 95,
    PM_MATCH_REQUIRED_NODE = 96,
    PM_MATCH_WRITE_NODE = 97,
    PM_MISSING_NODE = 98,
    PM_MODULE_NODE = 99,
    PM_MULTI_TARGET_NODE = 100,
    PM_MULTI_WRITE_NODE = 101,
    PM_NEXT_NODE = 102,
    PM_NIL_NODE = 103,
    PM_NO_KEYWORDS_PARAMETER_NODE = 104,
    PM_NUMBERED_REFERENCE_READ_NODE = 105,
    PM_OPTIONAL_PARAMETER_NODE = 106,
    PM_OR_NODE = 107,
    PM_PARAMETERS_NODE = 108,
    PM_PARENTHESES_NODE = 109,
    PM_PINNED_EXPRESSION_NODE = 110,
    PM_PINNED_VARIABLE_NODE = 111,
    PM_POST_EXECUTION_NODE = 112,
    PM_PRE_EXECUTION_NODE = 113,
    PM_PROGRAM_NODE = 114,
    PM_RANGE_NODE = 115,
    PM_RATIONAL_NODE = 116,
    PM_REDO_NODE = 117,
    PM_REGULAR_EXPRESSION_NODE = 118,
    PM_REQUIRED_PARAMETER_NODE = 119,
    PM_RESCUE_MODIFIER_NODE = 120,
    PM_RESCUE_NODE = 121,
    PM_REST_PARAMETER_NODE = 122,
    PM_RETRY_NODE = 123,
    PM_RETURN_NODE = 124,
    PM_SELF_NODE = 125,
    PM_SINGLETON_CLASS_NODE = 126,
    PM_SOURCE_ENCODING_NODE = 127,
    PM_SOURCE_FILE_NODE = 128,
    PM_SOURCE_LINE_NODE = 129,
    PM_SPLAT_NODE = 130,
    PM_STATEMENTS_NODE = 131,
    PM_STRING_CONCAT_NODE = 132,
    PM_STRING_NODE = 133,
    PM_SUPER_NODE = 134,
    PM_SYMBOL_NODE = 135,
    PM_TRUE_NODE = 136,
    PM_UNDEF_NODE = 137,
    PM_UNLESS_NODE = 138,
    PM_UNTIL_NODE = 139,
    PM_WHEN_NODE = 140,
    PM_WHILE_NODE = 141,
    PM_X_STRING_NODE = 142,
    PM_YIELD_NODE = 143,
    PM_SCOPE_NODE
};

typedef uint16_t pm_node_type_t;
typedef uint16_t pm_node_flags_t;

// We store the flags enum in every node in the tree. Some flags are common to
// all nodes (the ones listed below). Others are specific to certain node types.
#define PM_NODE_FLAG_BITS (sizeof(pm_node_flags_t) * 8)
static const pm_node_flags_t PM_NODE_FLAG_NEWLINE = (1 << (PM_NODE_FLAG_BITS - 1));
static const pm_node_flags_t PM_NODE_FLAG_STATIC_LITERAL = (1 << (PM_NODE_FLAG_BITS - 2));
static const pm_node_flags_t PM_NODE_FLAG_COMMON_MASK = (1 << (PM_NODE_FLAG_BITS - 1)) | (1 << (PM_NODE_FLAG_BITS - 2));

// For easy access, we define some macros to check node type
#define PM_NODE_TYPE(node) ((enum pm_node_type)node->type)
#define PM_NODE_TYPE_P(node, type) (PM_NODE_TYPE(node) == (type))

// This is the overall tagged union representing a node in the syntax tree.
typedef struct pm_node {
    // This represents the type of the node. It somewhat maps to the nodes that
    // existed in the original grammar and ripper, but it's not a 1:1 mapping.
    pm_node_type_t type;

    // This represents any flags on the node
    pm_node_flags_t flags;

    // This is the location of the node in the source. It's a range of bytes
    // containing a start and an end.
    pm_location_t location;
} pm_node_t;

// AliasGlobalVariableNode
//
// Type: PM_ALIAS_GLOBAL_VARIABLE_NODE
typedef struct pm_alias_global_variable_node {
    pm_node_t base;
    struct pm_node *new_name;
    struct pm_node *old_name;
    pm_location_t keyword_loc;
} pm_alias_global_variable_node_t;

// AliasMethodNode
//
// Type: PM_ALIAS_METHOD_NODE
typedef struct pm_alias_method_node {
    pm_node_t base;
    struct pm_node *new_name;
    struct pm_node *old_name;
    pm_location_t keyword_loc;
} pm_alias_method_node_t;

// AlternationPatternNode
//
// Type: PM_ALTERNATION_PATTERN_NODE
typedef struct pm_alternation_pattern_node {
    pm_node_t base;
    struct pm_node *left;
    struct pm_node *right;
    pm_location_t operator_loc;
} pm_alternation_pattern_node_t;

// AndNode
//
// Type: PM_AND_NODE
typedef struct pm_and_node {
    pm_node_t base;
    struct pm_node *left;
    struct pm_node *right;
    pm_location_t operator_loc;
} pm_and_node_t;

// ArgumentsNode
//
// Type: PM_ARGUMENTS_NODE
// Flags:
//    PM_ARGUMENTS_NODE_FLAGS_KEYWORD_SPLAT
typedef struct pm_arguments_node {
    pm_node_t base;
    struct pm_node_list arguments;
} pm_arguments_node_t;

// ArrayNode
//
// Type: PM_ARRAY_NODE
typedef struct pm_array_node {
    pm_node_t base;
    struct pm_node_list elements;
    pm_location_t opening_loc;
    pm_location_t closing_loc;
} pm_array_node_t;

// ArrayPatternNode
//
// Type: PM_ARRAY_PATTERN_NODE
typedef struct pm_array_pattern_node {
    pm_node_t base;
    struct pm_node *constant;
    struct pm_node_list requireds;
    struct pm_node *rest;
    struct pm_node_list posts;
    pm_location_t opening_loc;
    pm_location_t closing_loc;
} pm_array_pattern_node_t;

// AssocNode
//
// Type: PM_ASSOC_NODE
typedef struct pm_assoc_node {
    pm_node_t base;
    struct pm_node *key;
    struct pm_node *value;
    pm_location_t operator_loc;
} pm_assoc_node_t;

// AssocSplatNode
//
// Type: PM_ASSOC_SPLAT_NODE
typedef struct pm_assoc_splat_node {
    pm_node_t base;
    struct pm_node *value;
    pm_location_t operator_loc;
} pm_assoc_splat_node_t;

// BackReferenceReadNode
//
// Type: PM_BACK_REFERENCE_READ_NODE
typedef struct pm_back_reference_read_node {
    pm_node_t base;
    pm_constant_id_t name;
} pm_back_reference_read_node_t;

// BeginNode
//
// Type: PM_BEGIN_NODE
typedef struct pm_begin_node {
    pm_node_t base;
    pm_location_t begin_keyword_loc;
    struct pm_statements_node *statements;
    struct pm_rescue_node *rescue_clause;
    struct pm_else_node *else_clause;
    struct pm_ensure_node *ensure_clause;
    pm_location_t end_keyword_loc;
} pm_begin_node_t;

// BlockArgumentNode
//
// Type: PM_BLOCK_ARGUMENT_NODE
typedef struct pm_block_argument_node {
    pm_node_t base;
    struct pm_node *expression;
    pm_location_t operator_loc;
} pm_block_argument_node_t;

// BlockLocalVariableNode
//
// Type: PM_BLOCK_LOCAL_VARIABLE_NODE
typedef struct pm_block_local_variable_node {
    pm_node_t base;
    pm_constant_id_t name;
} pm_block_local_variable_node_t;

// BlockNode
//
// Type: PM_BLOCK_NODE
typedef struct pm_block_node {
    pm_node_t base;
    pm_constant_id_list_t locals;
    struct pm_block_parameters_node *parameters;
    struct pm_node *body;
    pm_location_t opening_loc;
    pm_location_t closing_loc;
} pm_block_node_t;

// BlockParameterNode
//
// Type: PM_BLOCK_PARAMETER_NODE
typedef struct pm_block_parameter_node {
    pm_node_t base;
    pm_constant_id_t name;
    pm_location_t name_loc;
    pm_location_t operator_loc;
} pm_block_parameter_node_t;

// BlockParametersNode
//
// Type: PM_BLOCK_PARAMETERS_NODE
typedef struct pm_block_parameters_node {
    pm_node_t base;
    struct pm_parameters_node *parameters;
    struct pm_node_list locals;
    pm_location_t opening_loc;
    pm_location_t closing_loc;
} pm_block_parameters_node_t;

// BreakNode
//
// Type: PM_BREAK_NODE
typedef struct pm_break_node {
    pm_node_t base;
    struct pm_arguments_node *arguments;
    pm_location_t keyword_loc;
} pm_break_node_t;

// CallAndWriteNode
//
// Type: PM_CALL_AND_WRITE_NODE
// Flags:
//    PM_CALL_NODE_FLAGS_SAFE_NAVIGATION
//    PM_CALL_NODE_FLAGS_VARIABLE_CALL
typedef struct pm_call_and_write_node {
    pm_node_t base;
    struct pm_node *receiver;
    pm_location_t call_operator_loc;
    pm_location_t message_loc;
    pm_constant_id_t read_name;
    pm_constant_id_t write_name;
    pm_location_t operator_loc;
    struct pm_node *value;
} pm_call_and_write_node_t;

// CallNode
//
// Type: PM_CALL_NODE
// Flags:
//    PM_CALL_NODE_FLAGS_SAFE_NAVIGATION
//    PM_CALL_NODE_FLAGS_VARIABLE_CALL
typedef struct pm_call_node {
    pm_node_t base;
    struct pm_node *receiver;
    pm_location_t call_operator_loc;
    pm_location_t message_loc;
    pm_location_t opening_loc;
    struct pm_arguments_node *arguments;
    pm_location_t closing_loc;
    struct pm_node *block;
    pm_constant_id_t name;
} pm_call_node_t;

// CallOperatorWriteNode
//
// Type: PM_CALL_OPERATOR_WRITE_NODE
// Flags:
//    PM_CALL_NODE_FLAGS_SAFE_NAVIGATION
//    PM_CALL_NODE_FLAGS_VARIABLE_CALL
typedef struct pm_call_operator_write_node {
    pm_node_t base;
    struct pm_node *receiver;
    pm_location_t call_operator_loc;
    pm_location_t message_loc;
    pm_constant_id_t read_name;
    pm_constant_id_t write_name;
    pm_constant_id_t operator;
    pm_location_t operator_loc;
    struct pm_node *value;
} pm_call_operator_write_node_t;

// CallOrWriteNode
//
// Type: PM_CALL_OR_WRITE_NODE
// Flags:
//    PM_CALL_NODE_FLAGS_SAFE_NAVIGATION
//    PM_CALL_NODE_FLAGS_VARIABLE_CALL
typedef struct pm_call_or_write_node {
    pm_node_t base;
    struct pm_node *receiver;
    pm_location_t call_operator_loc;
    pm_location_t message_loc;
    pm_constant_id_t read_name;
    pm_constant_id_t write_name;
    pm_location_t operator_loc;
    struct pm_node *value;
} pm_call_or_write_node_t;

// CapturePatternNode
//
// Type: PM_CAPTURE_PATTERN_NODE
typedef struct pm_capture_pattern_node {
    pm_node_t base;
    struct pm_node *value;
    struct pm_node *target;
    pm_location_t operator_loc;
} pm_capture_pattern_node_t;

// CaseNode
//
// Type: PM_CASE_NODE
typedef struct pm_case_node {
    pm_node_t base;
    struct pm_node *predicate;
    struct pm_node_list conditions;
    struct pm_else_node *consequent;
    pm_location_t case_keyword_loc;
    pm_location_t end_keyword_loc;
} pm_case_node_t;

// ClassNode
//
// Type: PM_CLASS_NODE
typedef struct pm_class_node {
    pm_node_t base;
    pm_constant_id_list_t locals;
    pm_location_t class_keyword_loc;
    struct pm_node *constant_path;
    pm_location_t inheritance_operator_loc;
    struct pm_node *superclass;
    struct pm_node *body;
    pm_location_t end_keyword_loc;
    pm_constant_id_t name;
} pm_class_node_t;

// ClassVariableAndWriteNode
//
// Type: PM_CLASS_VARIABLE_AND_WRITE_NODE
typedef struct pm_class_variable_and_write_node {
    pm_node_t base;
    pm_constant_id_t name;
    pm_location_t name_loc;
    pm_location_t operator_loc;
    struct pm_node *value;
} pm_class_variable_and_write_node_t;

// ClassVariableOperatorWriteNode
//
// Type: PM_CLASS_VARIABLE_OPERATOR_WRITE_NODE
typedef struct pm_class_variable_operator_write_node {
    pm_node_t base;
    pm_constant_id_t name;
    pm_location_t name_loc;
    pm_location_t operator_loc;
    struct pm_node *value;
    pm_constant_id_t operator;
} pm_class_variable_operator_write_node_t;

// ClassVariableOrWriteNode
//
// Type: PM_CLASS_VARIABLE_OR_WRITE_NODE
typedef struct pm_class_variable_or_write_node {
    pm_node_t base;
    pm_constant_id_t name;
    pm_location_t name_loc;
    pm_location_t operator_loc;
    struct pm_node *value;
} pm_class_variable_or_write_node_t;

// ClassVariableReadNode
//
// Type: PM_CLASS_VARIABLE_READ_NODE
typedef struct pm_class_variable_read_node {
    pm_node_t base;
    pm_constant_id_t name;
} pm_class_variable_read_node_t;

// ClassVariableTargetNode
//
// Type: PM_CLASS_VARIABLE_TARGET_NODE
typedef struct pm_class_variable_target_node {
    pm_node_t base;
    pm_constant_id_t name;
} pm_class_variable_target_node_t;

// ClassVariableWriteNode
//
// Type: PM_CLASS_VARIABLE_WRITE_NODE
typedef struct pm_class_variable_write_node {
    pm_node_t base;
    pm_constant_id_t name;
    pm_location_t name_loc;
    struct pm_node *value;
    pm_location_t operator_loc;
} pm_class_variable_write_node_t;

// ConstantAndWriteNode
//
// Type: PM_CONSTANT_AND_WRITE_NODE
typedef struct pm_constant_and_write_node {
    pm_node_t base;
    pm_constant_id_t name;
    pm_location_t name_loc;
    pm_location_t operator_loc;
    struct pm_node *value;
} pm_constant_and_write_node_t;

// ConstantOperatorWriteNode
//
// Type: PM_CONSTANT_OPERATOR_WRITE_NODE
typedef struct pm_constant_operator_write_node {
    pm_node_t base;
    pm_constant_id_t name;
    pm_location_t name_loc;
    pm_location_t operator_loc;
    struct pm_node *value;
    pm_constant_id_t operator;
} pm_constant_operator_write_node_t;

// ConstantOrWriteNode
//
// Type: PM_CONSTANT_OR_WRITE_NODE
typedef struct pm_constant_or_write_node {
    pm_node_t base;
    pm_constant_id_t name;
    pm_location_t name_loc;
    pm_location_t operator_loc;
    struct pm_node *value;
} pm_constant_or_write_node_t;

// ConstantPathAndWriteNode
//
// Type: PM_CONSTANT_PATH_AND_WRITE_NODE
typedef struct pm_constant_path_and_write_node {
    pm_node_t base;
    struct pm_constant_path_node *target;
    pm_location_t operator_loc;
    struct pm_node *value;
} pm_constant_path_and_write_node_t;

// ConstantPathNode
//
// Type: PM_CONSTANT_PATH_NODE
typedef struct pm_constant_path_node {
    pm_node_t base;
    struct pm_node *parent;
    struct pm_node *child;
    pm_location_t delimiter_loc;
} pm_constant_path_node_t;

// ConstantPathOperatorWriteNode
//
// Type: PM_CONSTANT_PATH_OPERATOR_WRITE_NODE
typedef struct pm_constant_path_operator_write_node {
    pm_node_t base;
    struct pm_constant_path_node *target;
    pm_location_t operator_loc;
    struct pm_node *value;
    pm_constant_id_t operator;
} pm_constant_path_operator_write_node_t;

// ConstantPathOrWriteNode
//
// Type: PM_CONSTANT_PATH_OR_WRITE_NODE
typedef struct pm_constant_path_or_write_node {
    pm_node_t base;
    struct pm_constant_path_node *target;
    pm_location_t operator_loc;
    struct pm_node *value;
} pm_constant_path_or_write_node_t;

// ConstantPathTargetNode
//
// Type: PM_CONSTANT_PATH_TARGET_NODE
typedef struct pm_constant_path_target_node {
    pm_node_t base;
    struct pm_node *parent;
    struct pm_node *child;
    pm_location_t delimiter_loc;
} pm_constant_path_target_node_t;

// ConstantPathWriteNode
//
// Type: PM_CONSTANT_PATH_WRITE_NODE
typedef struct pm_constant_path_write_node {
    pm_node_t base;
    struct pm_constant_path_node *target;
    pm_location_t operator_loc;
    struct pm_node *value;
} pm_constant_path_write_node_t;

// ConstantReadNode
//
// Type: PM_CONSTANT_READ_NODE
typedef struct pm_constant_read_node {
    pm_node_t base;
    pm_constant_id_t name;
} pm_constant_read_node_t;

// ConstantTargetNode
//
// Type: PM_CONSTANT_TARGET_NODE
typedef struct pm_constant_target_node {
    pm_node_t base;
    pm_constant_id_t name;
} pm_constant_target_node_t;

// ConstantWriteNode
//
// Type: PM_CONSTANT_WRITE_NODE
typedef struct pm_constant_write_node {
    pm_node_t base;
    pm_constant_id_t name;
    pm_location_t name_loc;
    struct pm_node *value;
    pm_location_t operator_loc;
} pm_constant_write_node_t;

// DefNode
//
// Type: PM_DEF_NODE
typedef struct pm_def_node {
    pm_node_t base;
    pm_constant_id_t name;
    pm_location_t name_loc;
    struct pm_node *receiver;
    struct pm_parameters_node *parameters;
    struct pm_node *body;
    pm_constant_id_list_t locals;
    pm_location_t def_keyword_loc;
    pm_location_t operator_loc;
    pm_location_t lparen_loc;
    pm_location_t rparen_loc;
    pm_location_t equal_loc;
    pm_location_t end_keyword_loc;
} pm_def_node_t;

// DefinedNode
//
// Type: PM_DEFINED_NODE
typedef struct pm_defined_node {
    pm_node_t base;
    pm_location_t lparen_loc;
    struct pm_node *value;
    pm_location_t rparen_loc;
    pm_location_t keyword_loc;
} pm_defined_node_t;

// ElseNode
//
// Type: PM_ELSE_NODE
typedef struct pm_else_node {
    pm_node_t base;
    pm_location_t else_keyword_loc;
    struct pm_statements_node *statements;
    pm_location_t end_keyword_loc;
} pm_else_node_t;

// EmbeddedStatementsNode
//
// Type: PM_EMBEDDED_STATEMENTS_NODE
typedef struct pm_embedded_statements_node {
    pm_node_t base;
    pm_location_t opening_loc;
    struct pm_statements_node *statements;
    pm_location_t closing_loc;
} pm_embedded_statements_node_t;

// EmbeddedVariableNode
//
// Type: PM_EMBEDDED_VARIABLE_NODE
typedef struct pm_embedded_variable_node {
    pm_node_t base;
    pm_location_t operator_loc;
    struct pm_node *variable;
} pm_embedded_variable_node_t;

// EnsureNode
//
// Type: PM_ENSURE_NODE
typedef struct pm_ensure_node {
    pm_node_t base;
    pm_location_t ensure_keyword_loc;
    struct pm_statements_node *statements;
    pm_location_t end_keyword_loc;
} pm_ensure_node_t;

// FalseNode
//
// Type: PM_FALSE_NODE
typedef struct pm_false_node {
    pm_node_t base;
} pm_false_node_t;

// FindPatternNode
//
// Type: PM_FIND_PATTERN_NODE
typedef struct pm_find_pattern_node {
    pm_node_t base;
    struct pm_node *constant;
    struct pm_node *left;
    struct pm_node_list requireds;
    struct pm_node *right;
    pm_location_t opening_loc;
    pm_location_t closing_loc;
} pm_find_pattern_node_t;

// FlipFlopNode
//
// Type: PM_FLIP_FLOP_NODE
// Flags:
//    PM_RANGE_FLAGS_EXCLUDE_END
typedef struct pm_flip_flop_node {
    pm_node_t base;
    struct pm_node *left;
    struct pm_node *right;
    pm_location_t operator_loc;
} pm_flip_flop_node_t;

// FloatNode
//
// Type: PM_FLOAT_NODE
typedef struct pm_float_node {
    pm_node_t base;
} pm_float_node_t;

// ForNode
//
// Type: PM_FOR_NODE
typedef struct pm_for_node {
    pm_node_t base;
    struct pm_node *index;
    struct pm_node *collection;
    struct pm_statements_node *statements;
    pm_location_t for_keyword_loc;
    pm_location_t in_keyword_loc;
    pm_location_t do_keyword_loc;
    pm_location_t end_keyword_loc;
} pm_for_node_t;

// ForwardingArgumentsNode
//
// Type: PM_FORWARDING_ARGUMENTS_NODE
typedef struct pm_forwarding_arguments_node {
    pm_node_t base;
} pm_forwarding_arguments_node_t;

// ForwardingParameterNode
//
// Type: PM_FORWARDING_PARAMETER_NODE
typedef struct pm_forwarding_parameter_node {
    pm_node_t base;
} pm_forwarding_parameter_node_t;

// ForwardingSuperNode
//
// Type: PM_FORWARDING_SUPER_NODE
typedef struct pm_forwarding_super_node {
    pm_node_t base;
    struct pm_block_node *block;
} pm_forwarding_super_node_t;

// GlobalVariableAndWriteNode
//
// Type: PM_GLOBAL_VARIABLE_AND_WRITE_NODE
typedef struct pm_global_variable_and_write_node {
    pm_node_t base;
    pm_constant_id_t name;
    pm_location_t name_loc;
    pm_location_t operator_loc;
    struct pm_node *value;
} pm_global_variable_and_write_node_t;

// GlobalVariableOperatorWriteNode
//
// Type: PM_GLOBAL_VARIABLE_OPERATOR_WRITE_NODE
typedef struct pm_global_variable_operator_write_node {
    pm_node_t base;
    pm_constant_id_t name;
    pm_location_t name_loc;
    pm_location_t operator_loc;
    struct pm_node *value;
    pm_constant_id_t operator;
} pm_global_variable_operator_write_node_t;

// GlobalVariableOrWriteNode
//
// Type: PM_GLOBAL_VARIABLE_OR_WRITE_NODE
typedef struct pm_global_variable_or_write_node {
    pm_node_t base;
    pm_constant_id_t name;
    pm_location_t name_loc;
    pm_location_t operator_loc;
    struct pm_node *value;
} pm_global_variable_or_write_node_t;

// GlobalVariableReadNode
//
// Type: PM_GLOBAL_VARIABLE_READ_NODE
typedef struct pm_global_variable_read_node {
    pm_node_t base;
    pm_constant_id_t name;
} pm_global_variable_read_node_t;

// GlobalVariableTargetNode
//
// Type: PM_GLOBAL_VARIABLE_TARGET_NODE
typedef struct pm_global_variable_target_node {
    pm_node_t base;
    pm_constant_id_t name;
} pm_global_variable_target_node_t;

// GlobalVariableWriteNode
//
// Type: PM_GLOBAL_VARIABLE_WRITE_NODE
typedef struct pm_global_variable_write_node {
    pm_node_t base;
    pm_constant_id_t name;
    pm_location_t name_loc;
    struct pm_node *value;
    pm_location_t operator_loc;
} pm_global_variable_write_node_t;

// HashNode
//
// Type: PM_HASH_NODE
typedef struct pm_hash_node {
    pm_node_t base;
    pm_location_t opening_loc;
    struct pm_node_list elements;
    pm_location_t closing_loc;
} pm_hash_node_t;

// HashPatternNode
//
// Type: PM_HASH_PATTERN_NODE
typedef struct pm_hash_pattern_node {
    pm_node_t base;
    struct pm_node *constant;
    struct pm_node_list elements;
    struct pm_node *rest;
    pm_location_t opening_loc;
    pm_location_t closing_loc;
} pm_hash_pattern_node_t;

// IfNode
//
// Type: PM_IF_NODE
typedef struct pm_if_node {
    pm_node_t base;
    pm_location_t if_keyword_loc;
    struct pm_node *predicate;
    struct pm_statements_node *statements;
    struct pm_node *consequent;
    pm_location_t end_keyword_loc;
} pm_if_node_t;

// ImaginaryNode
//
// Type: PM_IMAGINARY_NODE
typedef struct pm_imaginary_node {
    pm_node_t base;
    struct pm_node *numeric;
} pm_imaginary_node_t;

// ImplicitNode
//
// Type: PM_IMPLICIT_NODE
typedef struct pm_implicit_node {
    pm_node_t base;
    struct pm_node *value;
} pm_implicit_node_t;

// InNode
//
// Type: PM_IN_NODE
typedef struct pm_in_node {
    pm_node_t base;
    struct pm_node *pattern;
    struct pm_statements_node *statements;
    pm_location_t in_loc;
    pm_location_t then_loc;
} pm_in_node_t;

// IndexAndWriteNode
//
// Type: PM_INDEX_AND_WRITE_NODE
// Flags:
//    PM_CALL_NODE_FLAGS_SAFE_NAVIGATION
//    PM_CALL_NODE_FLAGS_VARIABLE_CALL
typedef struct pm_index_and_write_node {
    pm_node_t base;
    struct pm_node *receiver;
    pm_location_t call_operator_loc;
    pm_location_t opening_loc;
    struct pm_arguments_node *arguments;
    pm_location_t closing_loc;
    struct pm_node *block;
    pm_location_t operator_loc;
    struct pm_node *value;
} pm_index_and_write_node_t;

// IndexOperatorWriteNode
//
// Type: PM_INDEX_OPERATOR_WRITE_NODE
// Flags:
//    PM_CALL_NODE_FLAGS_SAFE_NAVIGATION
//    PM_CALL_NODE_FLAGS_VARIABLE_CALL
typedef struct pm_index_operator_write_node {
    pm_node_t base;
    struct pm_node *receiver;
    pm_location_t call_operator_loc;
    pm_location_t opening_loc;
    struct pm_arguments_node *arguments;
    pm_location_t closing_loc;
    struct pm_node *block;
    pm_constant_id_t operator;
    pm_location_t operator_loc;
    struct pm_node *value;
} pm_index_operator_write_node_t;

// IndexOrWriteNode
//
// Type: PM_INDEX_OR_WRITE_NODE
// Flags:
//    PM_CALL_NODE_FLAGS_SAFE_NAVIGATION
//    PM_CALL_NODE_FLAGS_VARIABLE_CALL
typedef struct pm_index_or_write_node {
    pm_node_t base;
    struct pm_node *receiver;
    pm_location_t call_operator_loc;
    pm_location_t opening_loc;
    struct pm_arguments_node *arguments;
    pm_location_t closing_loc;
    struct pm_node *block;
    pm_location_t operator_loc;
    struct pm_node *value;
} pm_index_or_write_node_t;

// InstanceVariableAndWriteNode
//
// Type: PM_INSTANCE_VARIABLE_AND_WRITE_NODE
typedef struct pm_instance_variable_and_write_node {
    pm_node_t base;
    pm_constant_id_t name;
    pm_location_t name_loc;
    pm_location_t operator_loc;
    struct pm_node *value;
} pm_instance_variable_and_write_node_t;

// InstanceVariableOperatorWriteNode
//
// Type: PM_INSTANCE_VARIABLE_OPERATOR_WRITE_NODE
typedef struct pm_instance_variable_operator_write_node {
    pm_node_t base;
    pm_constant_id_t name;
    pm_location_t name_loc;
    pm_location_t operator_loc;
    struct pm_node *value;
    pm_constant_id_t operator;
} pm_instance_variable_operator_write_node_t;

// InstanceVariableOrWriteNode
//
// Type: PM_INSTANCE_VARIABLE_OR_WRITE_NODE
typedef struct pm_instance_variable_or_write_node {
    pm_node_t base;
    pm_constant_id_t name;
    pm_location_t name_loc;
    pm_location_t operator_loc;
    struct pm_node *value;
} pm_instance_variable_or_write_node_t;

// InstanceVariableReadNode
//
// Type: PM_INSTANCE_VARIABLE_READ_NODE
typedef struct pm_instance_variable_read_node {
    pm_node_t base;
    pm_constant_id_t name;
} pm_instance_variable_read_node_t;

// InstanceVariableTargetNode
//
// Type: PM_INSTANCE_VARIABLE_TARGET_NODE
typedef struct pm_instance_variable_target_node {
    pm_node_t base;
    pm_constant_id_t name;
} pm_instance_variable_target_node_t;

// InstanceVariableWriteNode
//
// Type: PM_INSTANCE_VARIABLE_WRITE_NODE
typedef struct pm_instance_variable_write_node {
    pm_node_t base;
    pm_constant_id_t name;
    pm_location_t name_loc;
    struct pm_node *value;
    pm_location_t operator_loc;
} pm_instance_variable_write_node_t;

// IntegerNode
//
// Type: PM_INTEGER_NODE
// Flags:
//    PM_INTEGER_BASE_FLAGS_BINARY
//    PM_INTEGER_BASE_FLAGS_OCTAL
//    PM_INTEGER_BASE_FLAGS_DECIMAL
//    PM_INTEGER_BASE_FLAGS_HEXADECIMAL
typedef struct pm_integer_node {
    pm_node_t base;
} pm_integer_node_t;

// InterpolatedMatchLastLineNode
//
// Type: PM_INTERPOLATED_MATCH_LAST_LINE_NODE
// Flags:
//    PM_REGULAR_EXPRESSION_FLAGS_IGNORE_CASE
//    PM_REGULAR_EXPRESSION_FLAGS_EXTENDED
//    PM_REGULAR_EXPRESSION_FLAGS_MULTI_LINE
//    PM_REGULAR_EXPRESSION_FLAGS_ONCE
//    PM_REGULAR_EXPRESSION_FLAGS_EUC_JP
//    PM_REGULAR_EXPRESSION_FLAGS_ASCII_8BIT
//    PM_REGULAR_EXPRESSION_FLAGS_WINDOWS_31J
//    PM_REGULAR_EXPRESSION_FLAGS_UTF_8
typedef struct pm_interpolated_match_last_line_node {
    pm_node_t base;
    pm_location_t opening_loc;
    struct pm_node_list parts;
    pm_location_t closing_loc;
} pm_interpolated_match_last_line_node_t;

// InterpolatedRegularExpressionNode
//
// Type: PM_INTERPOLATED_REGULAR_EXPRESSION_NODE
// Flags:
//    PM_REGULAR_EXPRESSION_FLAGS_IGNORE_CASE
//    PM_REGULAR_EXPRESSION_FLAGS_EXTENDED
//    PM_REGULAR_EXPRESSION_FLAGS_MULTI_LINE
//    PM_REGULAR_EXPRESSION_FLAGS_ONCE
//    PM_REGULAR_EXPRESSION_FLAGS_EUC_JP
//    PM_REGULAR_EXPRESSION_FLAGS_ASCII_8BIT
//    PM_REGULAR_EXPRESSION_FLAGS_WINDOWS_31J
//    PM_REGULAR_EXPRESSION_FLAGS_UTF_8
typedef struct pm_interpolated_regular_expression_node {
    pm_node_t base;
    pm_location_t opening_loc;
    struct pm_node_list parts;
    pm_location_t closing_loc;
} pm_interpolated_regular_expression_node_t;

// InterpolatedStringNode
//
// Type: PM_INTERPOLATED_STRING_NODE
typedef struct pm_interpolated_string_node {
    pm_node_t base;
    pm_location_t opening_loc;
    struct pm_node_list parts;
    pm_location_t closing_loc;
} pm_interpolated_string_node_t;

// InterpolatedSymbolNode
//
// Type: PM_INTERPOLATED_SYMBOL_NODE
typedef struct pm_interpolated_symbol_node {
    pm_node_t base;
    pm_location_t opening_loc;
    struct pm_node_list parts;
    pm_location_t closing_loc;
} pm_interpolated_symbol_node_t;

// InterpolatedXStringNode
//
// Type: PM_INTERPOLATED_X_STRING_NODE
typedef struct pm_interpolated_x_string_node {
    pm_node_t base;
    pm_location_t opening_loc;
    struct pm_node_list parts;
    pm_location_t closing_loc;
} pm_interpolated_x_string_node_t;

// KeywordHashNode
//
// Type: PM_KEYWORD_HASH_NODE
typedef struct pm_keyword_hash_node {
    pm_node_t base;
    struct pm_node_list elements;
} pm_keyword_hash_node_t;

// KeywordParameterNode
//
// Type: PM_KEYWORD_PARAMETER_NODE
typedef struct pm_keyword_parameter_node {
    pm_node_t base;
    pm_constant_id_t name;
    pm_location_t name_loc;
    struct pm_node *value;
} pm_keyword_parameter_node_t;

// KeywordRestParameterNode
//
// Type: PM_KEYWORD_REST_PARAMETER_NODE
typedef struct pm_keyword_rest_parameter_node {
    pm_node_t base;
    pm_constant_id_t name;
    pm_location_t name_loc;
    pm_location_t operator_loc;
} pm_keyword_rest_parameter_node_t;

// LambdaNode
//
// Type: PM_LAMBDA_NODE
typedef struct pm_lambda_node {
    pm_node_t base;
    pm_constant_id_list_t locals;
    pm_location_t operator_loc;
    pm_location_t opening_loc;
    pm_location_t closing_loc;
    struct pm_block_parameters_node *parameters;
    struct pm_node *body;
} pm_lambda_node_t;

// LocalVariableAndWriteNode
//
// Type: PM_LOCAL_VARIABLE_AND_WRITE_NODE
typedef struct pm_local_variable_and_write_node {
    pm_node_t base;
    pm_location_t name_loc;
    pm_location_t operator_loc;
    struct pm_node *value;
    pm_constant_id_t name;
    uint32_t depth;
} pm_local_variable_and_write_node_t;

// LocalVariableOperatorWriteNode
//
// Type: PM_LOCAL_VARIABLE_OPERATOR_WRITE_NODE
typedef struct pm_local_variable_operator_write_node {
    pm_node_t base;
    pm_location_t name_loc;
    pm_location_t operator_loc;
    struct pm_node *value;
    pm_constant_id_t name;
    pm_constant_id_t operator;
    uint32_t depth;
} pm_local_variable_operator_write_node_t;

// LocalVariableOrWriteNode
//
// Type: PM_LOCAL_VARIABLE_OR_WRITE_NODE
typedef struct pm_local_variable_or_write_node {
    pm_node_t base;
    pm_location_t name_loc;
    pm_location_t operator_loc;
    struct pm_node *value;
    pm_constant_id_t name;
    uint32_t depth;
} pm_local_variable_or_write_node_t;

// LocalVariableReadNode
//
// Type: PM_LOCAL_VARIABLE_READ_NODE
typedef struct pm_local_variable_read_node {
    pm_node_t base;
    pm_constant_id_t name;
    uint32_t depth;
} pm_local_variable_read_node_t;

// LocalVariableTargetNode
//
// Type: PM_LOCAL_VARIABLE_TARGET_NODE
typedef struct pm_local_variable_target_node {
    pm_node_t base;
    pm_constant_id_t name;
    uint32_t depth;
} pm_local_variable_target_node_t;

// LocalVariableWriteNode
//
// Type: PM_LOCAL_VARIABLE_WRITE_NODE
typedef struct pm_local_variable_write_node {
    pm_node_t base;
    pm_constant_id_t name;
    uint32_t depth;
    pm_location_t name_loc;
    struct pm_node *value;
    pm_location_t operator_loc;
} pm_local_variable_write_node_t;

// MatchLastLineNode
//
// Type: PM_MATCH_LAST_LINE_NODE
// Flags:
//    PM_REGULAR_EXPRESSION_FLAGS_IGNORE_CASE
//    PM_REGULAR_EXPRESSION_FLAGS_EXTENDED
//    PM_REGULAR_EXPRESSION_FLAGS_MULTI_LINE
//    PM_REGULAR_EXPRESSION_FLAGS_ONCE
//    PM_REGULAR_EXPRESSION_FLAGS_EUC_JP
//    PM_REGULAR_EXPRESSION_FLAGS_ASCII_8BIT
//    PM_REGULAR_EXPRESSION_FLAGS_WINDOWS_31J
//    PM_REGULAR_EXPRESSION_FLAGS_UTF_8
typedef struct pm_match_last_line_node {
    pm_node_t base;
    pm_location_t opening_loc;
    pm_location_t content_loc;
    pm_location_t closing_loc;
    pm_string_t unescaped;
} pm_match_last_line_node_t;

// MatchPredicateNode
//
// Type: PM_MATCH_PREDICATE_NODE
typedef struct pm_match_predicate_node {
    pm_node_t base;
    struct pm_node *value;
    struct pm_node *pattern;
    pm_location_t operator_loc;
} pm_match_predicate_node_t;

// MatchRequiredNode
//
// Type: PM_MATCH_REQUIRED_NODE
typedef struct pm_match_required_node {
    pm_node_t base;
    struct pm_node *value;
    struct pm_node *pattern;
    pm_location_t operator_loc;
} pm_match_required_node_t;

// MatchWriteNode
//
// Type: PM_MATCH_WRITE_NODE
typedef struct pm_match_write_node {
    pm_node_t base;
    struct pm_call_node *call;
    pm_constant_id_list_t locals;
} pm_match_write_node_t;

// MissingNode
//
// Type: PM_MISSING_NODE
typedef struct pm_missing_node {
    pm_node_t base;
} pm_missing_node_t;

// ModuleNode
//
// Type: PM_MODULE_NODE
typedef struct pm_module_node {
    pm_node_t base;
    pm_constant_id_list_t locals;
    pm_location_t module_keyword_loc;
    struct pm_node *constant_path;
    struct pm_node *body;
    pm_location_t end_keyword_loc;
    pm_constant_id_t name;
} pm_module_node_t;

// MultiTargetNode
//
// Type: PM_MULTI_TARGET_NODE
typedef struct pm_multi_target_node {
    pm_node_t base;
    struct pm_node_list lefts;
    struct pm_node *rest;
    struct pm_node_list rights;
    pm_location_t lparen_loc;
    pm_location_t rparen_loc;
} pm_multi_target_node_t;

// MultiWriteNode
//
// Type: PM_MULTI_WRITE_NODE
typedef struct pm_multi_write_node {
    pm_node_t base;
    struct pm_node_list lefts;
    struct pm_node *rest;
    struct pm_node_list rights;
    pm_location_t lparen_loc;
    pm_location_t rparen_loc;
    pm_location_t operator_loc;
    struct pm_node *value;
} pm_multi_write_node_t;

// NextNode
//
// Type: PM_NEXT_NODE
typedef struct pm_next_node {
    pm_node_t base;
    struct pm_arguments_node *arguments;
    pm_location_t keyword_loc;
} pm_next_node_t;

// NilNode
//
// Type: PM_NIL_NODE
typedef struct pm_nil_node {
    pm_node_t base;
} pm_nil_node_t;

// NoKeywordsParameterNode
//
// Type: PM_NO_KEYWORDS_PARAMETER_NODE
typedef struct pm_no_keywords_parameter_node {
    pm_node_t base;
    pm_location_t operator_loc;
    pm_location_t keyword_loc;
} pm_no_keywords_parameter_node_t;

// NumberedReferenceReadNode
//
// Type: PM_NUMBERED_REFERENCE_READ_NODE
typedef struct pm_numbered_reference_read_node {
    pm_node_t base;
    uint32_t number;
} pm_numbered_reference_read_node_t;

// OptionalParameterNode
//
// Type: PM_OPTIONAL_PARAMETER_NODE
typedef struct pm_optional_parameter_node {
    pm_node_t base;
    pm_constant_id_t name;
    pm_location_t name_loc;
    pm_location_t operator_loc;
    struct pm_node *value;
} pm_optional_parameter_node_t;

// OrNode
//
// Type: PM_OR_NODE
typedef struct pm_or_node {
    pm_node_t base;
    struct pm_node *left;
    struct pm_node *right;
    pm_location_t operator_loc;
} pm_or_node_t;

// ParametersNode
//
// Type: PM_PARAMETERS_NODE
typedef struct pm_parameters_node {
    pm_node_t base;
    struct pm_node_list requireds;
    struct pm_node_list optionals;
    struct pm_rest_parameter_node *rest;
    struct pm_node_list posts;
    struct pm_node_list keywords;
    struct pm_node *keyword_rest;
    struct pm_block_parameter_node *block;
} pm_parameters_node_t;

// ParenthesesNode
//
// Type: PM_PARENTHESES_NODE
typedef struct pm_parentheses_node {
    pm_node_t base;
    struct pm_node *body;
    pm_location_t opening_loc;
    pm_location_t closing_loc;
} pm_parentheses_node_t;

// PinnedExpressionNode
//
// Type: PM_PINNED_EXPRESSION_NODE
typedef struct pm_pinned_expression_node {
    pm_node_t base;
    struct pm_node *expression;
    pm_location_t operator_loc;
    pm_location_t lparen_loc;
    pm_location_t rparen_loc;
} pm_pinned_expression_node_t;

// PinnedVariableNode
//
// Type: PM_PINNED_VARIABLE_NODE
typedef struct pm_pinned_variable_node {
    pm_node_t base;
    struct pm_node *variable;
    pm_location_t operator_loc;
} pm_pinned_variable_node_t;

// PostExecutionNode
//
// Type: PM_POST_EXECUTION_NODE
typedef struct pm_post_execution_node {
    pm_node_t base;
    struct pm_statements_node *statements;
    pm_location_t keyword_loc;
    pm_location_t opening_loc;
    pm_location_t closing_loc;
} pm_post_execution_node_t;

// PreExecutionNode
//
// Type: PM_PRE_EXECUTION_NODE
typedef struct pm_pre_execution_node {
    pm_node_t base;
    struct pm_statements_node *statements;
    pm_location_t keyword_loc;
    pm_location_t opening_loc;
    pm_location_t closing_loc;
} pm_pre_execution_node_t;

// ProgramNode
//
// Type: PM_PROGRAM_NODE
typedef struct pm_program_node {
    pm_node_t base;
    pm_constant_id_list_t locals;
    struct pm_statements_node *statements;
} pm_program_node_t;

// RangeNode
//
// Type: PM_RANGE_NODE
// Flags:
//    PM_RANGE_FLAGS_EXCLUDE_END
typedef struct pm_range_node {
    pm_node_t base;
    struct pm_node *left;
    struct pm_node *right;
    pm_location_t operator_loc;
} pm_range_node_t;

// RationalNode
//
// Type: PM_RATIONAL_NODE
typedef struct pm_rational_node {
    pm_node_t base;
    struct pm_node *numeric;
} pm_rational_node_t;

// RedoNode
//
// Type: PM_REDO_NODE
typedef struct pm_redo_node {
    pm_node_t base;
} pm_redo_node_t;

// RegularExpressionNode
//
// Type: PM_REGULAR_EXPRESSION_NODE
// Flags:
//    PM_REGULAR_EXPRESSION_FLAGS_IGNORE_CASE
//    PM_REGULAR_EXPRESSION_FLAGS_EXTENDED
//    PM_REGULAR_EXPRESSION_FLAGS_MULTI_LINE
//    PM_REGULAR_EXPRESSION_FLAGS_ONCE
//    PM_REGULAR_EXPRESSION_FLAGS_EUC_JP
//    PM_REGULAR_EXPRESSION_FLAGS_ASCII_8BIT
//    PM_REGULAR_EXPRESSION_FLAGS_WINDOWS_31J
//    PM_REGULAR_EXPRESSION_FLAGS_UTF_8
typedef struct pm_regular_expression_node {
    pm_node_t base;
    pm_location_t opening_loc;
    pm_location_t content_loc;
    pm_location_t closing_loc;
    pm_string_t unescaped;
} pm_regular_expression_node_t;

// RequiredParameterNode
//
// Type: PM_REQUIRED_PARAMETER_NODE
typedef struct pm_required_parameter_node {
    pm_node_t base;
    pm_constant_id_t name;
} pm_required_parameter_node_t;

// RescueModifierNode
//
// Type: PM_RESCUE_MODIFIER_NODE
typedef struct pm_rescue_modifier_node {
    pm_node_t base;
    struct pm_node *expression;
    pm_location_t keyword_loc;
    struct pm_node *rescue_expression;
} pm_rescue_modifier_node_t;

// RescueNode
//
// Type: PM_RESCUE_NODE
typedef struct pm_rescue_node {
    pm_node_t base;
    pm_location_t keyword_loc;
    struct pm_node_list exceptions;
    pm_location_t operator_loc;
    struct pm_node *reference;
    struct pm_statements_node *statements;
    struct pm_rescue_node *consequent;
} pm_rescue_node_t;

// RestParameterNode
//
// Type: PM_REST_PARAMETER_NODE
typedef struct pm_rest_parameter_node {
    pm_node_t base;
    pm_constant_id_t name;
    pm_location_t name_loc;
    pm_location_t operator_loc;
} pm_rest_parameter_node_t;

// RetryNode
//
// Type: PM_RETRY_NODE
typedef struct pm_retry_node {
    pm_node_t base;
} pm_retry_node_t;

// ReturnNode
//
// Type: PM_RETURN_NODE
typedef struct pm_return_node {
    pm_node_t base;
    pm_location_t keyword_loc;
    struct pm_arguments_node *arguments;
} pm_return_node_t;

// SelfNode
//
// Type: PM_SELF_NODE
typedef struct pm_self_node {
    pm_node_t base;
} pm_self_node_t;

// SingletonClassNode
//
// Type: PM_SINGLETON_CLASS_NODE
typedef struct pm_singleton_class_node {
    pm_node_t base;
    pm_constant_id_list_t locals;
    pm_location_t class_keyword_loc;
    pm_location_t operator_loc;
    struct pm_node *expression;
    struct pm_node *body;
    pm_location_t end_keyword_loc;
} pm_singleton_class_node_t;

// SourceEncodingNode
//
// Type: PM_SOURCE_ENCODING_NODE
typedef struct pm_source_encoding_node {
    pm_node_t base;
} pm_source_encoding_node_t;

// SourceFileNode
//
// Type: PM_SOURCE_FILE_NODE
typedef struct pm_source_file_node {
    pm_node_t base;
    pm_string_t filepath;
} pm_source_file_node_t;

// SourceLineNode
//
// Type: PM_SOURCE_LINE_NODE
typedef struct pm_source_line_node {
    pm_node_t base;
} pm_source_line_node_t;

// SplatNode
//
// Type: PM_SPLAT_NODE
typedef struct pm_splat_node {
    pm_node_t base;
    pm_location_t operator_loc;
    struct pm_node *expression;
} pm_splat_node_t;

// StatementsNode
//
// Type: PM_STATEMENTS_NODE
typedef struct pm_statements_node {
    pm_node_t base;
    struct pm_node_list body;
} pm_statements_node_t;

// StringConcatNode
//
// Type: PM_STRING_CONCAT_NODE
typedef struct pm_string_concat_node {
    pm_node_t base;
    struct pm_node *left;
    struct pm_node *right;
} pm_string_concat_node_t;

// StringNode
//
// Type: PM_STRING_NODE
// Flags:
//    PM_STRING_FLAGS_FROZEN
typedef struct pm_string_node {
    pm_node_t base;
    pm_location_t opening_loc;
    pm_location_t content_loc;
    pm_location_t closing_loc;
    pm_string_t unescaped;
} pm_string_node_t;

// SuperNode
//
// Type: PM_SUPER_NODE
typedef struct pm_super_node {
    pm_node_t base;
    pm_location_t keyword_loc;
    pm_location_t lparen_loc;
    struct pm_arguments_node *arguments;
    pm_location_t rparen_loc;
    struct pm_node *block;
} pm_super_node_t;

// SymbolNode
//
// Type: PM_SYMBOL_NODE
typedef struct pm_symbol_node {
    pm_node_t base;
    pm_location_t opening_loc;
    pm_location_t value_loc;
    pm_location_t closing_loc;
    pm_string_t unescaped;
} pm_symbol_node_t;

// TrueNode
//
// Type: PM_TRUE_NODE
typedef struct pm_true_node {
    pm_node_t base;
} pm_true_node_t;

// UndefNode
//
// Type: PM_UNDEF_NODE
typedef struct pm_undef_node {
    pm_node_t base;
    struct pm_node_list names;
    pm_location_t keyword_loc;
} pm_undef_node_t;

// UnlessNode
//
// Type: PM_UNLESS_NODE
typedef struct pm_unless_node {
    pm_node_t base;
    pm_location_t keyword_loc;
    struct pm_node *predicate;
    struct pm_statements_node *statements;
    struct pm_else_node *consequent;
    pm_location_t end_keyword_loc;
} pm_unless_node_t;

// UntilNode
//
// Type: PM_UNTIL_NODE
// Flags:
//    PM_LOOP_FLAGS_BEGIN_MODIFIER
typedef struct pm_until_node {
    pm_node_t base;
    pm_location_t keyword_loc;
    pm_location_t closing_loc;
    struct pm_node *predicate;
    struct pm_statements_node *statements;
} pm_until_node_t;

// WhenNode
//
// Type: PM_WHEN_NODE
typedef struct pm_when_node {
    pm_node_t base;
    pm_location_t keyword_loc;
    struct pm_node_list conditions;
    struct pm_statements_node *statements;
} pm_when_node_t;

// WhileNode
//
// Type: PM_WHILE_NODE
// Flags:
//    PM_LOOP_FLAGS_BEGIN_MODIFIER
typedef struct pm_while_node {
    pm_node_t base;
    pm_location_t keyword_loc;
    pm_location_t closing_loc;
    struct pm_node *predicate;
    struct pm_statements_node *statements;
} pm_while_node_t;

// XStringNode
//
// Type: PM_X_STRING_NODE
typedef struct pm_x_string_node {
    pm_node_t base;
    pm_location_t opening_loc;
    pm_location_t content_loc;
    pm_location_t closing_loc;
    pm_string_t unescaped;
} pm_x_string_node_t;

// YieldNode
//
// Type: PM_YIELD_NODE
typedef struct pm_yield_node {
    pm_node_t base;
    pm_location_t keyword_loc;
    pm_location_t lparen_loc;
    struct pm_arguments_node *arguments;
    pm_location_t rparen_loc;
} pm_yield_node_t;

// ArgumentsNodeFlags
typedef enum pm_arguments_node_flags {
    PM_ARGUMENTS_NODE_FLAGS_KEYWORD_SPLAT = 1 << 0,
} pm_arguments_node_flags_t;

// CallNodeFlags
typedef enum pm_call_node_flags {
    PM_CALL_NODE_FLAGS_SAFE_NAVIGATION = 1 << 0,
    PM_CALL_NODE_FLAGS_VARIABLE_CALL = 1 << 1,
} pm_call_node_flags_t;

// IntegerBaseFlags
typedef enum pm_integer_base_flags {
    PM_INTEGER_BASE_FLAGS_BINARY = 1 << 0,
    PM_INTEGER_BASE_FLAGS_OCTAL = 1 << 1,
    PM_INTEGER_BASE_FLAGS_DECIMAL = 1 << 2,
    PM_INTEGER_BASE_FLAGS_HEXADECIMAL = 1 << 3,
} pm_integer_base_flags_t;

// LoopFlags
typedef enum pm_loop_flags {
    PM_LOOP_FLAGS_BEGIN_MODIFIER = 1 << 0,
} pm_loop_flags_t;

// RangeFlags
typedef enum pm_range_flags {
    PM_RANGE_FLAGS_EXCLUDE_END = 1 << 0,
} pm_range_flags_t;

// RegularExpressionFlags
typedef enum pm_regular_expression_flags {
    PM_REGULAR_EXPRESSION_FLAGS_IGNORE_CASE = 1 << 0,
    PM_REGULAR_EXPRESSION_FLAGS_EXTENDED = 1 << 1,
    PM_REGULAR_EXPRESSION_FLAGS_MULTI_LINE = 1 << 2,
    PM_REGULAR_EXPRESSION_FLAGS_ONCE = 1 << 3,
    PM_REGULAR_EXPRESSION_FLAGS_EUC_JP = 1 << 4,
    PM_REGULAR_EXPRESSION_FLAGS_ASCII_8BIT = 1 << 5,
    PM_REGULAR_EXPRESSION_FLAGS_WINDOWS_31J = 1 << 6,
    PM_REGULAR_EXPRESSION_FLAGS_UTF_8 = 1 << 7,
} pm_regular_expression_flags_t;

// StringFlags
typedef enum pm_string_flags {
    PM_STRING_FLAGS_FROZEN = 1 << 0,
} pm_string_flags_t;

#define PRISM_SERIALIZE_ONLY_SEMANTICS_FIELDS 1

#endif // PRISM_AST_H
